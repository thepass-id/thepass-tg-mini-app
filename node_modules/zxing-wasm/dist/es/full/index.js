import { g as ki, s as Si, r as ji, a as Wi, w as Oi } from "../core-C2hxqLt7.js";
import { b as Li, c as Zi, e as Gi, f as Xi, d as qi, j as Ki, d as Qi, j as Yi, h as Ji, p as ra, i as ea, t as ta, k as na } from "../core-C2hxqLt7.js";
var ir = (() => {
  var H;
  var R = typeof document < "u" && ((H = document.currentScript) == null ? void 0 : H.tagName.toUpperCase()) === "SCRIPT" ? document.currentScript.src : void 0;
  return function(He = {}) {
    var Lr, f = He, Zr, ar, Ve = new Promise((r, e) => {
      Zr = r, ar = e;
    }), Be = typeof window == "object", Ne = typeof Bun < "u", Cr = typeof importScripts == "function";
    typeof process == "object" && typeof process.versions == "object" && typeof process.versions.node == "string" && process.type != "renderer";
    var Gr = Object.assign({}, f), Xr = "./this.program", j = "";
    function ze(r) {
      return f.locateFile ? f.locateFile(r, j) : j + r;
    }
    var qr, Pr;
    if (Be || Cr || Ne) {
      var Ar;
      Cr ? j = self.location.href : typeof document < "u" && ((Ar = document.currentScript) === null || Ar === void 0 ? void 0 : Ar.tagName.toUpperCase()) === "SCRIPT" && (j = document.currentScript.src), R && (j = R), j.startsWith("blob:") ? j = "" : j = j.substr(0, j.replace(/[?#].*/, "").lastIndexOf("/") + 1), Cr && (Pr = (r) => {
        var e = new XMLHttpRequest();
        return e.open("GET", r, !1), e.responseType = "arraybuffer", e.send(null), new Uint8Array(e.response);
      }), qr = (r) => fetch(r, {
        credentials: "same-origin"
      }).then((e) => e.ok ? e.arrayBuffer() : Promise.reject(new Error(e.status + " : " + e.url)));
    }
    var Le = f.print || console.log.bind(console), Z = f.printErr || console.error.bind(console);
    Object.assign(f, Gr), Gr = null, f.arguments && f.arguments, f.thisProgram && (Xr = f.thisProgram);
    var or = f.wasmBinary, sr, Kr = !1, W, E, G, K, V, $, Qr, Yr;
    function Jr() {
      var r = sr.buffer;
      f.HEAP8 = W = new Int8Array(r), f.HEAP16 = G = new Int16Array(r), f.HEAPU8 = E = new Uint8Array(r), f.HEAPU16 = K = new Uint16Array(r), f.HEAP32 = V = new Int32Array(r), f.HEAPU32 = $ = new Uint32Array(r), f.HEAPF32 = Qr = new Float32Array(r), f.HEAPF64 = Yr = new Float64Array(r);
    }
    var re = [], ee = [], te = [];
    function Ze() {
      var r = f.preRun;
      r && (typeof r == "function" && (r = [r]), r.forEach(qe)), Fr(re);
    }
    function Ge() {
      Fr(ee);
    }
    function Xe() {
      var r = f.postRun;
      r && (typeof r == "function" && (r = [r]), r.forEach(Qe)), Fr(te);
    }
    function qe(r) {
      re.unshift(r);
    }
    function Ke(r) {
      ee.unshift(r);
    }
    function Qe(r) {
      te.unshift(r);
    }
    var B = 0, Q = null;
    function Ye(r) {
      var e;
      B++, (e = f.monitorRunDependencies) === null || e === void 0 || e.call(f, B);
    }
    function Je(r) {
      var e;
      if (B--, (e = f.monitorRunDependencies) === null || e === void 0 || e.call(f, B), B == 0 && Q) {
        var t = Q;
        Q = null, t();
      }
    }
    function Er(r) {
      var e;
      (e = f.onAbort) === null || e === void 0 || e.call(f, r), r = "Aborted(" + r + ")", Z(r), Kr = !0, r += ". Build with -sASSERTIONS for more info.";
      var t = new WebAssembly.RuntimeError(r);
      throw ar(t), t;
    }
    var rt = "data:application/octet-stream;base64,", ne = (r) => r.startsWith(rt);
    function et() {
      var r = "zxing_full.wasm";
      return ne(r) ? r : ze(r);
    }
    var ur;
    function ie(r) {
      if (r == ur && or)
        return new Uint8Array(or);
      if (Pr)
        return Pr(r);
      throw "both async and sync fetching of the wasm failed";
    }
    function tt(r) {
      return or ? Promise.resolve().then(() => ie(r)) : qr(r).then((e) => new Uint8Array(e), () => ie(r));
    }
    function ae(r, e, t) {
      return tt(r).then((n) => WebAssembly.instantiate(n, e)).then(t, (n) => {
        Z(`failed to asynchronously prepare wasm: ${n}`), Er(n);
      });
    }
    function nt(r, e, t, n) {
      return !r && typeof WebAssembly.instantiateStreaming == "function" && !ne(e) && typeof fetch == "function" ? fetch(e, {
        credentials: "same-origin"
      }).then((i) => {
        var a = WebAssembly.instantiateStreaming(i, t);
        return a.then(n, function(s) {
          return Z(`wasm streaming compile failed: ${s}`), Z("falling back to ArrayBuffer instantiation"), ae(e, t, n);
        });
      }) : ae(e, t, n);
    }
    function it() {
      return {
        a: Xn
      };
    }
    function at() {
      var r, e = it();
      function t(i, a) {
        return w = i.exports, sr = w.za, Jr(), he = w.Da, Ke(w.Aa), Je(), w;
      }
      Ye();
      function n(i) {
        t(i.instance);
      }
      if (f.instantiateWasm)
        try {
          return f.instantiateWasm(e, t);
        } catch (i) {
          Z(`Module.instantiateWasm callback failed with error: ${i}`), ar(i);
        }
      return (r = ur) !== null && r !== void 0 || (ur = et()), nt(or, ur, e, n).catch(ar), {};
    }
    var Fr = (r) => {
      r.forEach((e) => e(f));
    };
    f.noExitRuntime;
    var h = (r) => Ee(r), _ = () => Fe(), lr = [], fr = 0, ot = (r) => {
      var e = new Rr(r);
      return e.get_caught() || (e.set_caught(!0), fr--), e.set_rethrown(!1), lr.push(e), ke(r), Pe(r);
    }, D = 0, st = () => {
      d(0, 0);
      var r = lr.pop();
      Re(r.excPtr), D = 0;
    };
    class Rr {
      constructor(e) {
        this.excPtr = e, this.ptr = e - 24;
      }
      set_type(e) {
        $[this.ptr + 4 >> 2] = e;
      }
      get_type() {
        return $[this.ptr + 4 >> 2];
      }
      set_destructor(e) {
        $[this.ptr + 8 >> 2] = e;
      }
      get_destructor() {
        return $[this.ptr + 8 >> 2];
      }
      set_caught(e) {
        e = e ? 1 : 0, W[this.ptr + 12] = e;
      }
      get_caught() {
        return W[this.ptr + 12] != 0;
      }
      set_rethrown(e) {
        e = e ? 1 : 0, W[this.ptr + 13] = e;
      }
      get_rethrown() {
        return W[this.ptr + 13] != 0;
      }
      init(e, t) {
        this.set_adjusted_ptr(0), this.set_type(e), this.set_destructor(t);
      }
      set_adjusted_ptr(e) {
        $[this.ptr + 16 >> 2] = e;
      }
      get_adjusted_ptr() {
        return $[this.ptr + 16 >> 2];
      }
    }
    var ut = (r) => {
      throw D || (D = r), D;
    }, cr = (r) => Ae(r), kr = (r) => {
      var e = D;
      if (!e)
        return cr(0), 0;
      var t = new Rr(e);
      t.set_adjusted_ptr(e);
      var n = t.get_type();
      if (!n)
        return cr(0), e;
      for (var i of r) {
        if (i === 0 || i === n)
          break;
        var a = t.ptr + 16;
        if (Se(i, n, a))
          return cr(i), e;
      }
      return cr(n), e;
    }, lt = () => kr([]), ft = (r) => kr([r]), ct = (r, e) => kr([r, e]), vt = () => {
      var r = lr.pop();
      r || Er("no exception to throw");
      var e = r.excPtr;
      throw r.get_rethrown() || (lr.push(r), r.set_rethrown(!0), r.set_caught(!1), fr++), D = e, D;
    }, dt = (r, e, t) => {
      var n = new Rr(r);
      throw n.init(e, t), D = r, fr++, D;
    }, pt = () => fr, ht = () => {
      Er("");
    }, vr = {}, Sr = (r) => {
      for (; r.length; ) {
        var e = r.pop(), t = r.pop();
        t(e);
      }
    };
    function Y(r) {
      return this.fromWireType($[r >> 2]);
    }
    var X = {}, N = {}, dr = {}, oe, pr = (r) => {
      throw new oe(r);
    }, z = (r, e, t) => {
      r.forEach((o) => dr[o] = e);
      function n(o) {
        var u = t(o);
        u.length !== r.length && pr("Mismatched type converter count");
        for (var l = 0; l < r.length; ++l)
          k(r[l], u[l]);
      }
      var i = new Array(e.length), a = [], s = 0;
      e.forEach((o, u) => {
        N.hasOwnProperty(o) ? i[u] = N[o] : (a.push(o), X.hasOwnProperty(o) || (X[o] = []), X[o].push(() => {
          i[u] = N[o], ++s, s === a.length && n(i);
        }));
      }), a.length === 0 && n(i);
    }, _t = (r) => {
      var e = vr[r];
      delete vr[r];
      var t = e.rawConstructor, n = e.rawDestructor, i = e.fields, a = i.map((s) => s.getterReturnType).concat(i.map((s) => s.setterArgumentType));
      z([r], a, (s) => {
        var o = {};
        return i.forEach((u, l) => {
          var c = u.fieldName, v = s[l], p = u.getter, m = u.getterContext, b = s[l + i.length], P = u.setter, T = u.setterContext;
          o[c] = {
            read: (C) => v.fromWireType(p(m, C)),
            write: (C, L) => {
              var F = [];
              P(T, C, b.toWireType(F, L)), Sr(F);
            }
          };
        }), [{
          name: e.name,
          fromWireType: (u) => {
            var l = {};
            for (var c in o)
              l[c] = o[c].read(u);
            return n(u), l;
          },
          toWireType: (u, l) => {
            for (var c in o)
              if (!(c in l))
                throw new TypeError(`Missing field: "${c}"`);
            var v = t();
            for (c in o)
              o[c].write(v, l[c]);
            return u !== null && u.push(n, v), v;
          },
          argPackAdvance: O,
          readValueFromPointer: Y,
          destructorFunction: n
        }];
      });
    }, gt = (r, e, t, n, i) => {
    }, yt = () => {
      for (var r = new Array(256), e = 0; e < 256; ++e)
        r[e] = String.fromCharCode(e);
      se = r;
    }, se, A = (r) => {
      for (var e = "", t = r; E[t]; )
        e += se[E[t++]];
      return e;
    }, q, y = (r) => {
      throw new q(r);
    };
    function mt(r, e) {
      let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var n = e.name;
      if (r || y(`type "${n}" must have a positive integer typeid pointer`), N.hasOwnProperty(r)) {
        if (t.ignoreDuplicateRegistrations)
          return;
        y(`Cannot register type '${n}' twice`);
      }
      if (N[r] = e, delete dr[r], X.hasOwnProperty(r)) {
        var i = X[r];
        delete X[r], i.forEach((a) => a());
      }
    }
    function k(r, e) {
      let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      return mt(r, e, t);
    }
    var O = 8, $t = (r, e, t, n) => {
      e = A(e), k(r, {
        name: e,
        fromWireType: function(i) {
          return !!i;
        },
        toWireType: function(i, a) {
          return a ? t : n;
        },
        argPackAdvance: O,
        readValueFromPointer: function(i) {
          return this.fromWireType(E[i]);
        },
        destructorFunction: null
      });
    }, bt = (r) => ({
      count: r.count,
      deleteScheduled: r.deleteScheduled,
      preservePointerOnDelete: r.preservePointerOnDelete,
      ptr: r.ptr,
      ptrType: r.ptrType,
      smartPtr: r.smartPtr,
      smartPtrType: r.smartPtrType
    }), jr = (r) => {
      function e(t) {
        return t.$$.ptrType.registeredClass.name;
      }
      y(e(r) + " instance already deleted");
    }, Wr = !1, ue = (r) => {
    }, wt = (r) => {
      r.smartPtr ? r.smartPtrType.rawDestructor(r.smartPtr) : r.ptrType.registeredClass.rawDestructor(r.ptr);
    }, le = (r) => {
      r.count.value -= 1;
      var e = r.count.value === 0;
      e && wt(r);
    }, fe = (r, e, t) => {
      if (e === t)
        return r;
      if (t.baseClass === void 0)
        return null;
      var n = fe(r, e, t.baseClass);
      return n === null ? null : t.downcast(n);
    }, ce = {}, Tt = {}, Ct = (r, e) => {
      for (e === void 0 && y("ptr should not be undefined"); r.baseClass; )
        e = r.upcast(e), r = r.baseClass;
      return e;
    }, Pt = (r, e) => (e = Ct(r, e), Tt[e]), hr = (r, e) => {
      (!e.ptrType || !e.ptr) && pr("makeClassHandle requires ptr and ptrType");
      var t = !!e.smartPtrType, n = !!e.smartPtr;
      return t !== n && pr("Both smartPtrType and smartPtr must be specified"), e.count = {
        value: 1
      }, J(Object.create(r, {
        $$: {
          value: e,
          writable: !0
        }
      }));
    };
    function At(r) {
      var e = this.getPointee(r);
      if (!e)
        return this.destructor(r), null;
      var t = Pt(this.registeredClass, e);
      if (t !== void 0) {
        if (t.$$.count.value === 0)
          return t.$$.ptr = e, t.$$.smartPtr = r, t.clone();
        var n = t.clone();
        return this.destructor(r), n;
      }
      function i() {
        return this.isSmartPointer ? hr(this.registeredClass.instancePrototype, {
          ptrType: this.pointeeType,
          ptr: e,
          smartPtrType: this,
          smartPtr: r
        }) : hr(this.registeredClass.instancePrototype, {
          ptrType: this,
          ptr: r
        });
      }
      var a = this.registeredClass.getActualType(e), s = ce[a];
      if (!s)
        return i.call(this);
      var o;
      this.isConst ? o = s.constPointerType : o = s.pointerType;
      var u = fe(e, this.registeredClass, o.registeredClass);
      return u === null ? i.call(this) : this.isSmartPointer ? hr(o.registeredClass.instancePrototype, {
        ptrType: o,
        ptr: u,
        smartPtrType: this,
        smartPtr: r
      }) : hr(o.registeredClass.instancePrototype, {
        ptrType: o,
        ptr: u
      });
    }
    var J = (r) => typeof FinalizationRegistry > "u" ? (J = (e) => e, r) : (Wr = new FinalizationRegistry((e) => {
      le(e.$$);
    }), J = (e) => {
      var t = e.$$, n = !!t.smartPtr;
      if (n) {
        var i = {
          $$: t
        };
        Wr.register(e, i, e);
      }
      return e;
    }, ue = (e) => Wr.unregister(e), J(r)), _r = [], Et = () => {
      for (; _r.length; ) {
        var r = _r.pop();
        r.$$.deleteScheduled = !1, r.delete();
      }
    }, ve, Ft = () => {
      Object.assign(gr.prototype, {
        isAliasOf(r) {
          if (!(this instanceof gr) || !(r instanceof gr))
            return !1;
          var e = this.$$.ptrType.registeredClass, t = this.$$.ptr;
          r.$$ = r.$$;
          for (var n = r.$$.ptrType.registeredClass, i = r.$$.ptr; e.baseClass; )
            t = e.upcast(t), e = e.baseClass;
          for (; n.baseClass; )
            i = n.upcast(i), n = n.baseClass;
          return e === n && t === i;
        },
        clone() {
          if (this.$$.ptr || jr(this), this.$$.preservePointerOnDelete)
            return this.$$.count.value += 1, this;
          var r = J(Object.create(Object.getPrototypeOf(this), {
            $$: {
              value: bt(this.$$)
            }
          }));
          return r.$$.count.value += 1, r.$$.deleteScheduled = !1, r;
        },
        delete() {
          this.$$.ptr || jr(this), this.$$.deleteScheduled && !this.$$.preservePointerOnDelete && y("Object already scheduled for deletion"), ue(this), le(this.$$), this.$$.preservePointerOnDelete || (this.$$.smartPtr = void 0, this.$$.ptr = void 0);
        },
        isDeleted() {
          return !this.$$.ptr;
        },
        deleteLater() {
          return this.$$.ptr || jr(this), this.$$.deleteScheduled && !this.$$.preservePointerOnDelete && y("Object already scheduled for deletion"), _r.push(this), _r.length === 1 && ve && ve(Et), this.$$.deleteScheduled = !0, this;
        }
      });
    };
    function gr() {
    }
    var rr = (r, e) => Object.defineProperty(e, "name", {
      value: r
    }), de = (r, e, t) => {
      if (r[e].overloadTable === void 0) {
        var n = r[e];
        r[e] = function() {
          for (var i = arguments.length, a = new Array(i), s = 0; s < i; s++)
            a[s] = arguments[s];
          return r[e].overloadTable.hasOwnProperty(a.length) || y(`Function '${t}' called with an invalid number of arguments (${a.length}) - expects one of (${r[e].overloadTable})!`), r[e].overloadTable[a.length].apply(this, a);
        }, r[e].overloadTable = [], r[e].overloadTable[n.argCount] = n;
      }
    }, Or = (r, e, t) => {
      f.hasOwnProperty(r) ? ((t === void 0 || f[r].overloadTable !== void 0 && f[r].overloadTable[t] !== void 0) && y(`Cannot register public name '${r}' twice`), de(f, r, r), f.hasOwnProperty(t) && y(`Cannot register multiple overloads of a function with the same number of arguments (${t})!`), f[r].overloadTable[t] = e) : (f[r] = e, t !== void 0 && (f[r].numArguments = t));
    }, Rt = 48, kt = 57, St = (r) => {
      r = r.replace(/[^a-zA-Z0-9_]/g, "$");
      var e = r.charCodeAt(0);
      return e >= Rt && e <= kt ? `_${r}` : r;
    };
    function jt(r, e, t, n, i, a, s, o) {
      this.name = r, this.constructor = e, this.instancePrototype = t, this.rawDestructor = n, this.baseClass = i, this.getActualType = a, this.upcast = s, this.downcast = o, this.pureVirtualFunctions = [];
    }
    var Dr = (r, e, t) => {
      for (; e !== t; )
        e.upcast || y(`Expected null or instance of ${t.name}, got an instance of ${e.name}`), r = e.upcast(r), e = e.baseClass;
      return r;
    };
    function Wt(r, e) {
      if (e === null)
        return this.isReference && y(`null is not a valid ${this.name}`), 0;
      e.$$ || y(`Cannot pass "${Vr(e)}" as a ${this.name}`), e.$$.ptr || y(`Cannot pass deleted object as a pointer of type ${this.name}`);
      var t = e.$$.ptrType.registeredClass, n = Dr(e.$$.ptr, t, this.registeredClass);
      return n;
    }
    function Ot(r, e) {
      var t;
      if (e === null)
        return this.isReference && y(`null is not a valid ${this.name}`), this.isSmartPointer ? (t = this.rawConstructor(), r !== null && r.push(this.rawDestructor, t), t) : 0;
      (!e || !e.$$) && y(`Cannot pass "${Vr(e)}" as a ${this.name}`), e.$$.ptr || y(`Cannot pass deleted object as a pointer of type ${this.name}`), !this.isConst && e.$$.ptrType.isConst && y(`Cannot convert argument of type ${e.$$.smartPtrType ? e.$$.smartPtrType.name : e.$$.ptrType.name} to parameter type ${this.name}`);
      var n = e.$$.ptrType.registeredClass;
      if (t = Dr(e.$$.ptr, n, this.registeredClass), this.isSmartPointer)
        switch (e.$$.smartPtr === void 0 && y("Passing raw pointer to smart pointer is illegal"), this.sharingPolicy) {
          case 0:
            e.$$.smartPtrType === this ? t = e.$$.smartPtr : y(`Cannot convert argument of type ${e.$$.smartPtrType ? e.$$.smartPtrType.name : e.$$.ptrType.name} to parameter type ${this.name}`);
            break;
          case 1:
            t = e.$$.smartPtr;
            break;
          case 2:
            if (e.$$.smartPtrType === this)
              t = e.$$.smartPtr;
            else {
              var i = e.clone();
              t = this.rawShare(t, x.toHandle(() => i.delete())), r !== null && r.push(this.rawDestructor, t);
            }
            break;
          default:
            y("Unsupporting sharing policy");
        }
      return t;
    }
    function Dt(r, e) {
      if (e === null)
        return this.isReference && y(`null is not a valid ${this.name}`), 0;
      e.$$ || y(`Cannot pass "${Vr(e)}" as a ${this.name}`), e.$$.ptr || y(`Cannot pass deleted object as a pointer of type ${this.name}`), e.$$.ptrType.isConst && y(`Cannot convert argument of type ${e.$$.ptrType.name} to parameter type ${this.name}`);
      var t = e.$$.ptrType.registeredClass, n = Dr(e.$$.ptr, t, this.registeredClass);
      return n;
    }
    var Ut = () => {
      Object.assign(yr.prototype, {
        getPointee(r) {
          return this.rawGetPointee && (r = this.rawGetPointee(r)), r;
        },
        destructor(r) {
          var e;
          (e = this.rawDestructor) === null || e === void 0 || e.call(this, r);
        },
        argPackAdvance: O,
        readValueFromPointer: Y,
        fromWireType: At
      });
    };
    function yr(r, e, t, n, i, a, s, o, u, l, c) {
      this.name = r, this.registeredClass = e, this.isReference = t, this.isConst = n, this.isSmartPointer = i, this.pointeeType = a, this.sharingPolicy = s, this.rawGetPointee = o, this.rawConstructor = u, this.rawShare = l, this.rawDestructor = c, !i && e.baseClass === void 0 ? n ? (this.toWireType = Wt, this.destructorFunction = null) : (this.toWireType = Dt, this.destructorFunction = null) : this.toWireType = Ot;
    }
    var pe = (r, e, t) => {
      f.hasOwnProperty(r) || pr("Replacing nonexistent public symbol"), f[r].overloadTable !== void 0 && t !== void 0 ? f[r].overloadTable[t] = e : (f[r] = e, f[r].argCount = t);
    }, xt = (r, e, t) => {
      r = r.replace(/p/g, "i");
      var n = f["dynCall_" + r];
      return n(e, ...t);
    }, mr = [], he, g = (r) => {
      var e = mr[r];
      return e || (r >= mr.length && (mr.length = r + 1), mr[r] = e = he.get(r)), e;
    }, It = function(r, e) {
      let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
      if (r.includes("j"))
        return xt(r, e, t);
      var n = g(e)(...t);
      return n;
    }, Mt = (r, e) => function() {
      for (var t = arguments.length, n = new Array(t), i = 0; i < t; i++)
        n[i] = arguments[i];
      return It(r, e, n);
    }, S = (r, e) => {
      r = A(r);
      function t() {
        return r.includes("j") ? Mt(r, e) : g(e);
      }
      var n = t();
      return typeof n != "function" && y(`unknown function pointer with signature ${r}: ${e}`), n;
    }, Ht = (r, e) => {
      var t = rr(e, function(n) {
        this.name = e, this.message = n;
        var i = new Error(n).stack;
        i !== void 0 && (this.stack = this.toString() + `
` + i.replace(/^Error(:[^\n]*)?\n/, ""));
      });
      return t.prototype = Object.create(r.prototype), t.prototype.constructor = t, t.prototype.toString = function() {
        return this.message === void 0 ? this.name : `${this.name}: ${this.message}`;
      }, t;
    }, _e, ge = (r) => {
      var e = Ce(r), t = A(e);
      return I(e), t;
    }, $r = (r, e) => {
      var t = [], n = {};
      function i(a) {
        if (!n[a] && !N[a]) {
          if (dr[a]) {
            dr[a].forEach(i);
            return;
          }
          t.push(a), n[a] = !0;
        }
      }
      throw e.forEach(i), new _e(`${r}: ` + t.map(ge).join([", "]));
    }, Vt = (r, e, t, n, i, a, s, o, u, l, c, v, p) => {
      c = A(c), a = S(i, a), o && (o = S(s, o)), l && (l = S(u, l)), p = S(v, p);
      var m = St(c);
      Or(m, function() {
        $r(`Cannot construct ${c} due to unbound types`, [n]);
      }), z([r, e, t], n ? [n] : [], (b) => {
        b = b[0];
        var P, T;
        n ? (P = b.registeredClass, T = P.instancePrototype) : T = gr.prototype;
        var C = rr(c, function() {
          if (Object.getPrototypeOf(this) !== L)
            throw new q("Use 'new' to construct " + c);
          if (F.constructor_body === void 0)
            throw new q(c + " has no accessible constructor");
          for (var Ie = arguments.length, wr = new Array(Ie), Tr = 0; Tr < Ie; Tr++)
            wr[Tr] = arguments[Tr];
          var Me = F.constructor_body[wr.length];
          if (Me === void 0)
            throw new q(`Tried to invoke ctor of ${c} with invalid number of parameters (${wr.length}) - expected (${Object.keys(F.constructor_body).toString()}) parameters instead!`);
          return Me.apply(this, wr);
        }), L = Object.create(T, {
          constructor: {
            value: C
          }
        });
        C.prototype = L;
        var F = new jt(c, C, L, p, P, a, o, l);
        if (F.baseClass) {
          var M, nr;
          (nr = (M = F.baseClass).__derivedClasses) !== null && nr !== void 0 || (M.__derivedClasses = []), F.baseClass.__derivedClasses.push(F);
        }
        var Ri = new yr(c, F, !0, !1, !1), Ue = new yr(c + "*", F, !1, !1, !1), xe = new yr(c + " const*", F, !1, !0, !1);
        return ce[r] = {
          pointerType: Ue,
          constPointerType: xe
        }, pe(m, C), [Ri, Ue, xe];
      });
    }, Ur = (r, e) => {
      for (var t = [], n = 0; n < r; n++)
        t.push($[e + n * 4 >> 2]);
      return t;
    };
    function Bt(r) {
      for (var e = 1; e < r.length; ++e)
        if (r[e] !== null && r[e].destructorFunction === void 0)
          return !0;
      return !1;
    }
    function xr(r, e, t, n, i, a) {
      var s = e.length;
      s < 2 && y("argTypes array size mismatch! Must at least get return value and 'this' types!");
      var o = e[1] !== null && t !== null, u = Bt(e), l = e[0].name !== "void", c = s - 2, v = new Array(c), p = [], m = [], b = function() {
        m.length = 0;
        var P;
        p.length = o ? 2 : 1, p[0] = i, o && (P = e[1].toWireType(m, this), p[1] = P);
        for (var T = 0; T < c; ++T)
          v[T] = e[T + 2].toWireType(m, T < 0 || arguments.length <= T ? void 0 : arguments[T]), p.push(v[T]);
        var C = n(...p);
        function L(F) {
          if (u)
            Sr(m);
          else
            for (var M = o ? 1 : 2; M < e.length; M++) {
              var nr = M === 1 ? P : v[M - 2];
              e[M].destructorFunction !== null && e[M].destructorFunction(nr);
            }
          if (l)
            return e[0].fromWireType(F);
        }
        return L(C);
      };
      return rr(r, b);
    }
    var Nt = (r, e, t, n, i, a) => {
      var s = Ur(e, t);
      i = S(n, i), z([], [r], (o) => {
        o = o[0];
        var u = `constructor ${o.name}`;
        if (o.registeredClass.constructor_body === void 0 && (o.registeredClass.constructor_body = []), o.registeredClass.constructor_body[e - 1] !== void 0)
          throw new q(`Cannot register multiple constructors with identical number of parameters (${e - 1}) for class '${o.name}'! Overload resolution is currently only performed using the parameter count, not actual type info!`);
        return o.registeredClass.constructor_body[e - 1] = () => {
          $r(`Cannot construct ${o.name} due to unbound types`, s);
        }, z([], s, (l) => (l.splice(1, 0, null), o.registeredClass.constructor_body[e - 1] = xr(u, l, null, i, a), [])), [];
      });
    }, ye = (r) => {
      r = r.trim();
      const e = r.indexOf("(");
      return e !== -1 ? r.substr(0, e) : r;
    }, zt = (r, e, t, n, i, a, s, o, u, l) => {
      var c = Ur(t, n);
      e = A(e), e = ye(e), a = S(i, a), z([], [r], (v) => {
        v = v[0];
        var p = `${v.name}.${e}`;
        e.startsWith("@@") && (e = Symbol[e.substring(2)]), o && v.registeredClass.pureVirtualFunctions.push(e);
        function m() {
          $r(`Cannot call ${p} due to unbound types`, c);
        }
        var b = v.registeredClass.instancePrototype, P = b[e];
        return P === void 0 || P.overloadTable === void 0 && P.className !== v.name && P.argCount === t - 2 ? (m.argCount = t - 2, m.className = v.name, b[e] = m) : (de(b, e, p), b[e].overloadTable[t - 2] = m), z([], c, (T) => {
          var C = xr(p, T, v, a, s);
          return b[e].overloadTable === void 0 ? (C.argCount = t - 2, b[e] = C) : b[e].overloadTable[t - 2] = C, [];
        }), [];
      });
    }, Ir = [], U = [], Mr = (r) => {
      r > 9 && --U[r + 1] === 0 && (U[r] = void 0, Ir.push(r));
    }, Lt = () => U.length / 2 - 5 - Ir.length, Zt = () => {
      U.push(0, 1, void 0, 1, null, 1, !0, 1, !1, 1), f.count_emval_handles = Lt;
    }, x = {
      toValue: (r) => (r || y("Cannot use deleted val. handle = " + r), U[r]),
      toHandle: (r) => {
        switch (r) {
          case void 0:
            return 2;
          case null:
            return 4;
          case !0:
            return 6;
          case !1:
            return 8;
          default: {
            const e = Ir.pop() || U.length;
            return U[e] = r, U[e + 1] = 1, e;
          }
        }
      }
    }, me = {
      name: "emscripten::val",
      fromWireType: (r) => {
        var e = x.toValue(r);
        return Mr(r), e;
      },
      toWireType: (r, e) => x.toHandle(e),
      argPackAdvance: O,
      readValueFromPointer: Y,
      destructorFunction: null
    }, Gt = (r) => k(r, me), Xt = (r, e, t) => {
      switch (e) {
        case 1:
          return t ? function(n) {
            return this.fromWireType(W[n]);
          } : function(n) {
            return this.fromWireType(E[n]);
          };
        case 2:
          return t ? function(n) {
            return this.fromWireType(G[n >> 1]);
          } : function(n) {
            return this.fromWireType(K[n >> 1]);
          };
        case 4:
          return t ? function(n) {
            return this.fromWireType(V[n >> 2]);
          } : function(n) {
            return this.fromWireType($[n >> 2]);
          };
        default:
          throw new TypeError(`invalid integer width (${e}): ${r}`);
      }
    }, qt = (r, e, t, n) => {
      e = A(e);
      function i() {
      }
      i.values = {}, k(r, {
        name: e,
        constructor: i,
        fromWireType: function(a) {
          return this.constructor.values[a];
        },
        toWireType: (a, s) => s.value,
        argPackAdvance: O,
        readValueFromPointer: Xt(e, t, n),
        destructorFunction: null
      }), Or(e, i);
    }, Hr = (r, e) => {
      var t = N[r];
      return t === void 0 && y(`${e} has unknown type ${ge(r)}`), t;
    }, Kt = (r, e, t) => {
      var n = Hr(r, "enum");
      e = A(e);
      var i = n.constructor, a = Object.create(n.constructor.prototype, {
        value: {
          value: t
        },
        constructor: {
          value: rr(`${n.name}_${e}`, function() {
          })
        }
      });
      i.values[t] = a, i[e] = a;
    }, Vr = (r) => {
      if (r === null)
        return "null";
      var e = typeof r;
      return e === "object" || e === "array" || e === "function" ? r.toString() : "" + r;
    }, Qt = (r, e) => {
      switch (e) {
        case 4:
          return function(t) {
            return this.fromWireType(Qr[t >> 2]);
          };
        case 8:
          return function(t) {
            return this.fromWireType(Yr[t >> 3]);
          };
        default:
          throw new TypeError(`invalid float width (${e}): ${r}`);
      }
    }, Yt = (r, e, t) => {
      e = A(e), k(r, {
        name: e,
        fromWireType: (n) => n,
        toWireType: (n, i) => i,
        argPackAdvance: O,
        readValueFromPointer: Qt(e, t),
        destructorFunction: null
      });
    }, Jt = (r, e, t, n, i, a, s, o) => {
      var u = Ur(e, t);
      r = A(r), r = ye(r), i = S(n, i), Or(r, function() {
        $r(`Cannot call ${r} due to unbound types`, u);
      }, e - 1), z([], u, (l) => {
        var c = [l[0], null].concat(l.slice(1));
        return pe(r, xr(r, c, null, i, a), e - 1), [];
      });
    }, rn = (r, e, t) => {
      switch (e) {
        case 1:
          return t ? (n) => W[n] : (n) => E[n];
        case 2:
          return t ? (n) => G[n >> 1] : (n) => K[n >> 1];
        case 4:
          return t ? (n) => V[n >> 2] : (n) => $[n >> 2];
        default:
          throw new TypeError(`invalid integer width (${e}): ${r}`);
      }
    }, en = (r, e, t, n, i) => {
      e = A(e);
      var a = (c) => c;
      if (n === 0) {
        var s = 32 - 8 * t;
        a = (c) => c << s >>> s;
      }
      var o = e.includes("unsigned"), u = (c, v) => {
      }, l;
      o ? l = function(c, v) {
        return u(v, this.name), v >>> 0;
      } : l = function(c, v) {
        return u(v, this.name), v;
      }, k(r, {
        name: e,
        fromWireType: a,
        toWireType: l,
        argPackAdvance: O,
        readValueFromPointer: rn(e, t, n !== 0),
        destructorFunction: null
      });
    }, tn = (r, e, t) => {
      var n = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], i = n[e];
      function a(s) {
        var o = $[s >> 2], u = $[s + 4 >> 2];
        return new i(W.buffer, u, o);
      }
      t = A(t), k(r, {
        name: t,
        fromWireType: a,
        argPackAdvance: O,
        readValueFromPointer: a
      }, {
        ignoreDuplicateRegistrations: !0
      });
    }, nn = Object.assign({
      optional: !0
    }, me), an = (r, e) => {
      k(r, nn);
    }, on = (r, e, t, n) => {
      if (!(n > 0)) return 0;
      for (var i = t, a = t + n - 1, s = 0; s < r.length; ++s) {
        var o = r.charCodeAt(s);
        if (o >= 55296 && o <= 57343) {
          var u = r.charCodeAt(++s);
          o = 65536 + ((o & 1023) << 10) | u & 1023;
        }
        if (o <= 127) {
          if (t >= a) break;
          e[t++] = o;
        } else if (o <= 2047) {
          if (t + 1 >= a) break;
          e[t++] = 192 | o >> 6, e[t++] = 128 | o & 63;
        } else if (o <= 65535) {
          if (t + 2 >= a) break;
          e[t++] = 224 | o >> 12, e[t++] = 128 | o >> 6 & 63, e[t++] = 128 | o & 63;
        } else {
          if (t + 3 >= a) break;
          e[t++] = 240 | o >> 18, e[t++] = 128 | o >> 12 & 63, e[t++] = 128 | o >> 6 & 63, e[t++] = 128 | o & 63;
        }
      }
      return e[t] = 0, t - i;
    }, er = (r, e, t) => on(r, E, e, t), sn = (r) => {
      for (var e = 0, t = 0; t < r.length; ++t) {
        var n = r.charCodeAt(t);
        n <= 127 ? e++ : n <= 2047 ? e += 2 : n >= 55296 && n <= 57343 ? (e += 4, ++t) : e += 3;
      }
      return e;
    }, $e = typeof TextDecoder < "u" ? new TextDecoder() : void 0, be = function(r) {
      let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : NaN;
      for (var n = e + t, i = e; r[i] && !(i >= n); ) ++i;
      if (i - e > 16 && r.buffer && $e)
        return $e.decode(r.subarray(e, i));
      for (var a = ""; e < i; ) {
        var s = r[e++];
        if (!(s & 128)) {
          a += String.fromCharCode(s);
          continue;
        }
        var o = r[e++] & 63;
        if ((s & 224) == 192) {
          a += String.fromCharCode((s & 31) << 6 | o);
          continue;
        }
        var u = r[e++] & 63;
        if ((s & 240) == 224 ? s = (s & 15) << 12 | o << 6 | u : s = (s & 7) << 18 | o << 12 | u << 6 | r[e++] & 63, s < 65536)
          a += String.fromCharCode(s);
        else {
          var l = s - 65536;
          a += String.fromCharCode(55296 | l >> 10, 56320 | l & 1023);
        }
      }
      return a;
    }, un = (r, e) => r ? be(E, r, e) : "", ln = (r, e) => {
      e = A(e);
      var t = e === "std::string";
      k(r, {
        name: e,
        fromWireType(n) {
          var i = $[n >> 2], a = n + 4, s;
          if (t)
            for (var o = a, u = 0; u <= i; ++u) {
              var l = a + u;
              if (u == i || E[l] == 0) {
                var c = l - o, v = un(o, c);
                s === void 0 ? s = v : (s += "\0", s += v), o = l + 1;
              }
            }
          else {
            for (var p = new Array(i), u = 0; u < i; ++u)
              p[u] = String.fromCharCode(E[a + u]);
            s = p.join("");
          }
          return I(n), s;
        },
        toWireType(n, i) {
          i instanceof ArrayBuffer && (i = new Uint8Array(i));
          var a, s = typeof i == "string";
          s || i instanceof Uint8Array || i instanceof Uint8ClampedArray || i instanceof Int8Array || y("Cannot pass non-string to std::string"), t && s ? a = sn(i) : a = i.length;
          var o = zr(4 + a + 1), u = o + 4;
          if ($[o >> 2] = a, t && s)
            er(i, u, a + 1);
          else if (s)
            for (var l = 0; l < a; ++l) {
              var c = i.charCodeAt(l);
              c > 255 && (I(u), y("String has UTF-16 code units that do not fit in 8 bits")), E[u + l] = c;
            }
          else
            for (var l = 0; l < a; ++l)
              E[u + l] = i[l];
          return n !== null && n.push(I, o), o;
        },
        argPackAdvance: O,
        readValueFromPointer: Y,
        destructorFunction(n) {
          I(n);
        }
      });
    }, we = typeof TextDecoder < "u" ? new TextDecoder("utf-16le") : void 0, fn = (r, e) => {
      for (var t = r, n = t >> 1, i = n + e / 2; !(n >= i) && K[n]; ) ++n;
      if (t = n << 1, t - r > 32 && we) return we.decode(E.subarray(r, t));
      for (var a = "", s = 0; !(s >= e / 2); ++s) {
        var o = G[r + s * 2 >> 1];
        if (o == 0) break;
        a += String.fromCharCode(o);
      }
      return a;
    }, cn = (r, e, t) => {
      var n;
      if ((n = t) !== null && n !== void 0 || (t = 2147483647), t < 2) return 0;
      t -= 2;
      for (var i = e, a = t < r.length * 2 ? t / 2 : r.length, s = 0; s < a; ++s) {
        var o = r.charCodeAt(s);
        G[e >> 1] = o, e += 2;
      }
      return G[e >> 1] = 0, e - i;
    }, vn = (r) => r.length * 2, dn = (r, e) => {
      for (var t = 0, n = ""; !(t >= e / 4); ) {
        var i = V[r + t * 4 >> 2];
        if (i == 0) break;
        if (++t, i >= 65536) {
          var a = i - 65536;
          n += String.fromCharCode(55296 | a >> 10, 56320 | a & 1023);
        } else
          n += String.fromCharCode(i);
      }
      return n;
    }, pn = (r, e, t) => {
      var n;
      if ((n = t) !== null && n !== void 0 || (t = 2147483647), t < 4) return 0;
      for (var i = e, a = i + t - 4, s = 0; s < r.length; ++s) {
        var o = r.charCodeAt(s);
        if (o >= 55296 && o <= 57343) {
          var u = r.charCodeAt(++s);
          o = 65536 + ((o & 1023) << 10) | u & 1023;
        }
        if (V[e >> 2] = o, e += 4, e + 4 > a) break;
      }
      return V[e >> 2] = 0, e - i;
    }, hn = (r) => {
      for (var e = 0, t = 0; t < r.length; ++t) {
        var n = r.charCodeAt(t);
        n >= 55296 && n <= 57343 && ++t, e += 4;
      }
      return e;
    }, _n = (r, e, t) => {
      t = A(t);
      var n, i, a, s;
      e === 2 ? (n = fn, i = cn, s = vn, a = (o) => K[o >> 1]) : e === 4 && (n = dn, i = pn, s = hn, a = (o) => $[o >> 2]), k(r, {
        name: t,
        fromWireType: (o) => {
          for (var u = $[o >> 2], l, c = o + 4, v = 0; v <= u; ++v) {
            var p = o + 4 + v * e;
            if (v == u || a(p) == 0) {
              var m = p - c, b = n(c, m);
              l === void 0 ? l = b : (l += "\0", l += b), c = p + e;
            }
          }
          return I(o), l;
        },
        toWireType: (o, u) => {
          typeof u != "string" && y(`Cannot pass non-string to C++ string type ${t}`);
          var l = s(u), c = zr(4 + l + e);
          return $[c >> 2] = l / e, i(u, c + 4, l + e), o !== null && o.push(I, c), c;
        },
        argPackAdvance: O,
        readValueFromPointer: Y,
        destructorFunction(o) {
          I(o);
        }
      });
    }, gn = (r, e, t, n, i, a) => {
      vr[r] = {
        name: A(e),
        rawConstructor: S(t, n),
        rawDestructor: S(i, a),
        fields: []
      };
    }, yn = (r, e, t, n, i, a, s, o, u, l) => {
      vr[r].fields.push({
        fieldName: A(e),
        getterReturnType: t,
        getter: S(n, i),
        getterContext: a,
        setterArgumentType: s,
        setter: S(o, u),
        setterContext: l
      });
    }, mn = (r, e) => {
      e = A(e), k(r, {
        isVoid: !0,
        name: e,
        argPackAdvance: 0,
        fromWireType: () => {
        },
        toWireType: (t, n) => {
        }
      });
    }, $n = (r, e, t) => E.copyWithin(r, e, e + t), Br = [], bn = (r, e, t, n) => (r = Br[r], e = x.toValue(e), r(null, e, t, n)), wn = {}, Tn = (r) => {
      var e = wn[r];
      return e === void 0 ? A(r) : e;
    }, Te = () => {
      if (typeof globalThis == "object")
        return globalThis;
      function r(e) {
        e.$$$embind_global$$$ = e;
        var t = typeof $$$embind_global$$$ == "object" && e.$$$embind_global$$$ == e;
        return t || delete e.$$$embind_global$$$, t;
      }
      if (typeof $$$embind_global$$$ == "object" || (typeof global == "object" && r(global) ? $$$embind_global$$$ = global : typeof self == "object" && r(self) && ($$$embind_global$$$ = self), typeof $$$embind_global$$$ == "object"))
        return $$$embind_global$$$;
      throw Error("unable to get global object.");
    }, Cn = (r) => r === 0 ? x.toHandle(Te()) : (r = Tn(r), x.toHandle(Te()[r])), Pn = (r) => {
      var e = Br.length;
      return Br.push(r), e;
    }, An = (r, e) => {
      for (var t = new Array(r), n = 0; n < r; ++n)
        t[n] = Hr($[e + n * 4 >> 2], "parameter " + n);
      return t;
    }, En = Reflect.construct, Fn = (r, e, t) => {
      var n = [], i = r.toWireType(n, t);
      return n.length && ($[e >> 2] = x.toHandle(n)), i;
    }, Rn = (r, e, t) => {
      var n = An(r, e), i = n.shift();
      r--;
      var a = new Array(r), s = (u, l, c, v) => {
        for (var p = 0, m = 0; m < r; ++m)
          a[m] = n[m].readValueFromPointer(v + p), p += n[m].argPackAdvance;
        var b = t === 1 ? En(l, a) : l.apply(u, a);
        return Fn(i, c, b);
      }, o = `methodCaller<(${n.map((u) => u.name).join(", ")}) => ${i.name}>`;
      return Pn(rr(o, s));
    }, kn = (r) => {
      r > 9 && (U[r + 1] += 1);
    }, Sn = (r) => {
      var e = x.toValue(r);
      Sr(e), Mr(r);
    }, jn = (r, e) => {
      r = Hr(r, "_emval_take_value");
      var t = r.readValueFromPointer(e);
      return x.toHandle(t);
    }, Wn = (r, e, t, n) => {
      var i = (/* @__PURE__ */ new Date()).getFullYear(), a = new Date(i, 0, 1), s = new Date(i, 6, 1), o = a.getTimezoneOffset(), u = s.getTimezoneOffset(), l = Math.max(o, u);
      $[r >> 2] = l * 60, V[e >> 2] = +(o != u);
      var c = (m) => {
        var b = m >= 0 ? "-" : "+", P = Math.abs(m), T = String(Math.floor(P / 60)).padStart(2, "0"), C = String(P % 60).padStart(2, "0");
        return `UTC${b}${T}${C}`;
      }, v = c(o), p = c(u);
      u < o ? (er(v, t, 17), er(p, n, 17)) : (er(v, n, 17), er(p, t, 17));
    }, On = () => 2147483648, Dn = (r, e) => Math.ceil(r / e) * e, Un = (r) => {
      var e = sr.buffer, t = (r - e.byteLength + 65535) / 65536 | 0;
      try {
        return sr.grow(t), Jr(), 1;
      } catch {
      }
    }, xn = (r) => {
      var e = E.length;
      r >>>= 0;
      var t = On();
      if (r > t)
        return !1;
      for (var n = 1; n <= 4; n *= 2) {
        var i = e * (1 + 0.2 / n);
        i = Math.min(i, r + 100663296);
        var a = Math.min(t, Dn(Math.max(r, i), 65536)), s = Un(a);
        if (s)
          return !0;
      }
      return !1;
    }, Nr = {}, In = () => Xr || "./this.program", tr = () => {
      if (!tr.strings) {
        var r = (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8", e = {
          USER: "web_user",
          LOGNAME: "web_user",
          PATH: "/",
          PWD: "/",
          HOME: "/home/web_user",
          LANG: r,
          _: In()
        };
        for (var t in Nr)
          Nr[t] === void 0 ? delete e[t] : e[t] = Nr[t];
        var n = [];
        for (var t in e)
          n.push(`${t}=${e[t]}`);
        tr.strings = n;
      }
      return tr.strings;
    }, Mn = (r, e) => {
      for (var t = 0; t < r.length; ++t)
        W[e++] = r.charCodeAt(t);
      W[e] = 0;
    }, Hn = (r, e) => {
      var t = 0;
      return tr().forEach((n, i) => {
        var a = e + t;
        $[r + i * 4 >> 2] = a, Mn(n, a), t += n.length + 1;
      }), 0;
    }, Vn = (r, e) => {
      var t = tr();
      $[r >> 2] = t.length;
      var n = 0;
      return t.forEach((i) => n += i.length + 1), $[e >> 2] = n, 0;
    }, Bn = (r) => 52;
    function Nn(r, e, t, n, i) {
      return 70;
    }
    var zn = [null, [], []], Ln = (r, e) => {
      var t = zn[r];
      e === 0 || e === 10 ? ((r === 1 ? Le : Z)(be(t)), t.length = 0) : t.push(e);
    }, Zn = (r, e, t, n) => {
      for (var i = 0, a = 0; a < t; a++) {
        var s = $[e >> 2], o = $[e + 4 >> 2];
        e += 8;
        for (var u = 0; u < o; u++)
          Ln(r, E[s + u]);
        i += o;
      }
      return $[n >> 2] = i, 0;
    }, Gn = (r) => r;
    oe = f.InternalError = class extends Error {
      constructor(e) {
        super(e), this.name = "InternalError";
      }
    }, yt(), q = f.BindingError = class extends Error {
      constructor(e) {
        super(e), this.name = "BindingError";
      }
    }, Ft(), Ut(), _e = f.UnboundTypeError = Ht(Error, "UnboundTypeError"), Zt();
    var Xn = {
      t: ot,
      x: st,
      a: lt,
      j: ft,
      k: ct,
      Q: vt,
      r: dt,
      ia: pt,
      d: ut,
      ea: ht,
      wa: _t,
      da: gt,
      qa: $t,
      ua: Vt,
      ta: Nt,
      G: zt,
      pa: Gt,
      H: qt,
      q: Kt,
      Y: Yt,
      S: Jt,
      z: en,
      v: tn,
      va: an,
      W: ln,
      R: _n,
      E: gn,
      xa: yn,
      ra: mn,
      la: $n,
      V: bn,
      ya: Mr,
      _: Cn,
      X: Rn,
      Z: kn,
      $: Sn,
      sa: jn,
      fa: Wn,
      ja: xn,
      ga: Hn,
      ha: Vn,
      ka: Bn,
      ba: Nn,
      U: Zn,
      L: hi,
      D: gi,
      N: Jn,
      T: Ci,
      s: ci,
      b: qn,
      F: pi,
      na: mi,
      c: ei,
      ma: $i,
      i: Yn,
      h: oi,
      n: si,
      P: di,
      w: ui,
      K: wi,
      M: vi,
      B: yi,
      J: Pi,
      ca: Ei,
      aa: Fi,
      m: ti,
      g: ri,
      e: Qn,
      f: Kn,
      O: Ti,
      l: ii,
      oa: _i,
      o: ni,
      u: li,
      y: fi,
      C: bi,
      p: ai,
      I: Ai,
      A: Gn
    }, w = at(), Ce = (r) => (Ce = w.Ba)(r), I = f._free = (r) => (I = f._free = w.Ca)(r), zr = f._malloc = (r) => (zr = f._malloc = w.Ea)(r), Pe = (r) => (Pe = w.Fa)(r), d = (r, e) => (d = w.Ga)(r, e), Ae = (r) => (Ae = w.Ha)(r), Ee = (r) => (Ee = w.Ia)(r), Fe = () => (Fe = w.Ja)(), Re = (r) => (Re = w.Ka)(r), ke = (r) => (ke = w.La)(r), Se = (r, e, t) => (Se = w.Ma)(r, e, t);
    f.dynCall_viijii = (r, e, t, n, i, a, s) => (f.dynCall_viijii = w.Na)(r, e, t, n, i, a, s);
    var je = f.dynCall_jiii = (r, e, t, n) => (je = f.dynCall_jiii = w.Oa)(r, e, t, n);
    f.dynCall_jiji = (r, e, t, n, i) => (f.dynCall_jiji = w.Pa)(r, e, t, n, i);
    var We = f.dynCall_jiiii = (r, e, t, n, i) => (We = f.dynCall_jiiii = w.Qa)(r, e, t, n, i);
    f.dynCall_iiiiij = (r, e, t, n, i, a, s) => (f.dynCall_iiiiij = w.Ra)(r, e, t, n, i, a, s), f.dynCall_iiiiijj = (r, e, t, n, i, a, s, o, u) => (f.dynCall_iiiiijj = w.Sa)(r, e, t, n, i, a, s, o, u), f.dynCall_iiiiiijj = (r, e, t, n, i, a, s, o, u, l) => (f.dynCall_iiiiiijj = w.Ta)(r, e, t, n, i, a, s, o, u, l);
    function qn(r, e) {
      var t = _();
      try {
        return g(r)(e);
      } catch (n) {
        if (h(t), n !== n + 0) throw n;
        d(1, 0);
      }
    }
    function Kn(r, e, t, n) {
      var i = _();
      try {
        g(r)(e, t, n);
      } catch (a) {
        if (h(i), a !== a + 0) throw a;
        d(1, 0);
      }
    }
    function Qn(r, e, t) {
      var n = _();
      try {
        g(r)(e, t);
      } catch (i) {
        if (h(n), i !== i + 0) throw i;
        d(1, 0);
      }
    }
    function Yn(r, e, t, n) {
      var i = _();
      try {
        return g(r)(e, t, n);
      } catch (a) {
        if (h(i), a !== a + 0) throw a;
        d(1, 0);
      }
    }
    function Jn(r, e, t, n, i) {
      var a = _();
      try {
        return g(r)(e, t, n, i);
      } catch (s) {
        if (h(a), s !== s + 0) throw s;
        d(1, 0);
      }
    }
    function ri(r, e) {
      var t = _();
      try {
        g(r)(e);
      } catch (n) {
        if (h(t), n !== n + 0) throw n;
        d(1, 0);
      }
    }
    function ei(r, e, t) {
      var n = _();
      try {
        return g(r)(e, t);
      } catch (i) {
        if (h(n), i !== i + 0) throw i;
        d(1, 0);
      }
    }
    function ti(r) {
      var e = _();
      try {
        g(r)();
      } catch (t) {
        if (h(e), t !== t + 0) throw t;
        d(1, 0);
      }
    }
    function ni(r, e, t, n, i, a) {
      var s = _();
      try {
        g(r)(e, t, n, i, a);
      } catch (o) {
        if (h(s), o !== o + 0) throw o;
        d(1, 0);
      }
    }
    function ii(r, e, t, n, i) {
      var a = _();
      try {
        g(r)(e, t, n, i);
      } catch (s) {
        if (h(a), s !== s + 0) throw s;
        d(1, 0);
      }
    }
    function ai(r, e, t, n, i, a, s, o, u, l, c) {
      var v = _();
      try {
        g(r)(e, t, n, i, a, s, o, u, l, c);
      } catch (p) {
        if (h(v), p !== p + 0) throw p;
        d(1, 0);
      }
    }
    function oi(r, e, t, n, i) {
      var a = _();
      try {
        return g(r)(e, t, n, i);
      } catch (s) {
        if (h(a), s !== s + 0) throw s;
        d(1, 0);
      }
    }
    function si(r, e, t, n, i, a) {
      var s = _();
      try {
        return g(r)(e, t, n, i, a);
      } catch (o) {
        if (h(s), o !== o + 0) throw o;
        d(1, 0);
      }
    }
    function ui(r, e, t, n, i, a, s) {
      var o = _();
      try {
        return g(r)(e, t, n, i, a, s);
      } catch (u) {
        if (h(o), u !== u + 0) throw u;
        d(1, 0);
      }
    }
    function li(r, e, t, n, i, a, s, o) {
      var u = _();
      try {
        g(r)(e, t, n, i, a, s, o);
      } catch (l) {
        if (h(u), l !== l + 0) throw l;
        d(1, 0);
      }
    }
    function fi(r, e, t, n, i, a, s, o, u) {
      var l = _();
      try {
        g(r)(e, t, n, i, a, s, o, u);
      } catch (c) {
        if (h(l), c !== c + 0) throw c;
        d(1, 0);
      }
    }
    function ci(r) {
      var e = _();
      try {
        return g(r)();
      } catch (t) {
        if (h(e), t !== t + 0) throw t;
        d(1, 0);
      }
    }
    function vi(r, e, t, n, i, a, s, o, u) {
      var l = _();
      try {
        return g(r)(e, t, n, i, a, s, o, u);
      } catch (c) {
        if (h(l), c !== c + 0) throw c;
        d(1, 0);
      }
    }
    function di(r, e, t, n, i, a, s) {
      var o = _();
      try {
        return g(r)(e, t, n, i, a, s);
      } catch (u) {
        if (h(o), u !== u + 0) throw u;
        d(1, 0);
      }
    }
    function pi(r, e, t, n) {
      var i = _();
      try {
        return g(r)(e, t, n);
      } catch (a) {
        if (h(i), a !== a + 0) throw a;
        d(1, 0);
      }
    }
    function hi(r, e, t, n) {
      var i = _();
      try {
        return g(r)(e, t, n);
      } catch (a) {
        if (h(i), a !== a + 0) throw a;
        d(1, 0);
      }
    }
    function _i(r, e, t, n, i, a, s, o) {
      var u = _();
      try {
        g(r)(e, t, n, i, a, s, o);
      } catch (l) {
        if (h(u), l !== l + 0) throw l;
        d(1, 0);
      }
    }
    function gi(r, e, t, n, i, a) {
      var s = _();
      try {
        return g(r)(e, t, n, i, a);
      } catch (o) {
        if (h(s), o !== o + 0) throw o;
        d(1, 0);
      }
    }
    function yi(r, e, t, n, i, a, s, o, u, l) {
      var c = _();
      try {
        return g(r)(e, t, n, i, a, s, o, u, l);
      } catch (v) {
        if (h(c), v !== v + 0) throw v;
        d(1, 0);
      }
    }
    function mi(r, e, t) {
      var n = _();
      try {
        return g(r)(e, t);
      } catch (i) {
        if (h(n), i !== i + 0) throw i;
        d(1, 0);
      }
    }
    function $i(r, e, t, n, i) {
      var a = _();
      try {
        return g(r)(e, t, n, i);
      } catch (s) {
        if (h(a), s !== s + 0) throw s;
        d(1, 0);
      }
    }
    function bi(r, e, t, n, i, a, s, o, u, l) {
      var c = _();
      try {
        g(r)(e, t, n, i, a, s, o, u, l);
      } catch (v) {
        if (h(c), v !== v + 0) throw v;
        d(1, 0);
      }
    }
    function wi(r, e, t, n, i, a, s, o) {
      var u = _();
      try {
        return g(r)(e, t, n, i, a, s, o);
      } catch (l) {
        if (h(u), l !== l + 0) throw l;
        d(1, 0);
      }
    }
    function Ti(r, e, t, n, i, a, s) {
      var o = _();
      try {
        g(r)(e, t, n, i, a, s);
      } catch (u) {
        if (h(o), u !== u + 0) throw u;
        d(1, 0);
      }
    }
    function Ci(r, e, t, n) {
      var i = _();
      try {
        return g(r)(e, t, n);
      } catch (a) {
        if (h(i), a !== a + 0) throw a;
        d(1, 0);
      }
    }
    function Pi(r, e, t, n, i, a, s, o, u, l, c, v) {
      var p = _();
      try {
        return g(r)(e, t, n, i, a, s, o, u, l, c, v);
      } catch (m) {
        if (h(p), m !== m + 0) throw m;
        d(1, 0);
      }
    }
    function Ai(r, e, t, n, i, a, s, o, u, l, c, v, p, m, b, P) {
      var T = _();
      try {
        g(r)(e, t, n, i, a, s, o, u, l, c, v, p, m, b, P);
      } catch (C) {
        if (h(T), C !== C + 0) throw C;
        d(1, 0);
      }
    }
    function Ei(r, e, t, n) {
      var i = _();
      try {
        return je(r, e, t, n);
      } catch (a) {
        if (h(i), a !== a + 0) throw a;
        d(1, 0);
      }
    }
    function Fi(r, e, t, n, i) {
      var a = _();
      try {
        return We(r, e, t, n, i);
      } catch (s) {
        if (h(a), s !== s + 0) throw s;
        d(1, 0);
      }
    }
    var br, Oe;
    Q = function r() {
      br || De(), br || (Q = r);
    };
    function De() {
      if (B > 0 || !Oe && (Oe = 1, Ze(), B > 0))
        return;
      function r() {
        var e;
        br || (br = 1, f.calledRun = 1, !Kr && (Ge(), Zr(f), (e = f.onRuntimeInitialized) === null || e === void 0 || e.call(f), Xe()));
      }
      f.setStatus ? (f.setStatus("Running..."), setTimeout(() => {
        setTimeout(() => f.setStatus(""), 1), r();
      }, 1)) : r();
    }
    if (f.preInit)
      for (typeof f.preInit == "function" && (f.preInit = [f.preInit]); f.preInit.length > 0; )
        f.preInit.pop()();
    return De(), Lr = Ve, Lr;
  };
})();
function Ii(R) {
  return ki(
    ir,
    R
  );
}
function Mi(R) {
  return Si(
    ir,
    R
  );
}
async function Hi(R, H) {
  return ji(
    ir,
    R,
    H
  );
}
async function Vi(R, H) {
  return Wi(
    ir,
    R,
    H
  );
}
async function Bi(R, H) {
  return Oi(
    ir,
    R,
    H
  );
}
export {
  Li as barcodeFormats,
  Zi as binarizers,
  Gi as characterSets,
  Xi as contentTypes,
  qi as defaultDecodeHints,
  Ki as defaultEncodeHints,
  Qi as defaultReaderOptions,
  Yi as defaultWriterOptions,
  Ji as eanAddOnSymbols,
  Ii as getZXingModule,
  ra as purgeZXingModule,
  Vi as readBarcodesFromImageData,
  Hi as readBarcodesFromImageFile,
  ea as readOutputEccLevels,
  Mi as setZXingModuleOverrides,
  ta as textModes,
  Bi as writeBarcodeToImageFile,
  na as writeInputEccLevels
};
