import { g as on, s as sn, w as un } from "../core-C2hxqLt7.js";
import { b as gn, e as mn, j as yn, j as bn, p as wn, k as Tn } from "../core-C2hxqLt7.js";
var br = (() => {
  var G;
  var k = typeof document < "u" && ((G = document.currentScript) == null ? void 0 : G.tagName.toUpperCase()) === "SCRIPT" ? document.currentScript.src : void 0;
  return function(ae = {}) {
    var wr, f = ae, Tr, K, ie = new Promise((r, e) => {
      Tr = r, K = e;
    }), oe = typeof window == "object", se = typeof Bun < "u", sr = typeof importScripts == "function";
    typeof process == "object" && typeof process.versions == "object" && typeof process.versions.node == "string" && process.type != "renderer";
    var $r = Object.assign({}, f), A = "";
    function ue(r) {
      return f.locateFile ? f.locateFile(r, A) : A + r;
    }
    var Ar, ur;
    if (oe || sr || se) {
      var fr;
      sr ? A = self.location.href : typeof document < "u" && ((fr = document.currentScript) === null || fr === void 0 ? void 0 : fr.tagName.toUpperCase()) === "SCRIPT" && (A = document.currentScript.src), k && (A = k), A.startsWith("blob:") ? A = "" : A = A.substr(0, A.replace(/[?#].*/, "").lastIndexOf("/") + 1), sr && (ur = (r) => {
        var e = new XMLHttpRequest();
        return e.open("GET", r, !1), e.responseType = "arraybuffer", e.send(null), new Uint8Array(e.response);
      }), Ar = (r) => fetch(r, {
        credentials: "same-origin"
      }).then((e) => e.ok ? e.arrayBuffer() : Promise.reject(new Error(e.status + " : " + e.url)));
    }
    f.print || console.log.bind(console);
    var H = f.printErr || console.error.bind(console);
    Object.assign(f, $r), $r = null, f.arguments && f.arguments, f.thisProgram && f.thisProgram;
    var q = f.wasmBinary, J, Er = !1, U, b, j, N, D, _, Cr, Rr;
    function Fr() {
      var r = J.buffer;
      f.HEAP8 = U = new Int8Array(r), f.HEAP16 = j = new Int16Array(r), f.HEAPU8 = b = new Uint8Array(r), f.HEAPU16 = N = new Uint16Array(r), f.HEAP32 = D = new Int32Array(r), f.HEAPU32 = _ = new Uint32Array(r), f.HEAPF32 = Cr = new Float32Array(r), f.HEAPF64 = Rr = new Float64Array(r);
    }
    var Pr = [], Wr = [], kr = [];
    function fe() {
      var r = f.preRun;
      r && (typeof r == "function" && (r = [r]), r.forEach(le)), cr(Pr);
    }
    function ve() {
      cr(Wr);
    }
    function ce() {
      var r = f.postRun;
      r && (typeof r == "function" && (r = [r]), r.forEach(_e)), cr(kr);
    }
    function le(r) {
      Pr.unshift(r);
    }
    function de(r) {
      Wr.unshift(r);
    }
    function _e(r) {
      kr.unshift(r);
    }
    var x = 0, B = null;
    function he(r) {
      var e;
      x++, (e = f.monitorRunDependencies) === null || e === void 0 || e.call(f, x);
    }
    function pe(r) {
      var e;
      if (x--, (e = f.monitorRunDependencies) === null || e === void 0 || e.call(f, x), x == 0 && B) {
        var t = B;
        B = null, t();
      }
    }
    function vr(r) {
      var e;
      (e = f.onAbort) === null || e === void 0 || e.call(f, r), r = "Aborted(" + r + ")", H(r), Er = !0, r += ". Build with -sASSERTIONS for more info.";
      var t = new WebAssembly.RuntimeError(r);
      throw K(t), t;
    }
    var ge = "data:application/octet-stream;base64,", Ur = (r) => r.startsWith(ge);
    function me() {
      var r = "zxing_writer.wasm";
      return Ur(r) ? r : ue(r);
    }
    var Q;
    function Sr(r) {
      if (r == Q && q)
        return new Uint8Array(q);
      if (ur)
        return ur(r);
      throw "both async and sync fetching of the wasm failed";
    }
    function ye(r) {
      return q ? Promise.resolve().then(() => Sr(r)) : Ar(r).then((e) => new Uint8Array(e), () => Sr(r));
    }
    function xr(r, e, t) {
      return ye(r).then((n) => WebAssembly.instantiate(n, e)).then(t, (n) => {
        H(`failed to asynchronously prepare wasm: ${n}`), vr(n);
      });
    }
    function be(r, e, t, n) {
      return !r && typeof WebAssembly.instantiateStreaming == "function" && !Ur(e) && typeof fetch == "function" ? fetch(e, {
        credentials: "same-origin"
      }).then((a) => {
        var i = WebAssembly.instantiateStreaming(a, t);
        return i.then(n, function(o) {
          return H(`wasm streaming compile failed: ${o}`), H("falling back to ArrayBuffer instantiation"), xr(e, t, n);
        });
      }) : xr(e, t, n);
    }
    function we() {
      return {
        a: Vt
      };
    }
    function Te() {
      var r, e = we();
      function t(a, i) {
        return y = a.exports, J = y.Y, Fr(), Br = y.$, de(y.Z), pe(), y;
      }
      he();
      function n(a) {
        t(a.instance);
      }
      if (f.instantiateWasm)
        try {
          return f.instantiateWasm(e, t);
        } catch (a) {
          H(`Module.instantiateWasm callback failed with error: ${a}`), K(a);
        }
      return (r = Q) !== null && r !== void 0 || (Q = me()), be(q, Q, e, n).catch(K), {};
    }
    var cr = (r) => {
      r.forEach((e) => e(f));
    };
    f.noExitRuntime;
    var g = (r) => Jr(r), m = () => Qr(), Y = [], $e = (r) => {
      var e = new lr(r);
      return e.get_caught() || e.set_caught(!0), e.set_rethrown(!1), Y.push(e), zr(r), ee(r);
    }, R = 0, Ae = () => {
      p(0, 0);
      var r = Y.pop();
      Yr(r.excPtr), R = 0;
    };
    class lr {
      constructor(e) {
        this.excPtr = e, this.ptr = e - 24;
      }
      set_type(e) {
        _[this.ptr + 4 >> 2] = e;
      }
      get_type() {
        return _[this.ptr + 4 >> 2];
      }
      set_destructor(e) {
        _[this.ptr + 8 >> 2] = e;
      }
      get_destructor() {
        return _[this.ptr + 8 >> 2];
      }
      set_caught(e) {
        e = e ? 1 : 0, U[this.ptr + 12] = e;
      }
      get_caught() {
        return U[this.ptr + 12] != 0;
      }
      set_rethrown(e) {
        e = e ? 1 : 0, U[this.ptr + 13] = e;
      }
      get_rethrown() {
        return U[this.ptr + 13] != 0;
      }
      init(e, t) {
        this.set_adjusted_ptr(0), this.set_type(e), this.set_destructor(t);
      }
      set_adjusted_ptr(e) {
        _[this.ptr + 16 >> 2] = e;
      }
      get_adjusted_ptr() {
        return _[this.ptr + 16 >> 2];
      }
    }
    var Ee = (r) => {
      throw R || (R = r), R;
    }, z = (r) => qr(r), dr = (r) => {
      var e = R;
      if (!e)
        return z(0), 0;
      var t = new lr(e);
      t.set_adjusted_ptr(e);
      var n = t.get_type();
      if (!n)
        return z(0), e;
      for (var a of r) {
        if (a === 0 || a === n)
          break;
        var i = t.ptr + 16;
        if (re(a, n, i))
          return z(a), e;
      }
      return z(n), e;
    }, Ce = () => dr([]), Re = (r) => dr([r]), Fe = (r, e) => dr([r, e]), Pe = () => {
      var r = Y.pop();
      r || vr("no exception to throw");
      var e = r.excPtr;
      throw r.get_rethrown() || (Y.push(r), r.set_rethrown(!0), r.set_caught(!1)), R = e, R;
    }, We = (r, e, t) => {
      var n = new lr(r);
      throw n.init(e, t), R = r, R;
    }, ke = () => {
      vr("");
    }, rr = {}, _r = (r) => {
      for (; r.length; ) {
        var e = r.pop(), t = r.pop();
        t(e);
      }
    };
    function er(r) {
      return this.fromWireType(_[r >> 2]);
    }
    var O = {}, M = {}, tr = {}, Mr, Ir = (r) => {
      throw new Mr(r);
    }, jr = (r, e, t) => {
      r.forEach((s) => tr[s] = e);
      function n(s) {
        var u = t(s);
        u.length !== r.length && Ir("Mismatched type converter count");
        for (var v = 0; v < r.length; ++v)
          E(r[v], u[v]);
      }
      var a = new Array(e.length), i = [], o = 0;
      e.forEach((s, u) => {
        M.hasOwnProperty(s) ? a[u] = M[s] : (i.push(s), O.hasOwnProperty(s) || (O[s] = []), O[s].push(() => {
          a[u] = M[s], ++o, o === i.length && n(a);
        }));
      }), i.length === 0 && n(a);
    }, Ue = (r) => {
      var e = rr[r];
      delete rr[r];
      var t = e.rawConstructor, n = e.rawDestructor, a = e.fields, i = a.map((o) => o.getterReturnType).concat(a.map((o) => o.setterArgumentType));
      jr([r], i, (o) => {
        var s = {};
        return a.forEach((u, v) => {
          var c = u.fieldName, l = o[v], d = u.getter, T = u.getterContext, S = o[v + a.length], L = u.setter, C = u.setterContext;
          s[c] = {
            read: (Z) => l.fromWireType(d(T, Z)),
            write: (Z, yr) => {
              var or = [];
              L(C, Z, S.toWireType(or, yr)), _r(or);
            }
          };
        }), [{
          name: e.name,
          fromWireType: (u) => {
            var v = {};
            for (var c in s)
              v[c] = s[c].read(u);
            return n(u), v;
          },
          toWireType: (u, v) => {
            for (var c in s)
              if (!(c in v))
                throw new TypeError(`Missing field: "${c}"`);
            var l = t();
            for (c in s)
              s[c].write(l, v[c]);
            return u !== null && u.push(n, l), l;
          },
          argPackAdvance: F,
          readValueFromPointer: er,
          destructorFunction: n
        }];
      });
    }, Se = (r, e, t, n, a) => {
    }, xe = () => {
      for (var r = new Array(256), e = 0; e < 256; ++e)
        r[e] = String.fromCharCode(e);
      Dr = r;
    }, Dr, w = (r) => {
      for (var e = "", t = r; b[t]; )
        e += Dr[b[t++]];
      return e;
    }, Or, $ = (r) => {
      throw new Or(r);
    };
    function Me(r, e) {
      let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var n = e.name;
      if (r || $(`type "${n}" must have a positive integer typeid pointer`), M.hasOwnProperty(r)) {
        if (t.ignoreDuplicateRegistrations)
          return;
        $(`Cannot register type '${n}' twice`);
      }
      if (M[r] = e, delete tr[r], O.hasOwnProperty(r)) {
        var a = O[r];
        delete O[r], a.forEach((i) => i());
      }
    }
    function E(r, e) {
      let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      return Me(r, e, t);
    }
    var F = 8, Ie = (r, e, t, n) => {
      e = w(e), E(r, {
        name: e,
        fromWireType: function(a) {
          return !!a;
        },
        toWireType: function(a, i) {
          return i ? t : n;
        },
        argPackAdvance: F,
        readValueFromPointer: function(a) {
          return this.fromWireType(b[a]);
        },
        destructorFunction: null
      });
    }, hr = [], P = [], pr = (r) => {
      r > 9 && --P[r + 1] === 0 && (P[r] = void 0, hr.push(r));
    }, je = () => P.length / 2 - 5 - hr.length, De = () => {
      P.push(0, 1, void 0, 1, null, 1, !0, 1, !1, 1), f.count_emval_handles = je;
    }, I = {
      toValue: (r) => (r || $("Cannot use deleted val. handle = " + r), P[r]),
      toHandle: (r) => {
        switch (r) {
          case void 0:
            return 2;
          case null:
            return 4;
          case !0:
            return 6;
          case !1:
            return 8;
          default: {
            const e = hr.pop() || P.length;
            return P[e] = r, P[e + 1] = 1, e;
          }
        }
      }
    }, Oe = {
      name: "emscripten::val",
      fromWireType: (r) => {
        var e = I.toValue(r);
        return pr(r), e;
      },
      toWireType: (r, e) => I.toHandle(e),
      argPackAdvance: F,
      readValueFromPointer: er,
      destructorFunction: null
    }, Ve = (r) => E(r, Oe), He = (r, e, t) => {
      if (r[e].overloadTable === void 0) {
        var n = r[e];
        r[e] = function() {
          for (var a = arguments.length, i = new Array(a), o = 0; o < a; o++)
            i[o] = arguments[o];
          return r[e].overloadTable.hasOwnProperty(i.length) || $(`Function '${t}' called with an invalid number of arguments (${i.length}) - expects one of (${r[e].overloadTable})!`), r[e].overloadTable[i.length].apply(this, i);
        }, r[e].overloadTable = [], r[e].overloadTable[n.argCount] = n;
      }
    }, Vr = (r, e, t) => {
      f.hasOwnProperty(r) ? ((t === void 0 || f[r].overloadTable !== void 0 && f[r].overloadTable[t] !== void 0) && $(`Cannot register public name '${r}' twice`), He(f, r, r), f.hasOwnProperty(t) && $(`Cannot register multiple overloads of a function with the same number of arguments (${t})!`), f[r].overloadTable[t] = e) : (f[r] = e, t !== void 0 && (f[r].numArguments = t));
    }, Ne = (r, e, t) => {
      switch (e) {
        case 1:
          return t ? function(n) {
            return this.fromWireType(U[n]);
          } : function(n) {
            return this.fromWireType(b[n]);
          };
        case 2:
          return t ? function(n) {
            return this.fromWireType(j[n >> 1]);
          } : function(n) {
            return this.fromWireType(N[n >> 1]);
          };
        case 4:
          return t ? function(n) {
            return this.fromWireType(D[n >> 2]);
          } : function(n) {
            return this.fromWireType(_[n >> 2]);
          };
        default:
          throw new TypeError(`invalid integer width (${e}): ${r}`);
      }
    }, Be = (r, e, t, n) => {
      e = w(e);
      function a() {
      }
      a.values = {}, E(r, {
        name: e,
        constructor: a,
        fromWireType: function(i) {
          return this.constructor.values[i];
        },
        toWireType: (i, o) => o.value,
        argPackAdvance: F,
        readValueFromPointer: Ne(e, t, n),
        destructorFunction: null
      }), Vr(e, a);
    }, nr = (r, e) => Object.defineProperty(e, "name", {
      value: r
    }), Hr = (r) => {
      var e = Kr(r), t = w(e);
      return W(e), t;
    }, Nr = (r, e) => {
      var t = M[r];
      return t === void 0 && $(`${e} has unknown type ${Hr(r)}`), t;
    }, Xe = (r, e, t) => {
      var n = Nr(r, "enum");
      e = w(e);
      var a = n.constructor, i = Object.create(n.constructor.prototype, {
        value: {
          value: t
        },
        constructor: {
          value: nr(`${n.name}_${e}`, function() {
          })
        }
      });
      a.values[t] = i, a[e] = i;
    }, Le = (r, e) => {
      switch (e) {
        case 4:
          return function(t) {
            return this.fromWireType(Cr[t >> 2]);
          };
        case 8:
          return function(t) {
            return this.fromWireType(Rr[t >> 3]);
          };
        default:
          throw new TypeError(`invalid float width (${e}): ${r}`);
      }
    }, Ze = (r, e, t) => {
      e = w(e), E(r, {
        name: e,
        fromWireType: (n) => n,
        toWireType: (n, a) => a,
        argPackAdvance: F,
        readValueFromPointer: Le(e, t),
        destructorFunction: null
      });
    };
    function Ge(r) {
      for (var e = 1; e < r.length; ++e)
        if (r[e] !== null && r[e].destructorFunction === void 0)
          return !0;
      return !1;
    }
    function Ke(r, e, t, n, a, i) {
      var o = e.length;
      o < 2 && $("argTypes array size mismatch! Must at least get return value and 'this' types!");
      var s = e[1] !== null && t !== null, u = Ge(e), v = e[0].name !== "void", c = o - 2, l = new Array(c), d = [], T = [], S = function() {
        T.length = 0;
        var L;
        d.length = s ? 2 : 1, d[0] = a, s && (L = e[1].toWireType(T, this), d[1] = L);
        for (var C = 0; C < c; ++C)
          l[C] = e[C + 2].toWireType(T, C < 0 || arguments.length <= C ? void 0 : arguments[C]), d.push(l[C]);
        var Z = n(...d);
        function yr(or) {
          if (u)
            _r(T);
          else
            for (var V = s ? 1 : 2; V < e.length; V++) {
              var an = V === 1 ? L : l[V - 2];
              e[V].destructorFunction !== null && e[V].destructorFunction(an);
            }
          if (v)
            return e[0].fromWireType(or);
        }
        return yr(Z);
      };
      return nr(r, S);
    }
    var qe = (r, e) => {
      for (var t = [], n = 0; n < r; n++)
        t.push(_[e + n * 4 >> 2]);
      return t;
    }, Je = (r, e, t) => {
      f.hasOwnProperty(r) || Ir("Replacing nonexistent public symbol"), f[r].overloadTable !== void 0 && t !== void 0 ? f[r].overloadTable[t] = e : (f[r] = e, f[r].argCount = t);
    }, Qe = (r, e, t) => {
      r = r.replace(/p/g, "i");
      var n = f["dynCall_" + r];
      return n(e, ...t);
    }, ar = [], Br, h = (r) => {
      var e = ar[r];
      return e || (r >= ar.length && (ar.length = r + 1), ar[r] = e = Br.get(r)), e;
    }, Ye = function(r, e) {
      let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
      if (r.includes("j"))
        return Qe(r, e, t);
      var n = h(e)(...t);
      return n;
    }, ze = (r, e) => function() {
      for (var t = arguments.length, n = new Array(t), a = 0; a < t; a++)
        n[a] = arguments[a];
      return Ye(r, e, n);
    }, X = (r, e) => {
      r = w(r);
      function t() {
        return r.includes("j") ? ze(r, e) : h(e);
      }
      var n = t();
      return typeof n != "function" && $(`unknown function pointer with signature ${r}: ${e}`), n;
    }, rt = (r, e) => {
      var t = nr(e, function(n) {
        this.name = e, this.message = n;
        var a = new Error(n).stack;
        a !== void 0 && (this.stack = this.toString() + `
` + a.replace(/^Error(:[^\n]*)?\n/, ""));
      });
      return t.prototype = Object.create(r.prototype), t.prototype.constructor = t, t.prototype.toString = function() {
        return this.message === void 0 ? this.name : `${this.name}: ${this.message}`;
      }, t;
    }, Xr, et = (r, e) => {
      var t = [], n = {};
      function a(i) {
        if (!n[i] && !M[i]) {
          if (tr[i]) {
            tr[i].forEach(a);
            return;
          }
          t.push(i), n[i] = !0;
        }
      }
      throw e.forEach(a), new Xr(`${r}: ` + t.map(Hr).join([", "]));
    }, tt = (r) => {
      r = r.trim();
      const e = r.indexOf("(");
      return e !== -1 ? r.substr(0, e) : r;
    }, nt = (r, e, t, n, a, i, o, s) => {
      var u = qe(e, t);
      r = w(r), r = tt(r), a = X(n, a), Vr(r, function() {
        et(`Cannot call ${r} due to unbound types`, u);
      }, e - 1), jr([], u, (v) => {
        var c = [v[0], null].concat(v.slice(1));
        return Je(r, Ke(r, c, null, a, i), e - 1), [];
      });
    }, at = (r, e, t) => {
      switch (e) {
        case 1:
          return t ? (n) => U[n] : (n) => b[n];
        case 2:
          return t ? (n) => j[n >> 1] : (n) => N[n >> 1];
        case 4:
          return t ? (n) => D[n >> 2] : (n) => _[n >> 2];
        default:
          throw new TypeError(`invalid integer width (${e}): ${r}`);
      }
    }, it = (r, e, t, n, a) => {
      e = w(e);
      var i = (c) => c;
      if (n === 0) {
        var o = 32 - 8 * t;
        i = (c) => c << o >>> o;
      }
      var s = e.includes("unsigned"), u = (c, l) => {
      }, v;
      s ? v = function(c, l) {
        return u(l, this.name), l >>> 0;
      } : v = function(c, l) {
        return u(l, this.name), l;
      }, E(r, {
        name: e,
        fromWireType: i,
        toWireType: v,
        argPackAdvance: F,
        readValueFromPointer: at(e, t, n !== 0),
        destructorFunction: null
      });
    }, ot = (r, e, t) => {
      var n = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], a = n[e];
      function i(o) {
        var s = _[o >> 2], u = _[o + 4 >> 2];
        return new a(U.buffer, u, s);
      }
      t = w(t), E(r, {
        name: t,
        fromWireType: i,
        argPackAdvance: F,
        readValueFromPointer: i
      }, {
        ignoreDuplicateRegistrations: !0
      });
    }, st = (r, e, t, n) => {
      if (!(n > 0)) return 0;
      for (var a = t, i = t + n - 1, o = 0; o < r.length; ++o) {
        var s = r.charCodeAt(o);
        if (s >= 55296 && s <= 57343) {
          var u = r.charCodeAt(++o);
          s = 65536 + ((s & 1023) << 10) | u & 1023;
        }
        if (s <= 127) {
          if (t >= i) break;
          e[t++] = s;
        } else if (s <= 2047) {
          if (t + 1 >= i) break;
          e[t++] = 192 | s >> 6, e[t++] = 128 | s & 63;
        } else if (s <= 65535) {
          if (t + 2 >= i) break;
          e[t++] = 224 | s >> 12, e[t++] = 128 | s >> 6 & 63, e[t++] = 128 | s & 63;
        } else {
          if (t + 3 >= i) break;
          e[t++] = 240 | s >> 18, e[t++] = 128 | s >> 12 & 63, e[t++] = 128 | s >> 6 & 63, e[t++] = 128 | s & 63;
        }
      }
      return e[t] = 0, t - a;
    }, ut = (r, e, t) => st(r, b, e, t), ft = (r) => {
      for (var e = 0, t = 0; t < r.length; ++t) {
        var n = r.charCodeAt(t);
        n <= 127 ? e++ : n <= 2047 ? e += 2 : n >= 55296 && n <= 57343 ? (e += 4, ++t) : e += 3;
      }
      return e;
    }, Lr = typeof TextDecoder < "u" ? new TextDecoder() : void 0, vt = function(r) {
      let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : NaN;
      for (var n = e + t, a = e; r[a] && !(a >= n); ) ++a;
      if (a - e > 16 && r.buffer && Lr)
        return Lr.decode(r.subarray(e, a));
      for (var i = ""; e < a; ) {
        var o = r[e++];
        if (!(o & 128)) {
          i += String.fromCharCode(o);
          continue;
        }
        var s = r[e++] & 63;
        if ((o & 224) == 192) {
          i += String.fromCharCode((o & 31) << 6 | s);
          continue;
        }
        var u = r[e++] & 63;
        if ((o & 240) == 224 ? o = (o & 15) << 12 | s << 6 | u : o = (o & 7) << 18 | s << 12 | u << 6 | r[e++] & 63, o < 65536)
          i += String.fromCharCode(o);
        else {
          var v = o - 65536;
          i += String.fromCharCode(55296 | v >> 10, 56320 | v & 1023);
        }
      }
      return i;
    }, ct = (r, e) => r ? vt(b, r, e) : "", lt = (r, e) => {
      e = w(e);
      var t = e === "std::string";
      E(r, {
        name: e,
        fromWireType(n) {
          var a = _[n >> 2], i = n + 4, o;
          if (t)
            for (var s = i, u = 0; u <= a; ++u) {
              var v = i + u;
              if (u == a || b[v] == 0) {
                var c = v - s, l = ct(s, c);
                o === void 0 ? o = l : (o += "\0", o += l), s = v + 1;
              }
            }
          else {
            for (var d = new Array(a), u = 0; u < a; ++u)
              d[u] = String.fromCharCode(b[i + u]);
            o = d.join("");
          }
          return W(n), o;
        },
        toWireType(n, a) {
          a instanceof ArrayBuffer && (a = new Uint8Array(a));
          var i, o = typeof a == "string";
          o || a instanceof Uint8Array || a instanceof Uint8ClampedArray || a instanceof Int8Array || $("Cannot pass non-string to std::string"), t && o ? i = ft(a) : i = a.length;
          var s = mr(4 + i + 1), u = s + 4;
          if (_[s >> 2] = i, t && o)
            ut(a, u, i + 1);
          else if (o)
            for (var v = 0; v < i; ++v) {
              var c = a.charCodeAt(v);
              c > 255 && (W(u), $("String has UTF-16 code units that do not fit in 8 bits")), b[u + v] = c;
            }
          else
            for (var v = 0; v < i; ++v)
              b[u + v] = a[v];
          return n !== null && n.push(W, s), s;
        },
        argPackAdvance: F,
        readValueFromPointer: er,
        destructorFunction(n) {
          W(n);
        }
      });
    }, Zr = typeof TextDecoder < "u" ? new TextDecoder("utf-16le") : void 0, dt = (r, e) => {
      for (var t = r, n = t >> 1, a = n + e / 2; !(n >= a) && N[n]; ) ++n;
      if (t = n << 1, t - r > 32 && Zr) return Zr.decode(b.subarray(r, t));
      for (var i = "", o = 0; !(o >= e / 2); ++o) {
        var s = j[r + o * 2 >> 1];
        if (s == 0) break;
        i += String.fromCharCode(s);
      }
      return i;
    }, _t = (r, e, t) => {
      var n;
      if ((n = t) !== null && n !== void 0 || (t = 2147483647), t < 2) return 0;
      t -= 2;
      for (var a = e, i = t < r.length * 2 ? t / 2 : r.length, o = 0; o < i; ++o) {
        var s = r.charCodeAt(o);
        j[e >> 1] = s, e += 2;
      }
      return j[e >> 1] = 0, e - a;
    }, ht = (r) => r.length * 2, pt = (r, e) => {
      for (var t = 0, n = ""; !(t >= e / 4); ) {
        var a = D[r + t * 4 >> 2];
        if (a == 0) break;
        if (++t, a >= 65536) {
          var i = a - 65536;
          n += String.fromCharCode(55296 | i >> 10, 56320 | i & 1023);
        } else
          n += String.fromCharCode(a);
      }
      return n;
    }, gt = (r, e, t) => {
      var n;
      if ((n = t) !== null && n !== void 0 || (t = 2147483647), t < 4) return 0;
      for (var a = e, i = a + t - 4, o = 0; o < r.length; ++o) {
        var s = r.charCodeAt(o);
        if (s >= 55296 && s <= 57343) {
          var u = r.charCodeAt(++o);
          s = 65536 + ((s & 1023) << 10) | u & 1023;
        }
        if (D[e >> 2] = s, e += 4, e + 4 > i) break;
      }
      return D[e >> 2] = 0, e - a;
    }, mt = (r) => {
      for (var e = 0, t = 0; t < r.length; ++t) {
        var n = r.charCodeAt(t);
        n >= 55296 && n <= 57343 && ++t, e += 4;
      }
      return e;
    }, yt = (r, e, t) => {
      t = w(t);
      var n, a, i, o;
      e === 2 ? (n = dt, a = _t, o = ht, i = (s) => N[s >> 1]) : e === 4 && (n = pt, a = gt, o = mt, i = (s) => _[s >> 2]), E(r, {
        name: t,
        fromWireType: (s) => {
          for (var u = _[s >> 2], v, c = s + 4, l = 0; l <= u; ++l) {
            var d = s + 4 + l * e;
            if (l == u || i(d) == 0) {
              var T = d - c, S = n(c, T);
              v === void 0 ? v = S : (v += "\0", v += S), c = d + e;
            }
          }
          return W(s), v;
        },
        toWireType: (s, u) => {
          typeof u != "string" && $(`Cannot pass non-string to C++ string type ${t}`);
          var v = o(u), c = mr(4 + v + e);
          return _[c >> 2] = v / e, a(u, c + 4, v + e), s !== null && s.push(W, c), c;
        },
        argPackAdvance: F,
        readValueFromPointer: er,
        destructorFunction(s) {
          W(s);
        }
      });
    }, bt = (r, e, t, n, a, i) => {
      rr[r] = {
        name: w(e),
        rawConstructor: X(t, n),
        rawDestructor: X(a, i),
        fields: []
      };
    }, wt = (r, e, t, n, a, i, o, s, u, v) => {
      rr[r].fields.push({
        fieldName: w(e),
        getterReturnType: t,
        getter: X(n, a),
        getterContext: i,
        setterArgumentType: o,
        setter: X(s, u),
        setterContext: v
      });
    }, Tt = (r, e) => {
      e = w(e), E(r, {
        isVoid: !0,
        name: e,
        argPackAdvance: 0,
        fromWireType: () => {
        },
        toWireType: (t, n) => {
        }
      });
    }, $t = (r, e, t) => b.copyWithin(r, e, e + t), gr = [], At = (r, e, t, n) => (r = gr[r], e = I.toValue(e), r(null, e, t, n)), Et = {}, Ct = (r) => {
      var e = Et[r];
      return e === void 0 ? w(r) : e;
    }, Gr = () => {
      if (typeof globalThis == "object")
        return globalThis;
      function r(e) {
        e.$$$embind_global$$$ = e;
        var t = typeof $$$embind_global$$$ == "object" && e.$$$embind_global$$$ == e;
        return t || delete e.$$$embind_global$$$, t;
      }
      if (typeof $$$embind_global$$$ == "object" || (typeof global == "object" && r(global) ? $$$embind_global$$$ = global : typeof self == "object" && r(self) && ($$$embind_global$$$ = self), typeof $$$embind_global$$$ == "object"))
        return $$$embind_global$$$;
      throw Error("unable to get global object.");
    }, Rt = (r) => r === 0 ? I.toHandle(Gr()) : (r = Ct(r), I.toHandle(Gr()[r])), Ft = (r) => {
      var e = gr.length;
      return gr.push(r), e;
    }, Pt = (r, e) => {
      for (var t = new Array(r), n = 0; n < r; ++n)
        t[n] = Nr(_[e + n * 4 >> 2], "parameter " + n);
      return t;
    }, Wt = Reflect.construct, kt = (r, e, t) => {
      var n = [], a = r.toWireType(n, t);
      return n.length && (_[e >> 2] = I.toHandle(n)), a;
    }, Ut = (r, e, t) => {
      var n = Pt(r, e), a = n.shift();
      r--;
      var i = new Array(r), o = (u, v, c, l) => {
        for (var d = 0, T = 0; T < r; ++T)
          i[T] = n[T].readValueFromPointer(l + d), d += n[T].argPackAdvance;
        var S = t === 1 ? Wt(v, i) : v.apply(u, i);
        return kt(a, c, S);
      }, s = `methodCaller<(${n.map((u) => u.name).join(", ")}) => ${a.name}>`;
      return Ft(nr(s, o));
    }, St = (r) => {
      r > 9 && (P[r + 1] += 1);
    }, xt = (r) => {
      var e = I.toValue(r);
      _r(e), pr(r);
    }, Mt = () => 2147483648, It = (r, e) => Math.ceil(r / e) * e, jt = (r) => {
      var e = J.buffer, t = (r - e.byteLength + 65535) / 65536 | 0;
      try {
        return J.grow(t), Fr(), 1;
      } catch {
      }
    }, Dt = (r) => {
      var e = b.length;
      r >>>= 0;
      var t = Mt();
      if (r > t)
        return !1;
      for (var n = 1; n <= 4; n *= 2) {
        var a = e * (1 + 0.2 / n);
        a = Math.min(a, r + 100663296);
        var i = Math.min(t, It(Math.max(r, a), 65536)), o = jt(i);
        if (o)
          return !0;
      }
      return !1;
    }, Ot = (r) => r;
    Mr = f.InternalError = class extends Error {
      constructor(e) {
        super(e), this.name = "InternalError";
      }
    }, xe(), Or = f.BindingError = class extends Error {
      constructor(e) {
        super(e), this.name = "BindingError";
      }
    }, De(), Xr = f.UnboundTypeError = rt(Error, "UnboundTypeError");
    var Vt = {
      x: $e,
      y: Ae,
      a: Ce,
      l: Re,
      u: Fe,
      N: Pe,
      n: We,
      f: Ee,
      J: ke,
      T: Ue,
      I: Se,
      P: Ie,
      O: Ve,
      R: Be,
      k: Xe,
      B: Ze,
      S: nt,
      s: it,
      o: ot,
      A: lt,
      z: yt,
      C: bt,
      U: wt,
      Q: Tt,
      L: $t,
      F: At,
      W: pr,
      H: Rt,
      G: Ut,
      D: St,
      X: xt,
      K: Dt,
      E: Zt,
      v: tn,
      e: Ht,
      c: Gt,
      m: Lt,
      h: en,
      i: Yt,
      M: zt,
      q: Kt,
      g: Nt,
      d: Qt,
      b: Jt,
      j: Xt,
      p: Bt,
      w: rn,
      r: nn,
      t: qt,
      V: Ot
    }, y = Te(), Kr = (r) => (Kr = y._)(r), mr = f._malloc = (r) => (mr = f._malloc = y.aa)(r), W = f._free = (r) => (W = f._free = y.ba)(r), p = (r, e) => (p = y.ca)(r, e), qr = (r) => (qr = y.da)(r), Jr = (r) => (Jr = y.ea)(r), Qr = () => (Qr = y.fa)(), Yr = (r) => (Yr = y.ga)(r), zr = (r) => (zr = y.ha)(r), re = (r, e, t) => (re = y.ia)(r, e, t), ee = (r) => (ee = y.ja)(r);
    function Ht(r, e) {
      var t = m();
      try {
        return h(r)(e);
      } catch (n) {
        if (g(t), n !== n + 0) throw n;
        p(1, 0);
      }
    }
    function Nt(r, e) {
      var t = m();
      try {
        h(r)(e);
      } catch (n) {
        if (g(t), n !== n + 0) throw n;
        p(1, 0);
      }
    }
    function Bt(r, e, t, n, a, i) {
      var o = m();
      try {
        h(r)(e, t, n, a, i);
      } catch (s) {
        if (g(o), s !== s + 0) throw s;
        p(1, 0);
      }
    }
    function Xt(r, e, t, n, a) {
      var i = m();
      try {
        h(r)(e, t, n, a);
      } catch (o) {
        if (g(i), o !== o + 0) throw o;
        p(1, 0);
      }
    }
    function Lt(r, e, t, n) {
      var a = m();
      try {
        return h(r)(e, t, n);
      } catch (i) {
        if (g(a), i !== i + 0) throw i;
        p(1, 0);
      }
    }
    function Zt(r, e, t, n, a) {
      var i = m();
      try {
        return h(r)(e, t, n, a);
      } catch (o) {
        if (g(i), o !== o + 0) throw o;
        p(1, 0);
      }
    }
    function Gt(r, e, t) {
      var n = m();
      try {
        return h(r)(e, t);
      } catch (a) {
        if (g(n), a !== a + 0) throw a;
        p(1, 0);
      }
    }
    function Kt(r) {
      var e = m();
      try {
        h(r)();
      } catch (t) {
        if (g(e), t !== t + 0) throw t;
        p(1, 0);
      }
    }
    function qt(r, e, t, n, a, i, o, s, u, v, c) {
      var l = m();
      try {
        h(r)(e, t, n, a, i, o, s, u, v, c);
      } catch (d) {
        if (g(l), d !== d + 0) throw d;
        p(1, 0);
      }
    }
    function Jt(r, e, t, n) {
      var a = m();
      try {
        h(r)(e, t, n);
      } catch (i) {
        if (g(a), i !== i + 0) throw i;
        p(1, 0);
      }
    }
    function Qt(r, e, t) {
      var n = m();
      try {
        h(r)(e, t);
      } catch (a) {
        if (g(n), a !== a + 0) throw a;
        p(1, 0);
      }
    }
    function Yt(r, e, t, n, a, i) {
      var o = m();
      try {
        return h(r)(e, t, n, a, i);
      } catch (s) {
        if (g(o), s !== s + 0) throw s;
        p(1, 0);
      }
    }
    function zt(r, e, t, n, a, i, o) {
      var s = m();
      try {
        return h(r)(e, t, n, a, i, o);
      } catch (u) {
        if (g(s), u !== u + 0) throw u;
        p(1, 0);
      }
    }
    function rn(r, e, t, n, a, i, o, s) {
      var u = m();
      try {
        h(r)(e, t, n, a, i, o, s);
      } catch (v) {
        if (g(u), v !== v + 0) throw v;
        p(1, 0);
      }
    }
    function en(r, e, t, n, a) {
      var i = m();
      try {
        return h(r)(e, t, n, a);
      } catch (o) {
        if (g(i), o !== o + 0) throw o;
        p(1, 0);
      }
    }
    function tn(r) {
      var e = m();
      try {
        return h(r)();
      } catch (t) {
        if (g(e), t !== t + 0) throw t;
        p(1, 0);
      }
    }
    function nn(r, e, t, n, a, i, o, s, u) {
      var v = m();
      try {
        h(r)(e, t, n, a, i, o, s, u);
      } catch (c) {
        if (g(v), c !== c + 0) throw c;
        p(1, 0);
      }
    }
    var ir, te;
    B = function r() {
      ir || ne(), ir || (B = r);
    };
    function ne() {
      if (x > 0 || !te && (te = 1, fe(), x > 0))
        return;
      function r() {
        var e;
        ir || (ir = 1, f.calledRun = 1, !Er && (ve(), Tr(f), (e = f.onRuntimeInitialized) === null || e === void 0 || e.call(f), ce()));
      }
      f.setStatus ? (f.setStatus("Running..."), setTimeout(() => {
        setTimeout(() => f.setStatus(""), 1), r();
      }, 1)) : r();
    }
    if (f.preInit)
      for (typeof f.preInit == "function" && (f.preInit = [f.preInit]); f.preInit.length > 0; )
        f.preInit.pop()();
    return ne(), wr = ie, wr;
  };
})();
function ln(k) {
  return on(
    br,
    k
  );
}
function dn(k) {
  return sn(
    br,
    k
  );
}
async function _n(k, G) {
  return un(
    br,
    k,
    G
  );
}
export {
  gn as barcodeFormats,
  mn as characterSets,
  yn as defaultEncodeHints,
  bn as defaultWriterOptions,
  ln as getZXingModule,
  wn as purgeZXingModule,
  dn as setZXingModuleOverrides,
  _n as writeBarcodeToImageFile,
  Tn as writeInputEccLevels
};
