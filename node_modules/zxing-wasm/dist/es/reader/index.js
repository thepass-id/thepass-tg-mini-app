import { g as ki, s as Si, r as ji, a as Wi } from "../core-C2hxqLt7.js";
import { b as Ni, c as zi, e as Li, f as Zi, d as Gi, d as Xi, h as qi, p as Ki, i as Qi, t as Yi } from "../core-C2hxqLt7.js";
var Cr = (() => {
  var L;
  var S = typeof document < "u" && ((L = document.currentScript) == null ? void 0 : L.tagName.toUpperCase()) === "SCRIPT" ? document.currentScript.src : void 0;
  return function(He = {}) {
    var Lr, f = He, Zr, ir, Ve = new Promise((r, e) => {
      Zr = r, ir = e;
    }), Be = typeof window == "object", Ne = typeof Bun < "u", Tr = typeof importScripts == "function";
    typeof process == "object" && typeof process.versions == "object" && typeof process.versions.node == "string" && process.type != "renderer";
    var Gr = Object.assign({}, f), Xr = "./this.program", j = "";
    function ze(r) {
      return f.locateFile ? f.locateFile(r, j) : j + r;
    }
    var qr, Pr;
    if (Be || Tr || Ne) {
      var Ar;
      Tr ? j = self.location.href : typeof document < "u" && ((Ar = document.currentScript) === null || Ar === void 0 ? void 0 : Ar.tagName.toUpperCase()) === "SCRIPT" && (j = document.currentScript.src), S && (j = S), j.startsWith("blob:") ? j = "" : j = j.substr(0, j.replace(/[?#].*/, "").lastIndexOf("/") + 1), Tr && (Pr = (r) => {
        var e = new XMLHttpRequest();
        return e.open("GET", r, !1), e.responseType = "arraybuffer", e.send(null), new Uint8Array(e.response);
      }), qr = (r) => fetch(r, {
        credentials: "same-origin"
      }).then((e) => e.ok ? e.arrayBuffer() : Promise.reject(new Error(e.status + " : " + e.url)));
    }
    var Le = f.print || console.log.bind(console), Z = f.printErr || console.error.bind(console);
    Object.assign(f, Gr), Gr = null, f.arguments && f.arguments, f.thisProgram && (Xr = f.thisProgram);
    var ar = f.wasmBinary, or, Kr = !1, W, E, G, K, H, $, Qr, Yr;
    function Jr() {
      var r = or.buffer;
      f.HEAP8 = W = new Int8Array(r), f.HEAP16 = G = new Int16Array(r), f.HEAPU8 = E = new Uint8Array(r), f.HEAPU16 = K = new Uint16Array(r), f.HEAP32 = H = new Int32Array(r), f.HEAPU32 = $ = new Uint32Array(r), f.HEAPF32 = Qr = new Float32Array(r), f.HEAPF64 = Yr = new Float64Array(r);
    }
    var re = [], ee = [], te = [];
    function Ze() {
      var r = f.preRun;
      r && (typeof r == "function" && (r = [r]), r.forEach(qe)), Fr(re);
    }
    function Ge() {
      Fr(ee);
    }
    function Xe() {
      var r = f.postRun;
      r && (typeof r == "function" && (r = [r]), r.forEach(Qe)), Fr(te);
    }
    function qe(r) {
      re.unshift(r);
    }
    function Ke(r) {
      ee.unshift(r);
    }
    function Qe(r) {
      te.unshift(r);
    }
    var V = 0, Q = null;
    function Ye(r) {
      var e;
      V++, (e = f.monitorRunDependencies) === null || e === void 0 || e.call(f, V);
    }
    function Je(r) {
      var e;
      if (V--, (e = f.monitorRunDependencies) === null || e === void 0 || e.call(f, V), V == 0 && Q) {
        var t = Q;
        Q = null, t();
      }
    }
    function Er(r) {
      var e;
      (e = f.onAbort) === null || e === void 0 || e.call(f, r), r = "Aborted(" + r + ")", Z(r), Kr = !0, r += ". Build with -sASSERTIONS for more info.";
      var t = new WebAssembly.RuntimeError(r);
      throw ir(t), t;
    }
    var rt = "data:application/octet-stream;base64,", ne = (r) => r.startsWith(rt);
    function et() {
      var r = "zxing_reader.wasm";
      return ne(r) ? r : ze(r);
    }
    var sr;
    function ie(r) {
      if (r == sr && ar)
        return new Uint8Array(ar);
      if (Pr)
        return Pr(r);
      throw "both async and sync fetching of the wasm failed";
    }
    function tt(r) {
      return ar ? Promise.resolve().then(() => ie(r)) : qr(r).then((e) => new Uint8Array(e), () => ie(r));
    }
    function ae(r, e, t) {
      return tt(r).then((n) => WebAssembly.instantiate(n, e)).then(t, (n) => {
        Z(`failed to asynchronously prepare wasm: ${n}`), Er(n);
      });
    }
    function nt(r, e, t, n) {
      return !r && typeof WebAssembly.instantiateStreaming == "function" && !ne(e) && typeof fetch == "function" ? fetch(e, {
        credentials: "same-origin"
      }).then((i) => {
        var a = WebAssembly.instantiateStreaming(i, t);
        return a.then(n, function(s) {
          return Z(`wasm streaming compile failed: ${s}`), Z("falling back to ArrayBuffer instantiation"), ae(e, t, n);
        });
      }) : ae(e, t, n);
    }
    function it() {
      return {
        a: Xn
      };
    }
    function at() {
      var r, e = it();
      function t(i, a) {
        return w = i.exports, or = w.za, Jr(), he = w.Da, Ke(w.Aa), Je(), w;
      }
      Ye();
      function n(i) {
        t(i.instance);
      }
      if (f.instantiateWasm)
        try {
          return f.instantiateWasm(e, t);
        } catch (i) {
          Z(`Module.instantiateWasm callback failed with error: ${i}`), ir(i);
        }
      return (r = sr) !== null && r !== void 0 || (sr = et()), nt(ar, sr, e, n).catch(ir), {};
    }
    var Fr = (r) => {
      r.forEach((e) => e(f));
    };
    f.noExitRuntime;
    var h = (r) => Ee(r), _ = () => Fe(), ur = [], lr = 0, ot = (r) => {
      var e = new Rr(r);
      return e.get_caught() || (e.set_caught(!0), lr--), e.set_rethrown(!1), ur.push(e), ke(r), Pe(r);
    }, D = 0, st = () => {
      d(0, 0);
      var r = ur.pop();
      Re(r.excPtr), D = 0;
    };
    class Rr {
      constructor(e) {
        this.excPtr = e, this.ptr = e - 24;
      }
      set_type(e) {
        $[this.ptr + 4 >> 2] = e;
      }
      get_type() {
        return $[this.ptr + 4 >> 2];
      }
      set_destructor(e) {
        $[this.ptr + 8 >> 2] = e;
      }
      get_destructor() {
        return $[this.ptr + 8 >> 2];
      }
      set_caught(e) {
        e = e ? 1 : 0, W[this.ptr + 12] = e;
      }
      get_caught() {
        return W[this.ptr + 12] != 0;
      }
      set_rethrown(e) {
        e = e ? 1 : 0, W[this.ptr + 13] = e;
      }
      get_rethrown() {
        return W[this.ptr + 13] != 0;
      }
      init(e, t) {
        this.set_adjusted_ptr(0), this.set_type(e), this.set_destructor(t);
      }
      set_adjusted_ptr(e) {
        $[this.ptr + 16 >> 2] = e;
      }
      get_adjusted_ptr() {
        return $[this.ptr + 16 >> 2];
      }
    }
    var ut = (r) => {
      throw D || (D = r), D;
    }, fr = (r) => Ae(r), kr = (r) => {
      var e = D;
      if (!e)
        return fr(0), 0;
      var t = new Rr(e);
      t.set_adjusted_ptr(e);
      var n = t.get_type();
      if (!n)
        return fr(0), e;
      for (var i of r) {
        if (i === 0 || i === n)
          break;
        var a = t.ptr + 16;
        if (Se(i, n, a))
          return fr(i), e;
      }
      return fr(n), e;
    }, lt = () => kr([]), ft = (r) => kr([r]), ct = (r, e) => kr([r, e]), vt = () => {
      var r = ur.pop();
      r || Er("no exception to throw");
      var e = r.excPtr;
      throw r.get_rethrown() || (ur.push(r), r.set_rethrown(!0), r.set_caught(!1), lr++), D = e, D;
    }, dt = (r, e, t) => {
      var n = new Rr(r);
      throw n.init(e, t), D = r, lr++, D;
    }, pt = () => lr, ht = () => {
      Er("");
    }, cr = {}, Sr = (r) => {
      for (; r.length; ) {
        var e = r.pop(), t = r.pop();
        t(e);
      }
    };
    function Y(r) {
      return this.fromWireType($[r >> 2]);
    }
    var X = {}, B = {}, vr = {}, oe, dr = (r) => {
      throw new oe(r);
    }, N = (r, e, t) => {
      r.forEach((o) => vr[o] = e);
      function n(o) {
        var u = t(o);
        u.length !== r.length && dr("Mismatched type converter count");
        for (var l = 0; l < r.length; ++l)
          R(r[l], u[l]);
      }
      var i = new Array(e.length), a = [], s = 0;
      e.forEach((o, u) => {
        B.hasOwnProperty(o) ? i[u] = B[o] : (a.push(o), X.hasOwnProperty(o) || (X[o] = []), X[o].push(() => {
          i[u] = B[o], ++s, s === a.length && n(i);
        }));
      }), a.length === 0 && n(i);
    }, _t = (r) => {
      var e = cr[r];
      delete cr[r];
      var t = e.rawConstructor, n = e.rawDestructor, i = e.fields, a = i.map((s) => s.getterReturnType).concat(i.map((s) => s.setterArgumentType));
      N([r], a, (s) => {
        var o = {};
        return i.forEach((u, l) => {
          var c = u.fieldName, v = s[l], p = u.getter, m = u.getterContext, b = s[l + i.length], P = u.setter, C = u.setterContext;
          o[c] = {
            read: (T) => v.fromWireType(p(m, T)),
            write: (T, z) => {
              var F = [];
              P(C, T, b.toWireType(F, z)), Sr(F);
            }
          };
        }), [{
          name: e.name,
          fromWireType: (u) => {
            var l = {};
            for (var c in o)
              l[c] = o[c].read(u);
            return n(u), l;
          },
          toWireType: (u, l) => {
            for (var c in o)
              if (!(c in l))
                throw new TypeError(`Missing field: "${c}"`);
            var v = t();
            for (c in o)
              o[c].write(v, l[c]);
            return u !== null && u.push(n, v), v;
          },
          argPackAdvance: O,
          readValueFromPointer: Y,
          destructorFunction: n
        }];
      });
    }, gt = (r, e, t, n, i) => {
    }, yt = () => {
      for (var r = new Array(256), e = 0; e < 256; ++e)
        r[e] = String.fromCharCode(e);
      se = r;
    }, se, A = (r) => {
      for (var e = "", t = r; E[t]; )
        e += se[E[t++]];
      return e;
    }, q, y = (r) => {
      throw new q(r);
    };
    function mt(r, e) {
      let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var n = e.name;
      if (r || y(`type "${n}" must have a positive integer typeid pointer`), B.hasOwnProperty(r)) {
        if (t.ignoreDuplicateRegistrations)
          return;
        y(`Cannot register type '${n}' twice`);
      }
      if (B[r] = e, delete vr[r], X.hasOwnProperty(r)) {
        var i = X[r];
        delete X[r], i.forEach((a) => a());
      }
    }
    function R(r, e) {
      let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      return mt(r, e, t);
    }
    var O = 8, $t = (r, e, t, n) => {
      e = A(e), R(r, {
        name: e,
        fromWireType: function(i) {
          return !!i;
        },
        toWireType: function(i, a) {
          return a ? t : n;
        },
        argPackAdvance: O,
        readValueFromPointer: function(i) {
          return this.fromWireType(E[i]);
        },
        destructorFunction: null
      });
    }, bt = (r) => ({
      count: r.count,
      deleteScheduled: r.deleteScheduled,
      preservePointerOnDelete: r.preservePointerOnDelete,
      ptr: r.ptr,
      ptrType: r.ptrType,
      smartPtr: r.smartPtr,
      smartPtrType: r.smartPtrType
    }), jr = (r) => {
      function e(t) {
        return t.$$.ptrType.registeredClass.name;
      }
      y(e(r) + " instance already deleted");
    }, Wr = !1, ue = (r) => {
    }, wt = (r) => {
      r.smartPtr ? r.smartPtrType.rawDestructor(r.smartPtr) : r.ptrType.registeredClass.rawDestructor(r.ptr);
    }, le = (r) => {
      r.count.value -= 1;
      var e = r.count.value === 0;
      e && wt(r);
    }, fe = (r, e, t) => {
      if (e === t)
        return r;
      if (t.baseClass === void 0)
        return null;
      var n = fe(r, e, t.baseClass);
      return n === null ? null : t.downcast(n);
    }, ce = {}, Ct = {}, Tt = (r, e) => {
      for (e === void 0 && y("ptr should not be undefined"); r.baseClass; )
        e = r.upcast(e), r = r.baseClass;
      return e;
    }, Pt = (r, e) => (e = Tt(r, e), Ct[e]), pr = (r, e) => {
      (!e.ptrType || !e.ptr) && dr("makeClassHandle requires ptr and ptrType");
      var t = !!e.smartPtrType, n = !!e.smartPtr;
      return t !== n && dr("Both smartPtrType and smartPtr must be specified"), e.count = {
        value: 1
      }, J(Object.create(r, {
        $$: {
          value: e,
          writable: !0
        }
      }));
    };
    function At(r) {
      var e = this.getPointee(r);
      if (!e)
        return this.destructor(r), null;
      var t = Pt(this.registeredClass, e);
      if (t !== void 0) {
        if (t.$$.count.value === 0)
          return t.$$.ptr = e, t.$$.smartPtr = r, t.clone();
        var n = t.clone();
        return this.destructor(r), n;
      }
      function i() {
        return this.isSmartPointer ? pr(this.registeredClass.instancePrototype, {
          ptrType: this.pointeeType,
          ptr: e,
          smartPtrType: this,
          smartPtr: r
        }) : pr(this.registeredClass.instancePrototype, {
          ptrType: this,
          ptr: r
        });
      }
      var a = this.registeredClass.getActualType(e), s = ce[a];
      if (!s)
        return i.call(this);
      var o;
      this.isConst ? o = s.constPointerType : o = s.pointerType;
      var u = fe(e, this.registeredClass, o.registeredClass);
      return u === null ? i.call(this) : this.isSmartPointer ? pr(o.registeredClass.instancePrototype, {
        ptrType: o,
        ptr: u,
        smartPtrType: this,
        smartPtr: r
      }) : pr(o.registeredClass.instancePrototype, {
        ptrType: o,
        ptr: u
      });
    }
    var J = (r) => typeof FinalizationRegistry > "u" ? (J = (e) => e, r) : (Wr = new FinalizationRegistry((e) => {
      le(e.$$);
    }), J = (e) => {
      var t = e.$$, n = !!t.smartPtr;
      if (n) {
        var i = {
          $$: t
        };
        Wr.register(e, i, e);
      }
      return e;
    }, ue = (e) => Wr.unregister(e), J(r)), hr = [], Et = () => {
      for (; hr.length; ) {
        var r = hr.pop();
        r.$$.deleteScheduled = !1, r.delete();
      }
    }, ve, Ft = () => {
      Object.assign(_r.prototype, {
        isAliasOf(r) {
          if (!(this instanceof _r) || !(r instanceof _r))
            return !1;
          var e = this.$$.ptrType.registeredClass, t = this.$$.ptr;
          r.$$ = r.$$;
          for (var n = r.$$.ptrType.registeredClass, i = r.$$.ptr; e.baseClass; )
            t = e.upcast(t), e = e.baseClass;
          for (; n.baseClass; )
            i = n.upcast(i), n = n.baseClass;
          return e === n && t === i;
        },
        clone() {
          if (this.$$.ptr || jr(this), this.$$.preservePointerOnDelete)
            return this.$$.count.value += 1, this;
          var r = J(Object.create(Object.getPrototypeOf(this), {
            $$: {
              value: bt(this.$$)
            }
          }));
          return r.$$.count.value += 1, r.$$.deleteScheduled = !1, r;
        },
        delete() {
          this.$$.ptr || jr(this), this.$$.deleteScheduled && !this.$$.preservePointerOnDelete && y("Object already scheduled for deletion"), ue(this), le(this.$$), this.$$.preservePointerOnDelete || (this.$$.smartPtr = void 0, this.$$.ptr = void 0);
        },
        isDeleted() {
          return !this.$$.ptr;
        },
        deleteLater() {
          return this.$$.ptr || jr(this), this.$$.deleteScheduled && !this.$$.preservePointerOnDelete && y("Object already scheduled for deletion"), hr.push(this), hr.length === 1 && ve && ve(Et), this.$$.deleteScheduled = !0, this;
        }
      });
    };
    function _r() {
    }
    var rr = (r, e) => Object.defineProperty(e, "name", {
      value: r
    }), de = (r, e, t) => {
      if (r[e].overloadTable === void 0) {
        var n = r[e];
        r[e] = function() {
          for (var i = arguments.length, a = new Array(i), s = 0; s < i; s++)
            a[s] = arguments[s];
          return r[e].overloadTable.hasOwnProperty(a.length) || y(`Function '${t}' called with an invalid number of arguments (${a.length}) - expects one of (${r[e].overloadTable})!`), r[e].overloadTable[a.length].apply(this, a);
        }, r[e].overloadTable = [], r[e].overloadTable[n.argCount] = n;
      }
    }, Or = (r, e, t) => {
      f.hasOwnProperty(r) ? ((t === void 0 || f[r].overloadTable !== void 0 && f[r].overloadTable[t] !== void 0) && y(`Cannot register public name '${r}' twice`), de(f, r, r), f.hasOwnProperty(t) && y(`Cannot register multiple overloads of a function with the same number of arguments (${t})!`), f[r].overloadTable[t] = e) : (f[r] = e, t !== void 0 && (f[r].numArguments = t));
    }, Rt = 48, kt = 57, St = (r) => {
      r = r.replace(/[^a-zA-Z0-9_]/g, "$");
      var e = r.charCodeAt(0);
      return e >= Rt && e <= kt ? `_${r}` : r;
    };
    function jt(r, e, t, n, i, a, s, o) {
      this.name = r, this.constructor = e, this.instancePrototype = t, this.rawDestructor = n, this.baseClass = i, this.getActualType = a, this.upcast = s, this.downcast = o, this.pureVirtualFunctions = [];
    }
    var Dr = (r, e, t) => {
      for (; e !== t; )
        e.upcast || y(`Expected null or instance of ${t.name}, got an instance of ${e.name}`), r = e.upcast(r), e = e.baseClass;
      return r;
    };
    function Wt(r, e) {
      if (e === null)
        return this.isReference && y(`null is not a valid ${this.name}`), 0;
      e.$$ || y(`Cannot pass "${Vr(e)}" as a ${this.name}`), e.$$.ptr || y(`Cannot pass deleted object as a pointer of type ${this.name}`);
      var t = e.$$.ptrType.registeredClass, n = Dr(e.$$.ptr, t, this.registeredClass);
      return n;
    }
    function Ot(r, e) {
      var t;
      if (e === null)
        return this.isReference && y(`null is not a valid ${this.name}`), this.isSmartPointer ? (t = this.rawConstructor(), r !== null && r.push(this.rawDestructor, t), t) : 0;
      (!e || !e.$$) && y(`Cannot pass "${Vr(e)}" as a ${this.name}`), e.$$.ptr || y(`Cannot pass deleted object as a pointer of type ${this.name}`), !this.isConst && e.$$.ptrType.isConst && y(`Cannot convert argument of type ${e.$$.smartPtrType ? e.$$.smartPtrType.name : e.$$.ptrType.name} to parameter type ${this.name}`);
      var n = e.$$.ptrType.registeredClass;
      if (t = Dr(e.$$.ptr, n, this.registeredClass), this.isSmartPointer)
        switch (e.$$.smartPtr === void 0 && y("Passing raw pointer to smart pointer is illegal"), this.sharingPolicy) {
          case 0:
            e.$$.smartPtrType === this ? t = e.$$.smartPtr : y(`Cannot convert argument of type ${e.$$.smartPtrType ? e.$$.smartPtrType.name : e.$$.ptrType.name} to parameter type ${this.name}`);
            break;
          case 1:
            t = e.$$.smartPtr;
            break;
          case 2:
            if (e.$$.smartPtrType === this)
              t = e.$$.smartPtr;
            else {
              var i = e.clone();
              t = this.rawShare(t, x.toHandle(() => i.delete())), r !== null && r.push(this.rawDestructor, t);
            }
            break;
          default:
            y("Unsupporting sharing policy");
        }
      return t;
    }
    function Dt(r, e) {
      if (e === null)
        return this.isReference && y(`null is not a valid ${this.name}`), 0;
      e.$$ || y(`Cannot pass "${Vr(e)}" as a ${this.name}`), e.$$.ptr || y(`Cannot pass deleted object as a pointer of type ${this.name}`), e.$$.ptrType.isConst && y(`Cannot convert argument of type ${e.$$.ptrType.name} to parameter type ${this.name}`);
      var t = e.$$.ptrType.registeredClass, n = Dr(e.$$.ptr, t, this.registeredClass);
      return n;
    }
    var Ut = () => {
      Object.assign(gr.prototype, {
        getPointee(r) {
          return this.rawGetPointee && (r = this.rawGetPointee(r)), r;
        },
        destructor(r) {
          var e;
          (e = this.rawDestructor) === null || e === void 0 || e.call(this, r);
        },
        argPackAdvance: O,
        readValueFromPointer: Y,
        fromWireType: At
      });
    };
    function gr(r, e, t, n, i, a, s, o, u, l, c) {
      this.name = r, this.registeredClass = e, this.isReference = t, this.isConst = n, this.isSmartPointer = i, this.pointeeType = a, this.sharingPolicy = s, this.rawGetPointee = o, this.rawConstructor = u, this.rawShare = l, this.rawDestructor = c, !i && e.baseClass === void 0 ? n ? (this.toWireType = Wt, this.destructorFunction = null) : (this.toWireType = Dt, this.destructorFunction = null) : this.toWireType = Ot;
    }
    var pe = (r, e, t) => {
      f.hasOwnProperty(r) || dr("Replacing nonexistent public symbol"), f[r].overloadTable !== void 0 && t !== void 0 ? f[r].overloadTable[t] = e : (f[r] = e, f[r].argCount = t);
    }, xt = (r, e, t) => {
      r = r.replace(/p/g, "i");
      var n = f["dynCall_" + r];
      return n(e, ...t);
    }, yr = [], he, g = (r) => {
      var e = yr[r];
      return e || (r >= yr.length && (yr.length = r + 1), yr[r] = e = he.get(r)), e;
    }, Mt = function(r, e) {
      let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
      if (r.includes("j"))
        return xt(r, e, t);
      var n = g(e)(...t);
      return n;
    }, It = (r, e) => function() {
      for (var t = arguments.length, n = new Array(t), i = 0; i < t; i++)
        n[i] = arguments[i];
      return Mt(r, e, n);
    }, k = (r, e) => {
      r = A(r);
      function t() {
        return r.includes("j") ? It(r, e) : g(e);
      }
      var n = t();
      return typeof n != "function" && y(`unknown function pointer with signature ${r}: ${e}`), n;
    }, Ht = (r, e) => {
      var t = rr(e, function(n) {
        this.name = e, this.message = n;
        var i = new Error(n).stack;
        i !== void 0 && (this.stack = this.toString() + `
` + i.replace(/^Error(:[^\n]*)?\n/, ""));
      });
      return t.prototype = Object.create(r.prototype), t.prototype.constructor = t, t.prototype.toString = function() {
        return this.message === void 0 ? this.name : `${this.name}: ${this.message}`;
      }, t;
    }, _e, ge = (r) => {
      var e = Te(r), t = A(e);
      return M(e), t;
    }, mr = (r, e) => {
      var t = [], n = {};
      function i(a) {
        if (!n[a] && !B[a]) {
          if (vr[a]) {
            vr[a].forEach(i);
            return;
          }
          t.push(a), n[a] = !0;
        }
      }
      throw e.forEach(i), new _e(`${r}: ` + t.map(ge).join([", "]));
    }, Vt = (r, e, t, n, i, a, s, o, u, l, c, v, p) => {
      c = A(c), a = k(i, a), o && (o = k(s, o)), l && (l = k(u, l)), p = k(v, p);
      var m = St(c);
      Or(m, function() {
        mr(`Cannot construct ${c} due to unbound types`, [n]);
      }), N([r, e, t], n ? [n] : [], (b) => {
        b = b[0];
        var P, C;
        n ? (P = b.registeredClass, C = P.instancePrototype) : C = _r.prototype;
        var T = rr(c, function() {
          if (Object.getPrototypeOf(this) !== z)
            throw new q("Use 'new' to construct " + c);
          if (F.constructor_body === void 0)
            throw new q(c + " has no accessible constructor");
          for (var Me = arguments.length, br = new Array(Me), wr = 0; wr < Me; wr++)
            br[wr] = arguments[wr];
          var Ie = F.constructor_body[br.length];
          if (Ie === void 0)
            throw new q(`Tried to invoke ctor of ${c} with invalid number of parameters (${br.length}) - expected (${Object.keys(F.constructor_body).toString()}) parameters instead!`);
          return Ie.apply(this, br);
        }), z = Object.create(C, {
          constructor: {
            value: T
          }
        });
        T.prototype = z;
        var F = new jt(c, T, z, p, P, a, o, l);
        if (F.baseClass) {
          var I, nr;
          (nr = (I = F.baseClass).__derivedClasses) !== null && nr !== void 0 || (I.__derivedClasses = []), F.baseClass.__derivedClasses.push(F);
        }
        var Ri = new gr(c, F, !0, !1, !1), Ue = new gr(c + "*", F, !1, !1, !1), xe = new gr(c + " const*", F, !1, !0, !1);
        return ce[r] = {
          pointerType: Ue,
          constPointerType: xe
        }, pe(m, T), [Ri, Ue, xe];
      });
    }, Ur = (r, e) => {
      for (var t = [], n = 0; n < r; n++)
        t.push($[e + n * 4 >> 2]);
      return t;
    };
    function Bt(r) {
      for (var e = 1; e < r.length; ++e)
        if (r[e] !== null && r[e].destructorFunction === void 0)
          return !0;
      return !1;
    }
    function xr(r, e, t, n, i, a) {
      var s = e.length;
      s < 2 && y("argTypes array size mismatch! Must at least get return value and 'this' types!");
      var o = e[1] !== null && t !== null, u = Bt(e), l = e[0].name !== "void", c = s - 2, v = new Array(c), p = [], m = [], b = function() {
        m.length = 0;
        var P;
        p.length = o ? 2 : 1, p[0] = i, o && (P = e[1].toWireType(m, this), p[1] = P);
        for (var C = 0; C < c; ++C)
          v[C] = e[C + 2].toWireType(m, C < 0 || arguments.length <= C ? void 0 : arguments[C]), p.push(v[C]);
        var T = n(...p);
        function z(F) {
          if (u)
            Sr(m);
          else
            for (var I = o ? 1 : 2; I < e.length; I++) {
              var nr = I === 1 ? P : v[I - 2];
              e[I].destructorFunction !== null && e[I].destructorFunction(nr);
            }
          if (l)
            return e[0].fromWireType(F);
        }
        return z(T);
      };
      return rr(r, b);
    }
    var Nt = (r, e, t, n, i, a) => {
      var s = Ur(e, t);
      i = k(n, i), N([], [r], (o) => {
        o = o[0];
        var u = `constructor ${o.name}`;
        if (o.registeredClass.constructor_body === void 0 && (o.registeredClass.constructor_body = []), o.registeredClass.constructor_body[e - 1] !== void 0)
          throw new q(`Cannot register multiple constructors with identical number of parameters (${e - 1}) for class '${o.name}'! Overload resolution is currently only performed using the parameter count, not actual type info!`);
        return o.registeredClass.constructor_body[e - 1] = () => {
          mr(`Cannot construct ${o.name} due to unbound types`, s);
        }, N([], s, (l) => (l.splice(1, 0, null), o.registeredClass.constructor_body[e - 1] = xr(u, l, null, i, a), [])), [];
      });
    }, ye = (r) => {
      r = r.trim();
      const e = r.indexOf("(");
      return e !== -1 ? r.substr(0, e) : r;
    }, zt = (r, e, t, n, i, a, s, o, u, l) => {
      var c = Ur(t, n);
      e = A(e), e = ye(e), a = k(i, a), N([], [r], (v) => {
        v = v[0];
        var p = `${v.name}.${e}`;
        e.startsWith("@@") && (e = Symbol[e.substring(2)]), o && v.registeredClass.pureVirtualFunctions.push(e);
        function m() {
          mr(`Cannot call ${p} due to unbound types`, c);
        }
        var b = v.registeredClass.instancePrototype, P = b[e];
        return P === void 0 || P.overloadTable === void 0 && P.className !== v.name && P.argCount === t - 2 ? (m.argCount = t - 2, m.className = v.name, b[e] = m) : (de(b, e, p), b[e].overloadTable[t - 2] = m), N([], c, (C) => {
          var T = xr(p, C, v, a, s);
          return b[e].overloadTable === void 0 ? (T.argCount = t - 2, b[e] = T) : b[e].overloadTable[t - 2] = T, [];
        }), [];
      });
    }, Mr = [], U = [], Ir = (r) => {
      r > 9 && --U[r + 1] === 0 && (U[r] = void 0, Mr.push(r));
    }, Lt = () => U.length / 2 - 5 - Mr.length, Zt = () => {
      U.push(0, 1, void 0, 1, null, 1, !0, 1, !1, 1), f.count_emval_handles = Lt;
    }, x = {
      toValue: (r) => (r || y("Cannot use deleted val. handle = " + r), U[r]),
      toHandle: (r) => {
        switch (r) {
          case void 0:
            return 2;
          case null:
            return 4;
          case !0:
            return 6;
          case !1:
            return 8;
          default: {
            const e = Mr.pop() || U.length;
            return U[e] = r, U[e + 1] = 1, e;
          }
        }
      }
    }, me = {
      name: "emscripten::val",
      fromWireType: (r) => {
        var e = x.toValue(r);
        return Ir(r), e;
      },
      toWireType: (r, e) => x.toHandle(e),
      argPackAdvance: O,
      readValueFromPointer: Y,
      destructorFunction: null
    }, Gt = (r) => R(r, me), Xt = (r, e, t) => {
      switch (e) {
        case 1:
          return t ? function(n) {
            return this.fromWireType(W[n]);
          } : function(n) {
            return this.fromWireType(E[n]);
          };
        case 2:
          return t ? function(n) {
            return this.fromWireType(G[n >> 1]);
          } : function(n) {
            return this.fromWireType(K[n >> 1]);
          };
        case 4:
          return t ? function(n) {
            return this.fromWireType(H[n >> 2]);
          } : function(n) {
            return this.fromWireType($[n >> 2]);
          };
        default:
          throw new TypeError(`invalid integer width (${e}): ${r}`);
      }
    }, qt = (r, e, t, n) => {
      e = A(e);
      function i() {
      }
      i.values = {}, R(r, {
        name: e,
        constructor: i,
        fromWireType: function(a) {
          return this.constructor.values[a];
        },
        toWireType: (a, s) => s.value,
        argPackAdvance: O,
        readValueFromPointer: Xt(e, t, n),
        destructorFunction: null
      }), Or(e, i);
    }, Hr = (r, e) => {
      var t = B[r];
      return t === void 0 && y(`${e} has unknown type ${ge(r)}`), t;
    }, Kt = (r, e, t) => {
      var n = Hr(r, "enum");
      e = A(e);
      var i = n.constructor, a = Object.create(n.constructor.prototype, {
        value: {
          value: t
        },
        constructor: {
          value: rr(`${n.name}_${e}`, function() {
          })
        }
      });
      i.values[t] = a, i[e] = a;
    }, Vr = (r) => {
      if (r === null)
        return "null";
      var e = typeof r;
      return e === "object" || e === "array" || e === "function" ? r.toString() : "" + r;
    }, Qt = (r, e) => {
      switch (e) {
        case 4:
          return function(t) {
            return this.fromWireType(Qr[t >> 2]);
          };
        case 8:
          return function(t) {
            return this.fromWireType(Yr[t >> 3]);
          };
        default:
          throw new TypeError(`invalid float width (${e}): ${r}`);
      }
    }, Yt = (r, e, t) => {
      e = A(e), R(r, {
        name: e,
        fromWireType: (n) => n,
        toWireType: (n, i) => i,
        argPackAdvance: O,
        readValueFromPointer: Qt(e, t),
        destructorFunction: null
      });
    }, Jt = (r, e, t, n, i, a, s, o) => {
      var u = Ur(e, t);
      r = A(r), r = ye(r), i = k(n, i), Or(r, function() {
        mr(`Cannot call ${r} due to unbound types`, u);
      }, e - 1), N([], u, (l) => {
        var c = [l[0], null].concat(l.slice(1));
        return pe(r, xr(r, c, null, i, a), e - 1), [];
      });
    }, rn = (r, e, t) => {
      switch (e) {
        case 1:
          return t ? (n) => W[n] : (n) => E[n];
        case 2:
          return t ? (n) => G[n >> 1] : (n) => K[n >> 1];
        case 4:
          return t ? (n) => H[n >> 2] : (n) => $[n >> 2];
        default:
          throw new TypeError(`invalid integer width (${e}): ${r}`);
      }
    }, en = (r, e, t, n, i) => {
      e = A(e);
      var a = (c) => c;
      if (n === 0) {
        var s = 32 - 8 * t;
        a = (c) => c << s >>> s;
      }
      var o = e.includes("unsigned"), u = (c, v) => {
      }, l;
      o ? l = function(c, v) {
        return u(v, this.name), v >>> 0;
      } : l = function(c, v) {
        return u(v, this.name), v;
      }, R(r, {
        name: e,
        fromWireType: a,
        toWireType: l,
        argPackAdvance: O,
        readValueFromPointer: rn(e, t, n !== 0),
        destructorFunction: null
      });
    }, tn = (r, e, t) => {
      var n = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], i = n[e];
      function a(s) {
        var o = $[s >> 2], u = $[s + 4 >> 2];
        return new i(W.buffer, u, o);
      }
      t = A(t), R(r, {
        name: t,
        fromWireType: a,
        argPackAdvance: O,
        readValueFromPointer: a
      }, {
        ignoreDuplicateRegistrations: !0
      });
    }, nn = Object.assign({
      optional: !0
    }, me), an = (r, e) => {
      R(r, nn);
    }, on = (r, e, t, n) => {
      if (!(n > 0)) return 0;
      for (var i = t, a = t + n - 1, s = 0; s < r.length; ++s) {
        var o = r.charCodeAt(s);
        if (o >= 55296 && o <= 57343) {
          var u = r.charCodeAt(++s);
          o = 65536 + ((o & 1023) << 10) | u & 1023;
        }
        if (o <= 127) {
          if (t >= a) break;
          e[t++] = o;
        } else if (o <= 2047) {
          if (t + 1 >= a) break;
          e[t++] = 192 | o >> 6, e[t++] = 128 | o & 63;
        } else if (o <= 65535) {
          if (t + 2 >= a) break;
          e[t++] = 224 | o >> 12, e[t++] = 128 | o >> 6 & 63, e[t++] = 128 | o & 63;
        } else {
          if (t + 3 >= a) break;
          e[t++] = 240 | o >> 18, e[t++] = 128 | o >> 12 & 63, e[t++] = 128 | o >> 6 & 63, e[t++] = 128 | o & 63;
        }
      }
      return e[t] = 0, t - i;
    }, er = (r, e, t) => on(r, E, e, t), sn = (r) => {
      for (var e = 0, t = 0; t < r.length; ++t) {
        var n = r.charCodeAt(t);
        n <= 127 ? e++ : n <= 2047 ? e += 2 : n >= 55296 && n <= 57343 ? (e += 4, ++t) : e += 3;
      }
      return e;
    }, $e = typeof TextDecoder < "u" ? new TextDecoder() : void 0, be = function(r) {
      let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : NaN;
      for (var n = e + t, i = e; r[i] && !(i >= n); ) ++i;
      if (i - e > 16 && r.buffer && $e)
        return $e.decode(r.subarray(e, i));
      for (var a = ""; e < i; ) {
        var s = r[e++];
        if (!(s & 128)) {
          a += String.fromCharCode(s);
          continue;
        }
        var o = r[e++] & 63;
        if ((s & 224) == 192) {
          a += String.fromCharCode((s & 31) << 6 | o);
          continue;
        }
        var u = r[e++] & 63;
        if ((s & 240) == 224 ? s = (s & 15) << 12 | o << 6 | u : s = (s & 7) << 18 | o << 12 | u << 6 | r[e++] & 63, s < 65536)
          a += String.fromCharCode(s);
        else {
          var l = s - 65536;
          a += String.fromCharCode(55296 | l >> 10, 56320 | l & 1023);
        }
      }
      return a;
    }, un = (r, e) => r ? be(E, r, e) : "", ln = (r, e) => {
      e = A(e);
      var t = e === "std::string";
      R(r, {
        name: e,
        fromWireType(n) {
          var i = $[n >> 2], a = n + 4, s;
          if (t)
            for (var o = a, u = 0; u <= i; ++u) {
              var l = a + u;
              if (u == i || E[l] == 0) {
                var c = l - o, v = un(o, c);
                s === void 0 ? s = v : (s += "\0", s += v), o = l + 1;
              }
            }
          else {
            for (var p = new Array(i), u = 0; u < i; ++u)
              p[u] = String.fromCharCode(E[a + u]);
            s = p.join("");
          }
          return M(n), s;
        },
        toWireType(n, i) {
          i instanceof ArrayBuffer && (i = new Uint8Array(i));
          var a, s = typeof i == "string";
          s || i instanceof Uint8Array || i instanceof Uint8ClampedArray || i instanceof Int8Array || y("Cannot pass non-string to std::string"), t && s ? a = sn(i) : a = i.length;
          var o = zr(4 + a + 1), u = o + 4;
          if ($[o >> 2] = a, t && s)
            er(i, u, a + 1);
          else if (s)
            for (var l = 0; l < a; ++l) {
              var c = i.charCodeAt(l);
              c > 255 && (M(u), y("String has UTF-16 code units that do not fit in 8 bits")), E[u + l] = c;
            }
          else
            for (var l = 0; l < a; ++l)
              E[u + l] = i[l];
          return n !== null && n.push(M, o), o;
        },
        argPackAdvance: O,
        readValueFromPointer: Y,
        destructorFunction(n) {
          M(n);
        }
      });
    }, we = typeof TextDecoder < "u" ? new TextDecoder("utf-16le") : void 0, fn = (r, e) => {
      for (var t = r, n = t >> 1, i = n + e / 2; !(n >= i) && K[n]; ) ++n;
      if (t = n << 1, t - r > 32 && we) return we.decode(E.subarray(r, t));
      for (var a = "", s = 0; !(s >= e / 2); ++s) {
        var o = G[r + s * 2 >> 1];
        if (o == 0) break;
        a += String.fromCharCode(o);
      }
      return a;
    }, cn = (r, e, t) => {
      var n;
      if ((n = t) !== null && n !== void 0 || (t = 2147483647), t < 2) return 0;
      t -= 2;
      for (var i = e, a = t < r.length * 2 ? t / 2 : r.length, s = 0; s < a; ++s) {
        var o = r.charCodeAt(s);
        G[e >> 1] = o, e += 2;
      }
      return G[e >> 1] = 0, e - i;
    }, vn = (r) => r.length * 2, dn = (r, e) => {
      for (var t = 0, n = ""; !(t >= e / 4); ) {
        var i = H[r + t * 4 >> 2];
        if (i == 0) break;
        if (++t, i >= 65536) {
          var a = i - 65536;
          n += String.fromCharCode(55296 | a >> 10, 56320 | a & 1023);
        } else
          n += String.fromCharCode(i);
      }
      return n;
    }, pn = (r, e, t) => {
      var n;
      if ((n = t) !== null && n !== void 0 || (t = 2147483647), t < 4) return 0;
      for (var i = e, a = i + t - 4, s = 0; s < r.length; ++s) {
        var o = r.charCodeAt(s);
        if (o >= 55296 && o <= 57343) {
          var u = r.charCodeAt(++s);
          o = 65536 + ((o & 1023) << 10) | u & 1023;
        }
        if (H[e >> 2] = o, e += 4, e + 4 > a) break;
      }
      return H[e >> 2] = 0, e - i;
    }, hn = (r) => {
      for (var e = 0, t = 0; t < r.length; ++t) {
        var n = r.charCodeAt(t);
        n >= 55296 && n <= 57343 && ++t, e += 4;
      }
      return e;
    }, _n = (r, e, t) => {
      t = A(t);
      var n, i, a, s;
      e === 2 ? (n = fn, i = cn, s = vn, a = (o) => K[o >> 1]) : e === 4 && (n = dn, i = pn, s = hn, a = (o) => $[o >> 2]), R(r, {
        name: t,
        fromWireType: (o) => {
          for (var u = $[o >> 2], l, c = o + 4, v = 0; v <= u; ++v) {
            var p = o + 4 + v * e;
            if (v == u || a(p) == 0) {
              var m = p - c, b = n(c, m);
              l === void 0 ? l = b : (l += "\0", l += b), c = p + e;
            }
          }
          return M(o), l;
        },
        toWireType: (o, u) => {
          typeof u != "string" && y(`Cannot pass non-string to C++ string type ${t}`);
          var l = s(u), c = zr(4 + l + e);
          return $[c >> 2] = l / e, i(u, c + 4, l + e), o !== null && o.push(M, c), c;
        },
        argPackAdvance: O,
        readValueFromPointer: Y,
        destructorFunction(o) {
          M(o);
        }
      });
    }, gn = (r, e, t, n, i, a) => {
      cr[r] = {
        name: A(e),
        rawConstructor: k(t, n),
        rawDestructor: k(i, a),
        fields: []
      };
    }, yn = (r, e, t, n, i, a, s, o, u, l) => {
      cr[r].fields.push({
        fieldName: A(e),
        getterReturnType: t,
        getter: k(n, i),
        getterContext: a,
        setterArgumentType: s,
        setter: k(o, u),
        setterContext: l
      });
    }, mn = (r, e) => {
      e = A(e), R(r, {
        isVoid: !0,
        name: e,
        argPackAdvance: 0,
        fromWireType: () => {
        },
        toWireType: (t, n) => {
        }
      });
    }, $n = (r, e, t) => E.copyWithin(r, e, e + t), Br = [], bn = (r, e, t, n) => (r = Br[r], e = x.toValue(e), r(null, e, t, n)), wn = {}, Cn = (r) => {
      var e = wn[r];
      return e === void 0 ? A(r) : e;
    }, Ce = () => {
      if (typeof globalThis == "object")
        return globalThis;
      function r(e) {
        e.$$$embind_global$$$ = e;
        var t = typeof $$$embind_global$$$ == "object" && e.$$$embind_global$$$ == e;
        return t || delete e.$$$embind_global$$$, t;
      }
      if (typeof $$$embind_global$$$ == "object" || (typeof global == "object" && r(global) ? $$$embind_global$$$ = global : typeof self == "object" && r(self) && ($$$embind_global$$$ = self), typeof $$$embind_global$$$ == "object"))
        return $$$embind_global$$$;
      throw Error("unable to get global object.");
    }, Tn = (r) => r === 0 ? x.toHandle(Ce()) : (r = Cn(r), x.toHandle(Ce()[r])), Pn = (r) => {
      var e = Br.length;
      return Br.push(r), e;
    }, An = (r, e) => {
      for (var t = new Array(r), n = 0; n < r; ++n)
        t[n] = Hr($[e + n * 4 >> 2], "parameter " + n);
      return t;
    }, En = Reflect.construct, Fn = (r, e, t) => {
      var n = [], i = r.toWireType(n, t);
      return n.length && ($[e >> 2] = x.toHandle(n)), i;
    }, Rn = (r, e, t) => {
      var n = An(r, e), i = n.shift();
      r--;
      var a = new Array(r), s = (u, l, c, v) => {
        for (var p = 0, m = 0; m < r; ++m)
          a[m] = n[m].readValueFromPointer(v + p), p += n[m].argPackAdvance;
        var b = t === 1 ? En(l, a) : l.apply(u, a);
        return Fn(i, c, b);
      }, o = `methodCaller<(${n.map((u) => u.name).join(", ")}) => ${i.name}>`;
      return Pn(rr(o, s));
    }, kn = (r) => {
      r > 9 && (U[r + 1] += 1);
    }, Sn = (r) => {
      var e = x.toValue(r);
      Sr(e), Ir(r);
    }, jn = (r, e) => {
      r = Hr(r, "_emval_take_value");
      var t = r.readValueFromPointer(e);
      return x.toHandle(t);
    }, Wn = (r, e, t, n) => {
      var i = (/* @__PURE__ */ new Date()).getFullYear(), a = new Date(i, 0, 1), s = new Date(i, 6, 1), o = a.getTimezoneOffset(), u = s.getTimezoneOffset(), l = Math.max(o, u);
      $[r >> 2] = l * 60, H[e >> 2] = +(o != u);
      var c = (m) => {
        var b = m >= 0 ? "-" : "+", P = Math.abs(m), C = String(Math.floor(P / 60)).padStart(2, "0"), T = String(P % 60).padStart(2, "0");
        return `UTC${b}${C}${T}`;
      }, v = c(o), p = c(u);
      u < o ? (er(v, t, 17), er(p, n, 17)) : (er(v, n, 17), er(p, t, 17));
    }, On = () => 2147483648, Dn = (r, e) => Math.ceil(r / e) * e, Un = (r) => {
      var e = or.buffer, t = (r - e.byteLength + 65535) / 65536 | 0;
      try {
        return or.grow(t), Jr(), 1;
      } catch {
      }
    }, xn = (r) => {
      var e = E.length;
      r >>>= 0;
      var t = On();
      if (r > t)
        return !1;
      for (var n = 1; n <= 4; n *= 2) {
        var i = e * (1 + 0.2 / n);
        i = Math.min(i, r + 100663296);
        var a = Math.min(t, Dn(Math.max(r, i), 65536)), s = Un(a);
        if (s)
          return !0;
      }
      return !1;
    }, Nr = {}, Mn = () => Xr || "./this.program", tr = () => {
      if (!tr.strings) {
        var r = (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8", e = {
          USER: "web_user",
          LOGNAME: "web_user",
          PATH: "/",
          PWD: "/",
          HOME: "/home/web_user",
          LANG: r,
          _: Mn()
        };
        for (var t in Nr)
          Nr[t] === void 0 ? delete e[t] : e[t] = Nr[t];
        var n = [];
        for (var t in e)
          n.push(`${t}=${e[t]}`);
        tr.strings = n;
      }
      return tr.strings;
    }, In = (r, e) => {
      for (var t = 0; t < r.length; ++t)
        W[e++] = r.charCodeAt(t);
      W[e] = 0;
    }, Hn = (r, e) => {
      var t = 0;
      return tr().forEach((n, i) => {
        var a = e + t;
        $[r + i * 4 >> 2] = a, In(n, a), t += n.length + 1;
      }), 0;
    }, Vn = (r, e) => {
      var t = tr();
      $[r >> 2] = t.length;
      var n = 0;
      return t.forEach((i) => n += i.length + 1), $[e >> 2] = n, 0;
    }, Bn = (r) => 52;
    function Nn(r, e, t, n, i) {
      return 70;
    }
    var zn = [null, [], []], Ln = (r, e) => {
      var t = zn[r];
      e === 0 || e === 10 ? ((r === 1 ? Le : Z)(be(t)), t.length = 0) : t.push(e);
    }, Zn = (r, e, t, n) => {
      for (var i = 0, a = 0; a < t; a++) {
        var s = $[e >> 2], o = $[e + 4 >> 2];
        e += 8;
        for (var u = 0; u < o; u++)
          Ln(r, E[s + u]);
        i += o;
      }
      return $[n >> 2] = i, 0;
    }, Gn = (r) => r;
    oe = f.InternalError = class extends Error {
      constructor(e) {
        super(e), this.name = "InternalError";
      }
    }, yt(), q = f.BindingError = class extends Error {
      constructor(e) {
        super(e), this.name = "BindingError";
      }
    }, Ft(), Ut(), _e = f.UnboundTypeError = Ht(Error, "UnboundTypeError"), Zt();
    var Xn = {
      t: ot,
      x: st,
      a: lt,
      j: ft,
      k: ct,
      O: vt,
      q: dt,
      ga: pt,
      d: ut,
      ca: ht,
      va: _t,
      ba: gt,
      pa: $t,
      ta: Vt,
      sa: Nt,
      E: zt,
      oa: Gt,
      F: qt,
      n: Kt,
      W: Yt,
      X: Jt,
      y: en,
      u: tn,
      ua: an,
      V: ln,
      P: _n,
      L: gn,
      wa: yn,
      qa: mn,
      ja: $n,
      T: bn,
      xa: Ir,
      ya: Tn,
      U: Rn,
      Y: kn,
      Z: Sn,
      ra: jn,
      da: Wn,
      ha: xn,
      ea: Hn,
      fa: Vn,
      ia: Bn,
      $: Nn,
      S: Zn,
      J: hi,
      C: gi,
      Q: Jn,
      R: Ti,
      r: ci,
      b: qn,
      D: pi,
      la: mi,
      c: ei,
      ka: $i,
      h: Yn,
      i: ai,
      s: oi,
      N: di,
      w: ui,
      I: wi,
      K: vi,
      z: yi,
      H: Pi,
      aa: Ei,
      _: Fi,
      l: ti,
      f: ri,
      e: Qn,
      g: Kn,
      M: Ci,
      m: ii,
      ma: _i,
      p: si,
      v: li,
      na: fi,
      B: bi,
      o: ni,
      G: Ai,
      A: Gn
    }, w = at(), Te = (r) => (Te = w.Ba)(r), M = f._free = (r) => (M = f._free = w.Ca)(r), zr = f._malloc = (r) => (zr = f._malloc = w.Ea)(r), Pe = (r) => (Pe = w.Fa)(r), d = (r, e) => (d = w.Ga)(r, e), Ae = (r) => (Ae = w.Ha)(r), Ee = (r) => (Ee = w.Ia)(r), Fe = () => (Fe = w.Ja)(), Re = (r) => (Re = w.Ka)(r), ke = (r) => (ke = w.La)(r), Se = (r, e, t) => (Se = w.Ma)(r, e, t);
    f.dynCall_viijii = (r, e, t, n, i, a, s) => (f.dynCall_viijii = w.Na)(r, e, t, n, i, a, s);
    var je = f.dynCall_jiii = (r, e, t, n) => (je = f.dynCall_jiii = w.Oa)(r, e, t, n);
    f.dynCall_jiji = (r, e, t, n, i) => (f.dynCall_jiji = w.Pa)(r, e, t, n, i);
    var We = f.dynCall_jiiii = (r, e, t, n, i) => (We = f.dynCall_jiiii = w.Qa)(r, e, t, n, i);
    f.dynCall_iiiiij = (r, e, t, n, i, a, s) => (f.dynCall_iiiiij = w.Ra)(r, e, t, n, i, a, s), f.dynCall_iiiiijj = (r, e, t, n, i, a, s, o, u) => (f.dynCall_iiiiijj = w.Sa)(r, e, t, n, i, a, s, o, u), f.dynCall_iiiiiijj = (r, e, t, n, i, a, s, o, u, l) => (f.dynCall_iiiiiijj = w.Ta)(r, e, t, n, i, a, s, o, u, l);
    function qn(r, e) {
      var t = _();
      try {
        return g(r)(e);
      } catch (n) {
        if (h(t), n !== n + 0) throw n;
        d(1, 0);
      }
    }
    function Kn(r, e, t, n) {
      var i = _();
      try {
        g(r)(e, t, n);
      } catch (a) {
        if (h(i), a !== a + 0) throw a;
        d(1, 0);
      }
    }
    function Qn(r, e, t) {
      var n = _();
      try {
        g(r)(e, t);
      } catch (i) {
        if (h(n), i !== i + 0) throw i;
        d(1, 0);
      }
    }
    function Yn(r, e, t, n) {
      var i = _();
      try {
        return g(r)(e, t, n);
      } catch (a) {
        if (h(i), a !== a + 0) throw a;
        d(1, 0);
      }
    }
    function Jn(r, e, t, n, i) {
      var a = _();
      try {
        return g(r)(e, t, n, i);
      } catch (s) {
        if (h(a), s !== s + 0) throw s;
        d(1, 0);
      }
    }
    function ri(r, e) {
      var t = _();
      try {
        g(r)(e);
      } catch (n) {
        if (h(t), n !== n + 0) throw n;
        d(1, 0);
      }
    }
    function ei(r, e, t) {
      var n = _();
      try {
        return g(r)(e, t);
      } catch (i) {
        if (h(n), i !== i + 0) throw i;
        d(1, 0);
      }
    }
    function ti(r) {
      var e = _();
      try {
        g(r)();
      } catch (t) {
        if (h(e), t !== t + 0) throw t;
        d(1, 0);
      }
    }
    function ni(r, e, t, n, i, a, s, o, u, l, c) {
      var v = _();
      try {
        g(r)(e, t, n, i, a, s, o, u, l, c);
      } catch (p) {
        if (h(v), p !== p + 0) throw p;
        d(1, 0);
      }
    }
    function ii(r, e, t, n, i) {
      var a = _();
      try {
        g(r)(e, t, n, i);
      } catch (s) {
        if (h(a), s !== s + 0) throw s;
        d(1, 0);
      }
    }
    function ai(r, e, t, n, i) {
      var a = _();
      try {
        return g(r)(e, t, n, i);
      } catch (s) {
        if (h(a), s !== s + 0) throw s;
        d(1, 0);
      }
    }
    function oi(r, e, t, n, i, a) {
      var s = _();
      try {
        return g(r)(e, t, n, i, a);
      } catch (o) {
        if (h(s), o !== o + 0) throw o;
        d(1, 0);
      }
    }
    function si(r, e, t, n, i, a) {
      var s = _();
      try {
        g(r)(e, t, n, i, a);
      } catch (o) {
        if (h(s), o !== o + 0) throw o;
        d(1, 0);
      }
    }
    function ui(r, e, t, n, i, a, s) {
      var o = _();
      try {
        return g(r)(e, t, n, i, a, s);
      } catch (u) {
        if (h(o), u !== u + 0) throw u;
        d(1, 0);
      }
    }
    function li(r, e, t, n, i, a, s, o) {
      var u = _();
      try {
        g(r)(e, t, n, i, a, s, o);
      } catch (l) {
        if (h(u), l !== l + 0) throw l;
        d(1, 0);
      }
    }
    function fi(r, e, t, n, i, a, s, o, u) {
      var l = _();
      try {
        g(r)(e, t, n, i, a, s, o, u);
      } catch (c) {
        if (h(l), c !== c + 0) throw c;
        d(1, 0);
      }
    }
    function ci(r) {
      var e = _();
      try {
        return g(r)();
      } catch (t) {
        if (h(e), t !== t + 0) throw t;
        d(1, 0);
      }
    }
    function vi(r, e, t, n, i, a, s, o, u) {
      var l = _();
      try {
        return g(r)(e, t, n, i, a, s, o, u);
      } catch (c) {
        if (h(l), c !== c + 0) throw c;
        d(1, 0);
      }
    }
    function di(r, e, t, n, i, a, s) {
      var o = _();
      try {
        return g(r)(e, t, n, i, a, s);
      } catch (u) {
        if (h(o), u !== u + 0) throw u;
        d(1, 0);
      }
    }
    function pi(r, e, t, n) {
      var i = _();
      try {
        return g(r)(e, t, n);
      } catch (a) {
        if (h(i), a !== a + 0) throw a;
        d(1, 0);
      }
    }
    function hi(r, e, t, n) {
      var i = _();
      try {
        return g(r)(e, t, n);
      } catch (a) {
        if (h(i), a !== a + 0) throw a;
        d(1, 0);
      }
    }
    function _i(r, e, t, n, i, a, s, o) {
      var u = _();
      try {
        g(r)(e, t, n, i, a, s, o);
      } catch (l) {
        if (h(u), l !== l + 0) throw l;
        d(1, 0);
      }
    }
    function gi(r, e, t, n, i, a) {
      var s = _();
      try {
        return g(r)(e, t, n, i, a);
      } catch (o) {
        if (h(s), o !== o + 0) throw o;
        d(1, 0);
      }
    }
    function yi(r, e, t, n, i, a, s, o, u, l) {
      var c = _();
      try {
        return g(r)(e, t, n, i, a, s, o, u, l);
      } catch (v) {
        if (h(c), v !== v + 0) throw v;
        d(1, 0);
      }
    }
    function mi(r, e, t) {
      var n = _();
      try {
        return g(r)(e, t);
      } catch (i) {
        if (h(n), i !== i + 0) throw i;
        d(1, 0);
      }
    }
    function $i(r, e, t, n, i) {
      var a = _();
      try {
        return g(r)(e, t, n, i);
      } catch (s) {
        if (h(a), s !== s + 0) throw s;
        d(1, 0);
      }
    }
    function bi(r, e, t, n, i, a, s, o, u, l) {
      var c = _();
      try {
        g(r)(e, t, n, i, a, s, o, u, l);
      } catch (v) {
        if (h(c), v !== v + 0) throw v;
        d(1, 0);
      }
    }
    function wi(r, e, t, n, i, a, s, o) {
      var u = _();
      try {
        return g(r)(e, t, n, i, a, s, o);
      } catch (l) {
        if (h(u), l !== l + 0) throw l;
        d(1, 0);
      }
    }
    function Ci(r, e, t, n, i, a, s) {
      var o = _();
      try {
        g(r)(e, t, n, i, a, s);
      } catch (u) {
        if (h(o), u !== u + 0) throw u;
        d(1, 0);
      }
    }
    function Ti(r, e, t, n) {
      var i = _();
      try {
        return g(r)(e, t, n);
      } catch (a) {
        if (h(i), a !== a + 0) throw a;
        d(1, 0);
      }
    }
    function Pi(r, e, t, n, i, a, s, o, u, l, c, v) {
      var p = _();
      try {
        return g(r)(e, t, n, i, a, s, o, u, l, c, v);
      } catch (m) {
        if (h(p), m !== m + 0) throw m;
        d(1, 0);
      }
    }
    function Ai(r, e, t, n, i, a, s, o, u, l, c, v, p, m, b, P) {
      var C = _();
      try {
        g(r)(e, t, n, i, a, s, o, u, l, c, v, p, m, b, P);
      } catch (T) {
        if (h(C), T !== T + 0) throw T;
        d(1, 0);
      }
    }
    function Ei(r, e, t, n) {
      var i = _();
      try {
        return je(r, e, t, n);
      } catch (a) {
        if (h(i), a !== a + 0) throw a;
        d(1, 0);
      }
    }
    function Fi(r, e, t, n, i) {
      var a = _();
      try {
        return We(r, e, t, n, i);
      } catch (s) {
        if (h(a), s !== s + 0) throw s;
        d(1, 0);
      }
    }
    var $r, Oe;
    Q = function r() {
      $r || De(), $r || (Q = r);
    };
    function De() {
      if (V > 0 || !Oe && (Oe = 1, Ze(), V > 0))
        return;
      function r() {
        var e;
        $r || ($r = 1, f.calledRun = 1, !Kr && (Ge(), Zr(f), (e = f.onRuntimeInitialized) === null || e === void 0 || e.call(f), Xe()));
      }
      f.setStatus ? (f.setStatus("Running..."), setTimeout(() => {
        setTimeout(() => f.setStatus(""), 1), r();
      }, 1)) : r();
    }
    if (f.preInit)
      for (typeof f.preInit == "function" && (f.preInit = [f.preInit]); f.preInit.length > 0; )
        f.preInit.pop()();
    return De(), Lr = Ve, Lr;
  };
})();
function xi(S) {
  return ki(
    Cr,
    S
  );
}
function Mi(S) {
  return Si(
    Cr,
    S
  );
}
async function Ii(S, L) {
  return ji(
    Cr,
    S,
    L
  );
}
async function Hi(S, L) {
  return Wi(
    Cr,
    S,
    L
  );
}
export {
  Ni as barcodeFormats,
  zi as binarizers,
  Li as characterSets,
  Zi as contentTypes,
  Gi as defaultDecodeHints,
  Xi as defaultReaderOptions,
  qi as eanAddOnSymbols,
  xi as getZXingModule,
  Ki as purgeZXingModule,
  Hi as readBarcodesFromImageData,
  Ii as readBarcodesFromImageFile,
  Qi as readOutputEccLevels,
  Mi as setZXingModuleOverrides,
  Yi as textModes
};
