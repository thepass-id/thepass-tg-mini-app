import i from "url-join";
import { nameResolutionStarknetIdsSchema as d, nameResolutionStarknetIdSchema as h, nameResolutionAddressesSchema as m, providersNamesSchema as p } from "./schema.js";
import { HTTPService as u } from "../http/HttpService.js";
class f {
  constructor(s, r) {
    this.apiBase = s, this.headers = r, this.httpService = new u(this.headers, "json");
  }
  async getAddressFromMultipleStarknetId(s, r, t) {
    const e = new URLSearchParams(r.map((c) => ["domain", c]));
    t && e.set("includeAvatar", "true");
    const o = i(this.apiBase, s, "starknet.id", `?${e}`), a = await this.httpService.get(o), n = d.safeParse(a);
    if (!n.success)
      throw new Error("Failed to parse name resolution");
    return n.data;
  }
  async getAddressFromStarknetId(s, r, t) {
    const e = i(this.apiBase, s, "starknet.id", r, t ? "?includeAvatar=true" : ""), o = await this.httpService.get(e), a = h.safeParse(o);
    if (!a.success)
      throw new Error("Failed to parse name resolution");
    return a.data;
  }
  /**
   * getAddressFromStarknetId: retrieve address from starknetId
   */
  async getStarknetIdFromAddress(s, r, t) {
    const e = new URLSearchParams(r.map((c) => ["address", c]));
    t && e.set("includeAvatar", "true");
    const o = i(this.apiBase, s, "addresses", `?${e}`), a = await this.httpService.get(o), n = m.safeParse(a);
    if (!n.success)
      throw new Error("Failed to parse name resolution");
    return n.data;
  }
  async getProvidersNames(s) {
    const r = i(this.apiBase, s, "providers", "name"), t = await this.httpService.get(r), e = p.safeParse(t);
    if (!e.success)
      throw new Error("Failed to parse name resolution");
    return e.data;
  }
}
export {
  f as ResolveNameService
};
