const u = (e, t) => ({
  decimals: t,
  value: t >= e.decimals ? e.value * BigInt(10) ** BigInt(t - e.decimals) : e.value / BigInt(10) ** BigInt(e.decimals - t)
}), v = (e) => {
  if (e.value === BigInt(0))
    return { value: BigInt(0), decimals: 0 };
  const i = e.value.toString().replace("-", "").split("").reverse();
  let l = 0;
  for (const a of i) {
    if (a !== "0")
      break;
    l++;
  }
  const s = Math.max(0, e.decimals - l);
  return u(e, s);
}, d = (e, t) => {
  const i = Math.max(e.decimals, t.decimals), [l, s] = [e, t].map((a) => u(a, i));
  return [l.value, s.value, i];
}, r = (e) => (t, i) => {
  const [l, s, a] = d(t, i);
  return {
    decimals: a,
    value: e(l, s, a)
  };
}, c = (e) => (t, i) => {
  const [l, s] = d(t, i);
  return e(l, s);
}, h = r((e, t) => e + t), j = r((e, t) => e - t), g = r((e, t, i) => {
  if (t === BigInt(0))
    throw new Error("Division by zero is not allowed");
  return e * BigInt(10) ** BigInt(i) / t;
}), p = (e, t) => v({
  decimals: e.decimals + t.decimals,
  value: e.value * t.value
}), A = r((e, t) => {
  if (t === BigInt(0))
    throw new Error("Modulus by zero is not allowed");
  return e % t;
}), D = (e) => ({
  decimals: e.decimals,
  value: e.value >= BigInt(0) ? e.value : -e.value
}), m = c((e, t) => e === t), B = c((e, t) => e < t), E = c((e, t) => e > t), I = c((e, t) => e <= t), f = c((e, t) => e >= t), b = (e, t) => !m(e, t), w = (e, t) => {
  if (!Number.isInteger(t))
    throw new Error("Exponent must be an integer");
  if (t < 0)
    return g({ value: BigInt(1), decimals: 0 }, w(e, -t));
  if (t === 0)
    return { value: BigInt(1), decimals: 0 };
  let i = { value: BigInt(1), decimals: 0 }, l = { ...e }, s = Math.abs(t);
  for (; s > 0; )
    s & 1 && (i = {
      value: i.value * l.value,
      decimals: i.decimals + l.decimals
    }), l = {
      value: l.value * l.value,
      decimals: l.decimals * 2
    }, s >>= 1;
  return i;
}, q = (e) => {
  if (B(e, { value: BigInt(0), decimals: 0 }))
    throw new Error("Cannot calculate square root of negative number");
  if (e.value === BigInt(0))
    return { value: BigInt(0), decimals: 0 };
  const t = e.decimals + e.decimals % 2, i = u(e, t);
  let l = BigInt(0), s = i.value, a = s;
  for (; l <= s; ) {
    const n = (l + s) / BigInt(2), o = n * n;
    if (o === i.value) {
      a = n;
      break;
    }
    o < i.value ? (l = n + BigInt(1), a = n) : s = n - BigInt(1);
  }
  return {
    value: a,
    decimals: t / 2
  };
}, z = (e) => {
  const t = BigInt(10) ** BigInt(e.decimals), i = e.value % t, l = t / BigInt(2);
  return {
    decimals: 0,
    value: e.value / t + (i >= l ? BigInt(1) : BigInt(0))
  };
}, M = (e) => ({
  decimals: 0,
  value: e.value / BigInt(10) ** BigInt(e.decimals)
}), S = (e) => {
  const t = BigInt(10) ** BigInt(e.decimals);
  return {
    decimals: 0,
    value: (e.value + t - BigInt(1)) / t
  };
}, k = (e, t) => f(e, t) ? e : t, y = (e, t) => I(e, t) ? e : t, C = (e) => e.value === BigInt(0) ? 0 : e.value > BigInt(0) ? 1 : -1;
export {
  D as abs,
  h as add,
  S as ceil,
  g as div,
  m as eq,
  M as floor,
  E as gt,
  f as gte,
  B as lt,
  I as lte,
  k as max,
  y as min,
  A as mod,
  p as mul,
  b as not,
  w as pow,
  z as round,
  C as sign,
  q as sqrt,
  j as sub,
  u as toFixedDecimals,
  v as toTiniestPossibleDecimal
};
