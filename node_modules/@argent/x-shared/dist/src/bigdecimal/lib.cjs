"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const r=(e,t)=>({decimals:t,value:t>=e.decimals?e.value*BigInt(10)**BigInt(t-e.decimals):e.value/BigInt(10)**BigInt(e.decimals-t)}),d=e=>{if(e.value===BigInt(0))return{value:BigInt(0),decimals:0};const i=e.value.toString().replace("-","").split("").reverse();let l=0;for(const a of i){if(a!=="0")break;l++}const s=Math.max(0,e.decimals-l);return r(e,s)},v=(e,t)=>{const i=Math.max(e.decimals,t.decimals),[l,s]=[e,t].map(a=>r(a,i));return[l.value,s.value,i]},o=e=>(t,i)=>{const[l,s,a]=v(t,i);return{decimals:a,value:e(l,s,a)}},c=e=>(t,i)=>{const[l,s]=v(t,i);return e(l,s)},h=o((e,t)=>e+t),b=o((e,t)=>e-t),g=o((e,t,i)=>{if(t===BigInt(0))throw new Error("Division by zero is not allowed");return e*BigInt(10)**BigInt(i)/t}),j=(e,t)=>d({decimals:e.decimals+t.decimals,value:e.value*t.value}),p=o((e,t)=>{if(t===BigInt(0))throw new Error("Modulus by zero is not allowed");return e%t}),D=e=>({decimals:e.decimals,value:e.value>=BigInt(0)?e.value:-e.value}),m=c((e,t)=>e===t),B=c((e,t)=>e<t),q=c((e,t)=>e>t),I=c((e,t)=>e<=t),f=c((e,t)=>e>=t),A=(e,t)=>!m(e,t),w=(e,t)=>{if(!Number.isInteger(t))throw new Error("Exponent must be an integer");if(t<0)return g({value:BigInt(1),decimals:0},w(e,-t));if(t===0)return{value:BigInt(1),decimals:0};let i={value:BigInt(1),decimals:0},l={...e},s=Math.abs(t);for(;s>0;)s&1&&(i={value:i.value*l.value,decimals:i.decimals+l.decimals}),l={value:l.value*l.value,decimals:l.decimals*2},s>>=1;return i},E=e=>{if(B(e,{value:BigInt(0),decimals:0}))throw new Error("Cannot calculate square root of negative number");if(e.value===BigInt(0))return{value:BigInt(0),decimals:0};const t=e.decimals+e.decimals%2,i=r(e,t);let l=BigInt(0),s=i.value,a=s;for(;l<=s;){const n=(l+s)/BigInt(2),u=n*n;if(u===i.value){a=n;break}u<i.value?(l=n+BigInt(1),a=n):s=n-BigInt(1)}return{value:a,decimals:t/2}},M=e=>{const t=BigInt(10)**BigInt(e.decimals),i=e.value%t,l=t/BigInt(2);return{decimals:0,value:e.value/t+(i>=l?BigInt(1):BigInt(0))}},S=e=>({decimals:0,value:e.value/BigInt(10)**BigInt(e.decimals)}),y=e=>{const t=BigInt(10)**BigInt(e.decimals);return{decimals:0,value:(e.value+t-BigInt(1))/t}},z=(e,t)=>f(e,t)?e:t,F=(e,t)=>I(e,t)?e:t,O=e=>e.value===BigInt(0)?0:e.value>BigInt(0)?1:-1;exports.abs=D;exports.add=h;exports.ceil=y;exports.div=g;exports.eq=m;exports.floor=S;exports.gt=q;exports.gte=f;exports.lt=B;exports.lte=I;exports.max=z;exports.min=F;exports.mod=p;exports.mul=j;exports.not=A;exports.pow=w;exports.round=M;exports.sign=O;exports.sqrt=E;exports.sub=b;exports.toFixedDecimals=r;exports.toTiniestPossibleDecimal=d;
