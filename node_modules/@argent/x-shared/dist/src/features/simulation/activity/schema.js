import { z as t } from "zod";
import { stakerInfoSchema as m, stakingActionSchema as g, investmentMetaSchema as d } from "../../../staking/schema.js";
import { actionSchema as y, targetedDappSchema as b } from "../transactionReview/schema.js";
import { addressSchemaArgentBackend as e } from "../../../chains/starknet/address.js";
const r = t.object({
  network: t.string(),
  hash: t.string(),
  status: t.string(),
  blockNumber: t.number().optional(),
  transactionIndex: t.number()
}), a = t.object({
  type: t.enum(["token", "nft"]),
  tokenAddress: e,
  amount: t.string().optional(),
  fiatAmount: t.object({
    currency: t.string(),
    currencyAmount: t.number()
  }).optional().nullable()
}), i = t.enum(["ethereum", "starknet", "zksync", "zksync2"]), S = t.object({
  type: t.enum(["payment", "gasFee"]),
  leg: t.enum(["credit", "debit"]),
  asset: a,
  counterParty: e.optional(),
  counterPartyNetwork: i.optional()
}), h = t.object({
  address: e,
  network: i,
  type: t.enum(["wallet", "token"])
}), k = t.object({
  chainId: t.enum(["TESTNET", "MAINNET", "SEPOLIA"]),
  ethereumNetwork: t.enum(["mainnet", "sepolia"])
}), v = t.enum([
  "approval",
  "changePubKey",
  "dappInteraction",
  "deploy",
  "gift",
  "multicall",
  "payment",
  "security",
  "trade",
  "staking"
]), s = t.enum([
  "triggerEscapeGuardian",
  "triggerEscapeSigner",
  "escapeGuardian",
  "escapeSigner",
  "guardianChanged",
  "guardianBackupChanged",
  "signerChanged",
  "cancelEscape",
  "accountUpgraded",
  "multisigConfigurationUpdated"
]), f = t.object({
  name: t.string(),
  parameters: t.array(t.unknown()).optional()
}), j = t.object({
  guid: t.string().optional(),
  signerType: t.string().optional(),
  // StarknetKey, Secp256k1, Secp256r1, Eip191, Webauthn
  signer: t.object({
    publicKey: t.string().optional()
  }).optional()
}), A = t.object({
  activeAt: t.string().optional(),
  newGuardian: t.string().optional(),
  newImplementation: t.string().optional(),
  newVersion: t.string().optional(),
  signerGuid: t.string().optional(),
  signers: t.array(j).optional()
}), o = t.discriminatedUnion("type", [
  t.object({
    type: t.literal("deploy"),
    deployer: e,
    contractAddress: e
  }),
  t.object({
    type: t.literal("approval"),
    spender: e,
    asset: a,
    approvalType: t.string()
  }),
  t.object({
    type: t.literal("payment"),
    counterparty: e,
    leg: t.string(),
    asset: a,
    counterpartyNetwork: i.optional()
  }),
  t.object({
    type: t.literal("trade"),
    srcAsset: a,
    destAsset: a
  }),
  t.object({
    type: t.literal("security"),
    action: s,
    context: A.optional()
  }),
  t.object({
    type: t.literal("dappInteraction"),
    dappAddress: e,
    function: f.optional().nullable()
    // This object is often null. It happens when we were unable to get the ABI or failed decoding the function call
  }),
  t.object({
    type: t.literal("staking"),
    stakingAction: g,
    counterparty: e,
    asset: a,
    stakerInfo: m
  }),
  t.object({
    type: t.literal("gift"),
    counterparty: e.optional(),
    leg: t.string(),
    asset: a,
    counterpartyNetwork: i.optional()
  })
]), w = t.union([
  o,
  t.object({
    type: t.literal("multicall"),
    calls: t.array(t.object({
      details: o
    }))
  })
]), N = t.object({
  dappId: t.string(),
  name: t.string().optional().nullable()
}), c = t.object({
  sent: t.boolean(),
  asset: t.discriminatedUnion("type", [
    t.object({
      type: t.literal("nft"),
      tokenAddress: e,
      tokenId: t.coerce.number().optional(),
      amount: t.string().optional(),
      collectionName: t.string().optional(),
      collectionPreviewImage: t.string().optional().nullable(),
      nftName: t.string().optional().nullable(),
      nftPreviewImage: t.string().optional().nullable()
    }),
    t.object({
      type: t.literal("token"),
      tokenAddress: e,
      amount: t.string().optional(),
      fiatAmount: t.object({
        currency: t.string(),
        currencyAmount: t.coerce.string()
      }).optional().nullable()
    })
  ])
}), I = t.object({
  type: t.string(),
  // "gas" for example
  to: e,
  actualFee: t.object({
    type: t.string(),
    tokenAddress: e,
    amount: t.string().optional(),
    fiatAmount: t.object({
      currency: t.string(),
      currencyAmount: t.number()
    }).optional().nullable()
  })
}), l = t.enum(["pending", "success", "failure"]), p = t.object({
  compositeId: t.string(),
  id: t.string().uuid(),
  status: l,
  wallet: e,
  txSender: e,
  source: t.string(),
  type: v,
  group: t.enum(["finance", "security"]),
  submitted: t.number(),
  lastModified: t.number(),
  transaction: r,
  transfers: t.array(S),
  // to be clarified
  fees: t.array(I).optional(),
  relatedAddresses: t.array(h).nullable(),
  network: t.string(),
  networkDetails: k.optional(),
  details: w,
  transferSummary: t.array(c).optional(),
  dapp: N.optional(),
  actions: t.array(y).optional(),
  title: t.string().optional(),
  multisigDetails: t.object({
    signers: t.array(e)
  }).optional()
}), E = t.object({
  title: t.string().optional(),
  shortTitle: t.string().optional(),
  subtitle: t.string().optional(),
  /** let's not import the keys from x-ui here */
  icon: t.string().optional(),
  investment: d.optional(),
  isExecuteFromOutside: t.boolean().optional()
}), T = "native", x = "rejected", D = "cancelled", P = "queued", F = p.pick({
  status: !0,
  actions: !0,
  submitted: !0,
  lastModified: !0,
  transferSummary: !0,
  fees: !0,
  multisigDetails: !0
}).extend({
  status: t.union([
    l,
    t.enum([
      x,
      D,
      P
    ])
  ]),
  type: t.literal(T),
  transaction: r.pick({
    hash: !0
  }),
  dapp: b.optional(),
  meta: E.optional()
}), M = t.array(p), B = t.object({
  activities: M,
  page: t.number(),
  pageSize: t.number(),
  totalElements: t.number(),
  totalPages: t.number()
});
function K(n) {
  return s.safeParse(n).success;
}
const u = (n) => c.safeParse(n).success, O = (n) => u(n) && n.asset.type === "token", R = (n) => u(n) && n.asset.type === "nft";
export {
  D as NativeActivityStatusCancelled,
  P as NativeActivityStatusQueued,
  x as NativeActivityStatusRejected,
  T as NativeActivityTypeNative,
  M as activitiesSchema,
  N as activityDappSchema,
  w as activityDetailsSchema,
  B as activityResponseSchema,
  p as activitySchema,
  c as activitySummarySchema,
  S as activityTransferSchema,
  I as feeSchema,
  K as isActivityDetailsAction,
  u as isActivitySummary,
  R as isNftActivitySummary,
  O as isTokenActivitySummary,
  E as nativeActivityMetaSchema,
  F as nativeActivitySchema
};
