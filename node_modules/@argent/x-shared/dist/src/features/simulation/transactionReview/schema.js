import { z as t } from "zod";
import { estimatedFeesSchema as b } from "../fees/schema.js";
import { severitySchema as u, reasonsSchema as S } from "../warning/schema.js";
import { addressSchemaArgentBackend as o, addressSchema as f } from "../../../chains/starknet/address.js";
const h = t.object({
  name: t.string(),
  url: t.string(),
  position: t.number()
}), e = t.object({
  address: t.string(),
  name: t.string(),
  symbol: t.string().optional(),
  decimals: t.number().optional(),
  unknown: t.boolean(),
  iconUrl: t.string().optional(),
  type: t.string()
}), r = t.discriminatedUnion("type", [
  t.object({
    type: t.literal("amount"),
    label: t.string(),
    token: e,
    amount: t.string(),
    usd: t.string(),
    editable: t.boolean()
  }),
  t.object({
    type: t.literal("address"),
    label: t.string(),
    address: t.string(),
    addressName: t.string().optional(),
    // tbd whether it's isVerified or verified
    verified: t.boolean().optional()
  }),
  t.object({
    type: t.literal("timestamp"),
    label: t.string(),
    value: t.string()
  }),
  t.object({
    type: t.literal("token_address"),
    label: t.string(),
    token: e
  }),
  t.object({
    type: t.literal("calldata"),
    label: t.string(),
    entrypoint: t.string(),
    calldata: t.array(t.string())
  }),
  t.object({
    type: t.literal("text"),
    label: t.string(),
    text: t.string()
  }),
  t.object({
    type: t.literal("nft"),
    label: t.string(),
    token: e
  })
]), j = t.object({
  name: t.string(),
  properties: t.array(r),
  defaultProperties: t.array(r).optional()
}), y = t.union([
  t.literal("verified"),
  t.literal("neutral"),
  t.literal("partial"),
  t.literal("warn")
]), k = t.object({
  unknown_token: t.unknown().optional(),
  date_of_addition: t.string().optional(),
  contract_address: f.optional(),
  reason: t.string().optional(),
  value: t.string().or(t.number()).optional()
}), l = t.object({
  reason: S,
  details: k.optional(),
  severity: u
}), v = t.object({
  assessment: y,
  warnings: t.array(l).optional(),
  assessmentReasons: t.array(t.string()).optional(),
  assessmentDetails: t.object({
    contract_address: t.string()
  }).optional(),
  action: j
}), w = t.object({
  name: t.string(),
  description: t.string(),
  logoUrl: t.string(),
  iconUrl: t.string(),
  argentVerified: t.boolean(),
  links: t.array(h)
}), c = t.object({
  assessment: t.union([
    t.literal("verified"),
    t.literal("neutral"),
    t.literal("partial"),
    t.literal("warn")
  ]),
  warnings: t.array(l).optional(),
  assessmentDetails: t.object({
    contract_address: t.string()
  }).optional(),
  targetedDapp: w.optional(),
  reviews: t.array(v)
}).optional(), p = t.object({
  banner: t.string().nullable().optional(),
  preview: t.string().nullable().optional(),
  full: t.string().nullable().optional(),
  original: t.string().nullable().optional()
}), U = t.object({
  twitter: t.string().optional(),
  external: t.string().optional(),
  discord: t.string().optional()
}), i = t.object({
  address: o,
  decimals: t.number().optional(),
  symbol: t.string().optional(),
  name: t.string(),
  description: t.string().optional(),
  type: t.string().optional(),
  usdValue: t.string().optional(),
  iconUrl: t.string().optional(),
  unknown: t.boolean().optional(),
  imageUrls: p.optional(),
  links: U.optional()
}), E = t.object({
  tokenAddress: o,
  owner: o,
  spender: o,
  value: t.string().optional(),
  approvalForAll: t.boolean(),
  details: i.optional()
}), A = t.object({
  tokenAddress: o,
  from: o,
  to: o,
  tokenId: t.string().optional(),
  value: t.string().optional(),
  details: i.optional()
}), a = t.union([t.string(), t.number(), t.bigint()]).transform((n) => parseInt(n.toString(), 10)), s = {
  overallFee: a,
  gasPrice: a,
  gasUsage: a,
  dataGasPrice: a.optional(),
  dataGasConsumed: a.optional()
}, D = t.object({
  ...s,
  unit: t.string().transform((n) => n.toUpperCase()).pipe(t.literal("WEI")),
  maxFee: a
}).or(t.object({
  ...s,
  unit: t.string().transform((n) => n.toUpperCase()).pipe(t.literal("FRI")),
  maxAmount: a,
  maxPricePerUnit: a
})), x = t.object({
  type: t.string(),
  label: t.string(),
  tokenId: t.string().optional(),
  value: t.string().optional(),
  usdValue: t.string().optional(),
  token: i,
  sent: t.boolean().optional(),
  tokenIdDetails: t.object({
    name: t.string().optional(),
    description: t.string().optional(),
    imageUrls: p.optional()
  }).optional()
}), F = t.object({
  approvals: t.array(E).optional(),
  transfers: t.array(A).optional(),
  calculatedNonce: t.string().optional(),
  feeEstimation: D,
  summary: t.array(x).optional()
}), P = t.object({
  label: t.string().optional(),
  code: t.number().optional(),
  message: t.string().optional(),
  error: t.string().optional()
}), m = t.object({
  reviewOfTransaction: c,
  simulation: F,
  simulationError: t.undefined()
}), g = t.object({
  reviewOfTransaction: c,
  simulation: t.undefined(),
  simulationError: P
}), d = m.or(g), C = t.object({
  transactions: t.array(d).optional()
}), O = t.object({
  transactions: t.array(d).optional(),
  enrichedFeeEstimation: b.optional(),
  isBackendDown: t.boolean().default(!1).optional()
});
function R(n) {
  return m.safeParse(n).success;
}
function V(n) {
  return g.safeParse(n).success;
}
export {
  j as actionSchema,
  y as assessmentSchema,
  O as enrichedSimulateAndReviewSchema,
  D as feeEstimationSchema,
  R as isNotTransactionSimulationError,
  V as isTransactionSimulationError,
  r as propertySchema,
  v as reviewSchema,
  C as simulateAndReviewSchema,
  w as targetedDappSchema,
  k as warningDetailsSchema,
  l as warningSchema
};
