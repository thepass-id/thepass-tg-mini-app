import { HttpError as r } from "./HttpError.js";
const o = (a) => {
  process.env.NODE_ENV;
};
function h(a, e) {
  const s = a.clone(), t = new Headers(s.headers);
  for (const [n, i] of Object.entries(e))
    t.set(n, i);
  return new Response(s.body, {
    status: s.status,
    statusText: a.statusText,
    headers: t
  });
}
class p {
  constructor(e, s, t, n) {
    this.dateService = e, this.cacheService = s, this.httpService = t, this.options = n, this.inFlightRequests = /* @__PURE__ */ new Map();
  }
  async rawGet(e, s) {
    try {
      const t = await this.cacheService.get(e), n = await this.dateService.now(), i = new Date(t.headers.get("date") || ""), c = n.getTime() - i.getTime();
      if (c < this.options.freshFor)
        return o("ðŸŸ¢ [SWR] Using fresh cache"), t;
      if (c < this.options.staleFor)
        return this.fetchAndCache(e, s), o("ðŸŸ  [SWR] Revalidating cache"), t;
      throw new Error("Cache too old");
    } catch (t) {
      if (t instanceof r)
        throw t;
      return o(), await this.fetchAndCache(e, s);
    }
  }
  async get(e, s) {
    const t = await this.rawGet(e, s);
    return this.parseResponse(t);
  }
  async fetchAndCache(e, s) {
    const t = this.inFlightRequests.get(e);
    if (!t) {
      const n = this.httpService.get(e, s).then(async (i) => {
        const c = await this.dateService.now();
        return await this.cacheService.set(e, h(i, {
          date: c.toUTCString()
        })), i;
      }).finally(() => {
        this.inFlightRequests.delete(e);
      });
      return this.inFlightRequests.set(e, n), n;
    }
    return o(), t;
  }
  parseResponse(e) {
    if (e.ok)
      return e.json();
    throw new r(e.statusText, e.status);
  }
}
export {
  p as SWRService
};
