class r {
  constructor(e, c) {
    this.cachePromise = c.open(e).catch((a) => (console.error(new Error("Failed to open cache", { cause: a })), null));
  }
  async get(e) {
    const c = await this.cachePromise;
    if (!c)
      throw new Error("No cache available");
    const a = await c.match(e).catch(() => {
      throw new Error("Failed to match cache");
    });
    if (!a)
      throw new Error("Failed to match cache");
    return a.clone();
  }
  async set(e, c) {
    const a = await this.cachePromise;
    a && await a.put(e, c).catch(() => {
      throw new Error("Failed to match cache");
    });
  }
  async delete(e) {
    const c = await this.cachePromise;
    return c ? c.delete(e) : !1;
  }
  // should be called on logout
  async flush() {
    const e = await this.cachePromise;
    if (!e)
      return;
    const c = await e.keys();
    await Promise.allSettled(c.map((a) => e.delete(a)));
  }
}
export {
  r as CacheService
};
