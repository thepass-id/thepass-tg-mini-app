import { TransactionType as u } from "starknet";
import g from "url-join";
import { ReviewError as d } from "../../errors/review.js";
import { getTxVersionFromFeeToken as E } from "../getTransactionVersion.js";
import { getPayloadFromTransaction as I, getEstimatedFeeFromSimulationAndRespectWatermarkFee as C } from "../estimate/utils.js";
import { urlWithQuery as O } from "../../utils/url/urlWithQuery.js";
import { simulateAndReviewSchema as S, isTransactionSimulationError as N } from "../../features/simulation/transactionReview/schema.js";
import { ensureArray as v } from "../../utils/arrays.js";
class x {
  constructor(a, e) {
    this.apiBase = a, this.httpService = e;
  }
  /**
   * Fetch transaction review labels
   * @returns {Promise<TransactionReviewLabel[] | undefined>} The account activities.
   */
  async getLabels() {
    const a = g(this.apiBase, "reviewer", "labels");
    return await this.httpService.get(a);
  }
  /**
   * Fetch transaction review warnings.
   * @returns {Promise<TransactionReviewWarning[] | undefined>} The account activities.
   */
  async getWarnings() {
    const a = g(this.apiBase, "reviewer", "warnings/reasons");
    return await this.httpService.get(a);
  }
  async simulateAndReview(a, e, o, n, c, s) {
    var m;
    const r = e.some((t) => t.type === "DEPLOY_ACCOUNT");
    try {
      if (!("getChainId" in a))
        throw new Error("MISSING_METHOD");
      const t = E(o), i = r ? "0x0" : await a.getNonce(), l = await a.getChainId(), w = {
        transactions: e.map((h) => ({
          ...I({
            transaction: h,
            nonce: i,
            version: t,
            chainId: l,
            isDeploymentTransaction: r,
            appDomain: n,
            cairoVersion: a.cairoVersion,
            address: a.address
          }),
          type: h.type
        }))
      }, _ = g(this.apiBase, "reviewer", "transactions", "v2", "review", "starknet"), y = s ? O(_, { delayedTransactions: "true" }) : _, p = await this.httpService.post(y, {
        headers: {
          Accept: "application/json",
          "Content-Type": "application/json"
        },
        body: JSON.stringify(w)
      }, S);
      if ((m = p.transactions) == null ? void 0 : m.some((h) => N(h)))
        return p;
      const F = C(p, o);
      return {
        ...p,
        enrichedFeeEstimation: F
      };
    } catch (t) {
      return console.error(t), this.fallbackToOnchainFeeEstimation({
        transactions: e,
        account: a,
        isDeploymentTransaction: r,
        feeTokenAddress: o,
        accountDeployTransaction: c
      });
    }
  }
  getCallsFromTx(a) {
    let e;
    return a.calls && (e = v(a.calls)), e;
  }
  async fallbackToOnchainFeeEstimation({ transactions: a, account: e, isDeploymentTransaction: o, feeTokenAddress: n, accountDeployTransaction: c }) {
    try {
      const s = o ? this.getCallsFromTx(a[1]) : this.getCallsFromTx(a[0]);
      if (!s)
        throw new d({
          code: "NO_CALLS_FOUND"
        });
      const r = await this.fetchFeesOnchain({
        starknetAccount: e,
        calls: s,
        isDeployed: !o,
        feeTokenAddress: n,
        accountDeployTransaction: c
      });
      return {
        transactions: [],
        enrichedFeeEstimation: r,
        isBackendDown: !0
      };
    } catch (s) {
      throw console.error(s), new d({
        message: `${s}`,
        code: "SIMULATE_AND_REVIEW_FAILED"
      });
    }
  }
  async fetchFeesOnchain({ starknetAccount: a, calls: e, isDeployed: o, feeTokenAddress: n, accountDeployTransaction: c }) {
    try {
      const s = E(n), r = {
        transactions: {
          feeTokenAddress: n,
          amount: 0n,
          pricePerUnit: 0n,
          dataGasConsumed: 0n,
          dataGasPrice: 0n
        }
      };
      if (!o && c) {
        if ("estimateFeeBulk" in a) {
          const m = [
            {
              type: u.DEPLOY_ACCOUNT,
              payload: {
                classHash: c.classHash,
                addressSalt: c.salt,
                constructorCalldata: c.calldata,
                contractAddress: a.address
              }
            },
            {
              type: u.INVOKE,
              payload: e
            }
          ], [t, i] = await a.estimateFeeBulk(m, {
            version: s
          }).catch((l) => {
            throw console.error(l), l;
          });
          if (!t.gas_consumed || !t.gas_price || !i.gas_consumed || !i.gas_price)
            throw new d({
              code: "ONCHAIN_FEE_ESTIMATION_FAILED",
              message: "Missing gas_consumed or gas_price"
            });
          r.deployment = {
            feeTokenAddress: n,
            amount: t.gas_consumed,
            pricePerUnit: t.gas_price,
            dataGasConsumed: t.data_gas_consumed,
            dataGasPrice: t.data_gas_price
          }, r.transactions = {
            feeTokenAddress: n,
            amount: i.gas_consumed,
            pricePerUnit: i.gas_price,
            dataGasConsumed: i.data_gas_consumed,
            dataGasPrice: i.data_gas_price
          };
        }
      } else {
        const { gas_consumed: m, gas_price: t, data_gas_consumed: i, data_gas_price: l } = await a.estimateFee(e, {
          skipValidate: !0,
          version: s
        });
        if (!m || !t)
          throw new d({
            code: "ONCHAIN_FEE_ESTIMATION_FAILED",
            message: "Missing gas_consumed or gas_price"
          });
        r.transactions = {
          feeTokenAddress: n,
          amount: m,
          pricePerUnit: t,
          dataGasConsumed: i,
          dataGasPrice: l
        };
      }
      return r;
    } catch (s) {
      throw new d({
        code: "ONCHAIN_FEE_ESTIMATION_FAILED",
        message: `${s}`
      });
    }
  }
}
export {
  x as TransactionReviewServiceWeb
};
