import { upperCase as T } from "lodash-es";
import { num as r, CallData as C, uint256 as U } from "starknet";
import { isEqualAddress as I } from "../../chains/starknet/address.js";
import { STRK_TOKEN_ADDRESS as y, ETH_TOKEN_ADDRESS as A } from "../../chains/starknet/constants.js";
import { argentMaxFee as h } from "./argentMaxFee.js";
import { EstimateError as G } from "./error.js";
import { transferCalldataSchema as _ } from "../../utils/starknet/starknet.js";
import { feeEstimationSchema as f } from "../../features/simulation/transactionReview/schema.js";
import { ensureArray as M } from "../../utils/arrays.js";
function E(t) {
  return T(t.unit) === "WEI";
}
function k(t) {
  return T(t.unit) === "FRI";
}
function u(t, n) {
  return E(t) ? {
    ...t,
    maxFee: n(t.maxFee),
    overallFee: n(t.overallFee),
    gasPrice: n(t.gasPrice),
    gasUsage: n(t.gasUsage)
  } : {
    ...t,
    overallFee: n(t.overallFee),
    gasPrice: n(t.gasPrice),
    gasUsage: n(t.gasUsage),
    maxAmount: n(t.maxAmount),
    maxPricePerUnit: n(t.maxPricePerUnit)
  };
}
function d(t) {
  return E(t) ? {
    maxFee: t.maxFee
  } : {
    amount: t.maxAmount,
    pricePerUnit: t.maxPricePerUnit
  };
}
function x(t) {
  return k({ unit: t }) ? y : A;
}
function O(t, n, e = 2) {
  const a = BigInt(10 ** e), s = BigInt(Math.round(n * 10 ** e));
  return t * s / a;
}
const K = [y], F = (t, n = D) => {
  if (t.max && "amount" in t.max)
    return {
      ...t,
      ...t.max
    };
  const e = 10000n, { amount: a, pricePerUnit: s, dataGasConsumed: o = 0n, dataGasPrice: m = 0n } = t, c = a * s + o * m;
  if (c < 0)
    throw Error("Cannot calculate max fee for negative fee");
  const i = r.toBigInt(h({ estimatedFee: c })), g = Number(i) / Number(c), B = n(g), l = BigInt(Math.trunc(B * Number(e)));
  return {
    ...t,
    amount: a * l / e,
    pricePerUnit: s * l / e,
    dataGasConsumed: o * l / e,
    dataGasPrice: m * l / e
  };
}, p = (t) => {
  const { amount: n, pricePerUnit: e, dataGasConsumed: a = 0n, dataGasPrice: s = 0n } = t;
  return n * e + a * s;
}, N = (t) => {
  if (t.max)
    return "maxFee" in t.max ? t.max.maxFee : p(t.max);
}, P = (t) => {
  const n = N(t);
  return n || p(F(t));
}, V = (t) => {
  if (t.deployment && !I(t.deployment.feeTokenAddress, t.transactions.feeTokenAddress))
    throw Error("Cannot calculate estimated fees for different tokens");
  const n = p(t.transactions), e = t.deployment ? p(t.deployment) : 0n;
  return n + e;
}, Y = (t) => {
  if (t.deployment && !I(t.deployment.feeTokenAddress, t.transactions.feeTokenAddress))
    throw Error("Cannot calculate estimated fees for different tokens");
  const n = t.deployment ? P(t.deployment) : 0n, e = P(t.transactions);
  return n + e;
}, $ = (t, n) => [
  {
    contractAddress: t,
    entrypoint: "transfer",
    calldata: C.compile(_.parse({
      // We are using a dummy address (ETH here) as recipient to estimate the fee given we don't have a receipient yet
      recipient: n,
      // We are using the smallest possible amount to make sure this doesn't throw an error
      amount: U.bnToUint256(BigInt(1))
    }))
  }
], S = (t, n) => {
  if (!t)
    return {
      transactions: {
        feeTokenAddress: n ?? A,
        amount: 0n,
        pricePerUnit: 0n,
        dataGasConsumed: 0n,
        dataGasPrice: 0n
      }
    };
  if (!Array.isArray(t))
    throw Error(`Unexpected simulation response. Expected array. Got ${typeof t}`);
  if (t.length === 1) {
    const e = f.parse(t[0].feeEstimation);
    return {
      transactions: {
        feeTokenAddress: x(e.unit),
        amount: r.toBigInt(e.gasUsage),
        pricePerUnit: r.toBigInt(e.gasPrice),
        max: d(u(e, r.toBigInt)),
        dataGasConsumed: e.dataGasConsumed ? r.toBigInt(e.dataGasConsumed) : 0n,
        dataGasPrice: e.dataGasPrice ? r.toBigInt(e.dataGasPrice) : 0n
      }
    };
  }
  if (t.length === 2) {
    const e = f.parse(t[0].feeEstimation), a = f.parse(t[1].feeEstimation);
    return {
      deployment: {
        feeTokenAddress: x(e.unit),
        amount: r.toBigInt(e.gasUsage),
        pricePerUnit: r.toBigInt(e.gasPrice),
        max: d(u(e, r.toBigInt)),
        dataGasConsumed: e.dataGasConsumed ? r.toBigInt(e.dataGasConsumed) : 0n,
        dataGasPrice: e.dataGasPrice ? r.toBigInt(e.dataGasPrice) : 0n
      },
      transactions: {
        feeTokenAddress: x(a.unit),
        amount: r.toBigInt(a.gasUsage),
        pricePerUnit: r.toBigInt(a.gasPrice),
        max: d(u(a, r.toBigInt)),
        dataGasConsumed: a.dataGasConsumed ? r.toBigInt(a.dataGasConsumed) : 0n,
        dataGasPrice: a.dataGasPrice ? r.toBigInt(a.dataGasPrice) : 0n
      }
    };
  }
  throw Error("Unexpected simulation response length");
}, z = ({ transaction: t, nonce: n, chainId: e, version: a, isDeploymentTransaction: s, cairoVersion: o, address: m, appDomain: c }) => {
  let i = n;
  s && t.type !== "DEPLOY_ACCOUNT" && (i = r.toHex(1));
  const g = M(t.calls);
  return {
    type: t.type,
    chainId: e,
    cairoVersion: o,
    nonce: i,
    version: a,
    account: m,
    calls: g,
    calldata: t.calldata,
    salt: t.salt,
    signature: t.signature,
    classHash: t.classHash,
    appDomain: c
    // appDomain: "https://starknetkit-blacked-listed.vercel.app", // to simulate blacklisted domain
  };
}, J = (t, n) => {
  const { transactions: e } = t;
  if (!e)
    throw new G({ code: "SIMULATE_AND_REVIEW_FAILED" });
  const a = e.map((i) => {
    if (!i.simulation)
      throw new G({ code: "SIMULATE_AND_REVIEW_FAILED" });
    return i;
  }), s = a.map((i) => ({
    ...i.simulation,
    feeEstimation: u(i.simulation.feeEstimation, Number)
  })), o = S(s, n), [m, c] = a.length === 1 ? [a[0], void 0] : [a[1], a[0]];
  return {
    ...o,
    transactions: {
      ...o.transactions,
      dataGasConsumed: o.transactions.dataGasConsumed ?? 0n,
      dataGasPrice: o.transactions.dataGasPrice ?? 0n,
      max: d(u(m.simulation.feeEstimation, r.toBigInt))
    },
    deployment: o.deployment && c ? {
      ...o.deployment,
      dataGasConsumed: o.deployment.dataGasConsumed ?? 0n,
      dataGasPrice: o.deployment.dataGasPrice ?? 0n,
      max: d(u(c.simulation.feeEstimation, r.toBigInt))
    } : void 0
  };
}, Q = (t) => {
  const n = F(t), e = P(t);
  return {
    // for v1 transactions
    maxFee: e,
    // for v3 transactions
    resourceBounds: {
      l1_gas: {
        // (overall_fee / gas_price) × gas_safety_margin
        max_amount: r.toHex(e / t.pricePerUnit),
        // max_price_per_unit: gas_price × fee_safety_margin
        max_price_per_unit: r.toHex(n.pricePerUnit)
      },
      l2_gas: {
        max_amount: "0x0",
        max_price_per_unit: "0x0"
      }
    }
  };
}, X = (t) => {
  const n = Math.sqrt(t);
  return isNaN(n) ? Math.sqrt(2) : n;
}, D = (t) => {
  const n = Math.cbrt(t);
  return isNaN(n) ? Math.cbrt(2) : n;
}, Z = (t) => t < 1 || isNaN(t) ? 1.1 : Math.log(t + 1) + 1;
export {
  $ as buildDummyTx,
  D as calculateCubeRootAdjustment,
  Z as calculateNonLinearAdjustment,
  X as calculateSqrtAdjustment,
  u as castFeeEstimation,
  P as estimatedFeeToMaxFeeTotal,
  Q as estimatedFeeToMaxResourceBounds,
  p as estimatedFeeToTotal,
  Y as estimatedFeesToMaxFeeTotal,
  V as estimatedFeesToTotal,
  S as getEstimatedFeeFromBulkSimulation,
  J as getEstimatedFeeFromSimulationAndRespectWatermarkFee,
  z as getPayloadFromTransaction,
  N as getWatermarkedMaxFeeTotal,
  k as isFRI,
  E as isWEI,
  O as multiplyBigIntByFloat,
  d as toMax,
  K as tokensRequireTxV3Support,
  x as unitToFeeTokenAddress
};
