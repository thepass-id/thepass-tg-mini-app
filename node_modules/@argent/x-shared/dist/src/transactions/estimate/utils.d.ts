import { CairoVersion } from 'starknet';
import { Address } from '../../chains/starknet/address';
import { EstimatedFee, EstimatedFees, SimulateAndReview } from '../../features/simulation';
import { ApiTransactionSimulationResponse } from '../transactionSimulationTypes';
import { CastFeeEstimation, FRI, FeeEstimationV1, FeeEstimationV3, TransactionReviewTransactions, WEI } from './model';
export declare function isWEI<T>(value: Pick<CastFeeEstimation<T>, "unit">): value is FeeEstimationV1<T>;
export declare function isFRI<T>(value: Pick<CastFeeEstimation<T>, "unit">): value is FeeEstimationV3<T>;
export declare function castFeeEstimation<S, T extends CastFeeEstimation<S>, C>(feeEstimation: T, cast: (value: S) => C): CastFeeEstimation<C>;
export declare function toMax<S, T extends CastFeeEstimation<S>>(value: T): T["unit"] extends WEI ? {
    maxFee: S;
} : {
    amount: S;
    pricePerUnit: S;
};
export declare function unitToFeeTokenAddress(unit: WEI | FRI): Address;
export declare function multiplyBigIntByFloat(bigintValue: bigint, floatValue: number, precision?: number): bigint;
export declare const tokensRequireTxV3Support: string[];
export type FeeAdjustmentFn = (ratio: number) => number;
export declare const estimatedFeeToTotal: (estimatedFee: Pick<EstimatedFee, "amount" | "pricePerUnit" | "dataGasConsumed" | "dataGasPrice">) => bigint;
export declare const getWatermarkedMaxFeeTotal: (estimatedFee: EstimatedFee) => bigint | undefined;
export declare const estimatedFeeToMaxFeeTotal: (estimatedFee: EstimatedFee) => bigint;
export declare const estimatedFeesToTotal: (estimatedFees: EstimatedFees) => bigint;
export declare const estimatedFeesToMaxFeeTotal: (estimatedFees: EstimatedFees) => bigint;
export declare const buildDummyTx: (tokenAddress: Address, feeTokenAddress: Address) => {
    contractAddress: `0x${string}`;
    entrypoint: string;
    calldata: import('starknet').Calldata;
}[];
export declare const getEstimatedFeeFromBulkSimulation: (simulation: Pick<ApiTransactionSimulationResponse, "feeEstimation">[] | undefined, feeTokenAddress?: Address) => EstimatedFees;
export declare const getPayloadFromTransaction: ({ transaction, nonce, chainId, version, isDeploymentTransaction, cairoVersion, address, appDomain, }: {
    transaction: TransactionReviewTransactions;
    nonce: string;
    chainId: string;
    version: string;
    isDeploymentTransaction: boolean;
    cairoVersion: CairoVersion;
    address: string;
    appDomain?: string;
}) => {
    type: "DECLARE" | "DEPLOY" | "DEPLOY_ACCOUNT" | "INVOKE";
    chainId: string;
    cairoVersion: CairoVersion;
    nonce: string;
    version: string;
    account: string;
    calls: import('starknet').Call[];
    calldata: string[] | undefined;
    salt: `0x${string}` | undefined;
    signature: string[] | undefined;
    classHash: `0x${string}` | undefined;
    appDomain: string | undefined;
};
export declare const getEstimatedFeeFromSimulationAndRespectWatermarkFee: (simulateAndReviewResult: Pick<SimulateAndReview, "transactions">, feeTokenAddress?: Address) => EstimatedFees & {
    transactions: Required<EstimatedFee>;
    deployment?: Required<EstimatedFee>;
};
export declare const estimatedFeeToMaxResourceBounds: (estimatedFee: EstimatedFee) => {
    maxFee: bigint;
    resourceBounds: {
        l1_gas: {
            max_amount: string;
            max_price_per_unit: string;
        };
        l2_gas: {
            max_amount: string;
            max_price_per_unit: string;
        };
    };
};
export declare const calculateSqrtAdjustment: (ratio: number) => number;
export declare const calculateCubeRootAdjustment: (ratio: number) => number;
export declare const calculateNonLinearAdjustment: (ratio: number) => number;
