import n from "../../../../../_virtual/semver.js";
import { ARGENT_ACCOUNT_CONTRACT_CLASS_HASHES as r, ARGENT_MULTISIG_CONTRACT_CLASS_HASHES as a } from "./constants.js";
function u(t) {
  const c = Object.entries(r), s = Object.entries(a);
  switch (t) {
    case "cairo0":
      return c.filter(([e]) => n.lt(e, "0.3.0")).map(([, e]) => e);
    case "cairo1":
      return c.filter(([e]) => n.gte(e, "0.3.0")).map(([, e]) => e);
    case "multisig":
      return s.map(([, e]) => e);
    default:
      return c.map(([, e]) => e);
  }
}
function g() {
  const t = n.maxSatisfying(Object.keys(r), "*");
  if (!t)
    throw new Error(`No argent account contract found: v${t} `);
  return r[t];
}
function f() {
  const t = n.maxSatisfying(Object.keys(a), "*");
  if (!t)
    throw new Error(`No argent multisig contract found: v${t} `);
  return a[t];
}
function l() {
  return Object.entries(r).filter(([t]) => n.gte(t, "0.4.0")).map(([, t]) => t);
}
function A() {
  const t = n.maxSatisfying(Object.keys(r), "<0.3.0");
  if (!t)
    throw new Error(`No argent account contract found: v${t} `);
  return r[t];
}
function m() {
  const t = Object.entries(r).filter(([s]) => n.gte(s, "0.3.1")).map(([, s]) => s), c = Object.entries(a).filter(([s]) => n.gte(s, "0.1.1")).map(([, s]) => s);
  return [...t, ...c];
}
function C() {
  return Object.entries(r).filter(([t]) => n.gte(t, "0.4.0")).map(([, t]) => t);
}
function h() {
  const t = n.maxSatisfying(Object.keys(r), ">=0.4.0");
  if (!t)
    throw new Error(`No ledger account contract found: v${t}`);
  return r[t];
}
export {
  u as getArgentAccountClassHashes,
  m as getArgentAccountClassHashesWithTxV3Support,
  l as getArgentAccountWithMultiSignerClassHashes,
  A as getLastCairo0ArgentAccountClassHash,
  g as getLatestArgentAccountClassHash,
  f as getLatestArgentMultisigClassHash,
  h as getLatestLedgerAccountClassHash,
  C as getLedgerAccountClassHashes
};
