import g from "../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/uniqWith.js";
import { CairoOption as p, CairoOptionVariant as u, CallData as f, hash as h } from "starknet";
import { z as H } from "zod";
import { getSignerForMultiSigner as d, MultiSigner as A } from "../../../../signer/multisigner.js";
import { AccountError as D } from "../../../../errors/account.js";
import { isEqualAddress as l } from "../../address.js";
import { STANDARD_DEVNET_ACCOUNT_CLASS_HASH as y } from "../../constants.js";
import { C0_PROXY_CONTRACT_CLASS_HASHES as _ } from "./constants.js";
import { implementationSchema as C, constructorCallDataSchemaC0 as E, constructorCallDataSchemaC1V1 as I } from "./deploymentData.schema.js";
import { getLatestArgentAccountClassHash as V, getArgentAccountClassHashes as S, getArgentAccountWithMultiSignerClassHashes as N } from "./getAccountClassHash.js";
const O = (o, t) => o.cairoVersion === t.cairoVersion && l(o.accountClassHash, t.accountClassHash);
function v(o, t, a = []) {
  if (t.type === "imported")
    throw new Error("Cannot find implementation for imported account");
  const n = C.parse({
    cairoVersion: t.cairoVersion ?? "1",
    accountClassHash: t.classHash ?? V()
  }), s = H.array(C).parse(a), r = [
    ...S("cairo0").map((e) => ({ cairoVersion: "0", accountClassHash: e })),
    ...S("cairo1").map((e) => ({ cairoVersion: "1", accountClassHash: e }))
  ], c = g([
    n,
    ...s,
    ...r
  ], O).map((e) => ({
    implementation: e,
    address: q(e.cairoVersion, e.accountClassHash, o, t.guardian, t.salt)
  })).find((e) => l(e.address, t.address));
  if (!c)
    throw new D({ code: "CALCULATED_ADDRESS_NO_MATCH" });
  return c.implementation;
}
function T(o, t, a, n, s, r = _[0]) {
  const m = M(o, t, a, n);
  return {
    classHash: o === "0" ? r : t,
    constructorCalldata: f.compile(m),
    addressSalt: s || a
  };
}
function M(o, t, a, n) {
  const s = o !== "0" && l(y, t), r = {
    pubkey: a,
    ...s ? {} : { guardian: n || "0" }
  };
  if (N().some((i) => l(i, t))) {
    const i = d(a, A.Starknet), c = n ? new p(u.Some, d(n, A.Starknet)) : new p(u.None, null);
    return { ownerSigner: i, guardianAsOption: c };
  }
  return o === "0" ? E.parse({
    implementation: t,
    selector: h.getSelectorFromName("initialize"),
    calldata: f.compile(r)
  }) : I.parse({
    owner: a,
    guardian: n
  });
}
function q(o, t, a, n, s) {
  const r = T(o, t, a, n, s);
  return h.calculateContractAddressFromHash(r.addressSalt, r.classHash, r.constructorCalldata, 0);
}
export {
  M as buildConstructorCalldata,
  v as findImplementationForAccount,
  q as getAccountContractAddress,
  T as getAccountDeploymentPayload,
  O as isEqualImplementation
};
