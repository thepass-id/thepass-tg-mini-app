import { starknetId as d } from "starknet";
import { AddressError as s } from "../../errors/address.js";
import { CallError as c } from "../../errors/call.js";
import { NetworkError as l } from "../../errors/network.js";
import { callSchema as A } from "../../utils/starknet/starknet.js";
import { isZeroAddress as N, isValidAddress as p, normalizeAddress as f } from "./address.js";
import { getChainIdFromNetworkId as w } from "./network.js";
function h(t) {
  return t.replace(".stark", "").split(".").map((n) => d.useEncoded(n).toString(10));
}
function I(t) {
  const r = w(t);
  return d.getStarknetIdContract(r);
}
function S(t, r) {
  const e = I(r), n = h(t);
  try {
    const o = { domain: n, hint: [] };
    return A.parse({
      contractAddress: e,
      entrypoint: "domain_to_address",
      calldata: o
    });
  } catch (a) {
    throw new c({
      code: "NOT_VALID",
      options: { error: a }
    });
  }
}
async function g(t, r, e) {
  if (!r || !e)
    throw new l({
      code: "NO_NETWORK_OR_MULTICALL"
    });
  let n = null;
  try {
    n = S(t, r);
  } catch (m) {
    throw new c({
      code: "NOT_VALID",
      options: { error: m }
    });
  }
  let a, o;
  try {
    a = await e.callContract(n), o = a[0];
  } catch {
    throw new s({
      code: "STARKNAME_ERROR"
    });
  }
  if (N(o))
    throw new s({
      code: "STARKNAME_NOT_FOUND",
      message: `${t} not found`
    });
  if (!p(o))
    throw new s({
      code: "STARKNAME_INVALID_ADDRESS",
      message: `${t} resolved to an invalid address (${o})`
    });
  return f(o);
}
export {
  g as getAddressFromStarkName,
  S as getCallFromStarkName,
  I as getStarknetIdContractAddressFromNetworkId,
  h as starkNameToCallDataDomain
};
