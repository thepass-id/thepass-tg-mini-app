"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const c=require("starknet"),n=require("../../errors/address.cjs"),i=require("../../errors/call.cjs"),u=require("../../errors/network.cjs"),w=require("../../utils/starknet/starknet.cjs"),d=require("./address.cjs"),S=require("./network.cjs");function l(r){return r.replace(".stark","").split(".").map(s=>c.starknetId.useEncoded(s).toString(10))}function m(r){const t=S.getChainIdFromNetworkId(r);return c.starknetId.getStarknetIdContract(t)}function A(r,t){const o=m(t),s=l(r);try{const e={domain:s,hint:[]};return w.callSchema.parse({contractAddress:o,entrypoint:"domain_to_address",calldata:e})}catch(a){throw new i.CallError({code:"NOT_VALID",options:{error:a}})}}async function I(r,t,o){if(!t||!o)throw new u.NetworkError({code:"NO_NETWORK_OR_MULTICALL"});let s=null;try{s=A(r,t)}catch(N){throw new i.CallError({code:"NOT_VALID",options:{error:N}})}let a,e;try{a=await o.callContract(s),e=a[0]}catch{throw new n.AddressError({code:"STARKNAME_ERROR"})}if(d.isZeroAddress(e))throw new n.AddressError({code:"STARKNAME_NOT_FOUND",message:`${r} not found`});if(!d.isValidAddress(e))throw new n.AddressError({code:"STARKNAME_INVALID_ADDRESS",message:`${r} resolved to an invalid address (${e})`});return d.normalizeAddress(e)}exports.getAddressFromStarkName=I;exports.getCallFromStarkName=A;exports.getStarknetIdContractAddressFromNetworkId=m;exports.starkNameToCallDataDomain=l;
