import { memoize as a } from "lodash-es";
import { validateChecksumAddress as l, validateAndParseAddress as u, getChecksumAddress as f, num as c, constants as h } from "starknet";
import { z as d } from "zod";
import { decodeBase58 as A } from "../../utils/base58.js";
const p = d.string().refine((e) => {
  if (e.toLowerCase() === e)
    return !0;
  try {
    return l(e) && $(e);
  } catch {
  }
  return !1;
}, "Invalid address (checksum error)"), z = d.string().refine((e) => {
  try {
    return u(e);
  } catch {
  }
  return !1;
}, "Invalid address (validation error)"), o = d.string().regex(/^0x[0-9a-fA-F]+$/, "Invalid address"), x = o.min(50, "Addresses must at least be 50 characters long").max(66, "Addresses must at most be 66 characters long"), T = o.length(66, "Address must be 66 characters long"), i = x.pipe(p).transform((e) => `0x${(e.startsWith("0x") ? e.slice(2) : e).padStart(64, "0")}`), E = i.or(d.literal("")).transform((e) => e === "" ? void 0 : e).optional(), I = o.transform((e) => `0x${e.replace(/^0x/, "").toLowerCase().padStart(64, "0")}`), S = (e) => i.safeParse(e).success, g = S, m = (e) => f(e), Z = (e) => {
  if (!e)
    return !1;
  try {
    const s = A(e);
    return g(s);
  } catch {
    return !1;
  }
}, v = (e) => {
  const s = m(e), r = s.slice(0, 2), n = s.slice(2, 6), t = s.slice(-4);
  return `${r}${n}…${t}`;
}, b = (e) => {
  const s = m(e), r = s.slice(0, 2), t = s.slice(2).match(/.{1,4}/g) || [];
  return `${r} ${t.join(" ")}`;
}, $ = (e) => !/^0x[0-9a-f]{63,64}$/.test(e), w = (e, s) => {
  try {
    return !e || !s ? !1 : c.hexToDecimalString(e) === c.hexToDecimalString(s);
  } catch {
  }
  return !1;
}, k = (e) => {
  try {
    return c.toBigInt(o.parse(e)) === h.ZERO;
  } catch {
  }
  return !1;
}, y = (e, s) => !!(s != null && s.some((r) => w(r, e))), D = a((e) => {
  const s = e.slice(0, 6), r = e.slice(-4);
  return `${s}…${r}`;
}), F = a((e, s) => {
  if (e.length < s)
    return e;
  const r = Math.floor((s - 1) / 2), n = e.slice(0, r), t = e.slice(-r);
  return `${n}…${t}`;
});
export {
  E as addressOrEmptyUndefinedSchema,
  i as addressSchema,
  I as addressSchemaArgentBackend,
  o as addressSchemaBase,
  x as addressSchemaLooseLength,
  T as addressSchemaStrictLength,
  b as formatFullAddress,
  v as formatTruncatedAddress,
  D as formatTruncatedSignerKey,
  F as formatTruncatedString,
  y as includesAddress,
  S as isAddress,
  Z as isBase58Address,
  w as isEqualAddress,
  g as isValidAddress,
  k as isZeroAddress,
  m as normalizeAddress,
  p as validChecksumAddressSchema,
  z as validateAddressRangeSchema
};
