import o from "url-join";
import { retryUntilInitialised as c } from "../../utils/retryUntilInitialised.js";
import { apiTokensInfoResponseSchema as r, apiTokenInfoResponseSchema as p, apiAccountTokenBalancesSchema as h, apiDefiPositionsSchema as d } from "./types/backend.model.js";
import { safeParseAndWarn as k } from "../../utils/schemas.js";
class v {
  constructor(t, e) {
    this.apiBase = t, this.httpService = e, this.TOKENS_INFO_URL = "/tokens/info";
  }
  /**
   * Fetch tokens info from backend
   * @param {Address} tokenAddress - The token address.
   * @returns {Promise<ApiTokenInfo[]>} - The fetched tokens or undefined if there was an error or not default network
   */
  async fetchTokensInfoFromBackend(t) {
    const e = o(this.apiBase, this.TOKENS_INFO_URL, t ?? "", "?chain=starknet"), a = await this.httpService.get(e), n = r.safeParse(a);
    if (n.success)
      return n.data.tokens;
    const s = p.safeParse(a);
    if (s.success)
      return [s.data];
  }
  /**
   * Fetch list of tokens and balances for given account from backend
   * @param {Address} address - The account address.
   * @returns {Promise<WebBaseTokenWithBalance[]>} - The fetched balances for the account address.
   */
  async fetchAddressTokenBalancesFromBackend(t, e, a) {
    const n = o(this.apiBase, "activity", "starknet", e, "account", t, "balance"), s = await c(() => this.httpService.get(n), h, a);
    return ((s == null ? void 0 : s.status) === "initialised" ? s.balances : []).map((i) => ({
      address: i.tokenAddress,
      balance: i.tokenBalance,
      networkId: e
    }));
  }
  async fetchDefiDecomposition(t, e) {
    const a = o(this.apiBase, "tokens/defi", t, "investments", "?chain=starknet", `&application=${e}`), n = await this.httpService.get(a);
    return k(d, n).success || console.error("Backend schema has changed. Make the changes to the models to prevent unknown/unhandled errors."), n.dapps;
  }
}
export {
  v as TokenServiceWeb
};
