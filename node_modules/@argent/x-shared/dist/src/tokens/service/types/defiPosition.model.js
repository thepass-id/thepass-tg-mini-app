import { z as t } from "zod";
import { addressSchema as o } from "../../../chains/starknet/address.js";
import { apiTokenInfoSchema as p, apiStrkDelegatedStakingSchema as g } from "./backend.model.js";
import { defiPositionTypeSchema as m } from "./defiPositionType.model.js";
import { webTokenWithBalanceAndPriceSchema as e } from "./webToken.model.js";
const i = e.extend({
  accruedFees: t.string(),
  currentPrice: t.string(),
  maxPrice: t.string(),
  minPrice: t.string(),
  principal: t.string()
}), n = t.object({
  address: o.optional(),
  currencyValue: t.string().default("0")
}), r = n.extend({
  poolFeePercentage: t.string(),
  tickSpacingPercentage: t.string().optional(),
  tokenId: t.string().optional(),
  unitCurrencyValueToken0: t.string().optional(),
  unitCurrencyValueToken1: t.string().optional(),
  token0: i,
  token1: i
}), T = t.array(r), x = t.object({
  name: t.string().optional(),
  healthRatio: t.string().optional(),
  accountAddress: o.optional()
}), s = n.extend({
  totalBalances: t.record(t.string()),
  collateral: t.boolean(),
  debt: t.boolean(),
  lending: t.boolean(),
  apy: t.string().optional(),
  totalApy: t.string().optional(),
  group: t.string().optional(),
  unitCurrencyValue: t.string().optional(),
  positionToken: p.or(t.undefined()),
  token: e.optional(),
  accountAddress: o.optional(),
  accountAddressGroup: t.string().optional()
}), D = t.array(s), c = n.extend({
  delegatingTo: o,
  token: e.optional(),
  balance: t.string(),
  unitCurrencyValue: t.string().optional().default("0")
}), j = t.array(c), a = t.object({
  wei: t.string(),
  eth: t.string(),
  currency: t.string()
}), l = n.extend({
  id: t.string(),
  total: a,
  apy: t.number(),
  totalApy: t.number(),
  token: e
}), V = t.array(l), d = n.extend({
  id: t.string(),
  accruedRewards: a,
  stakedAmount: a,
  total: a,
  apy: t.number(),
  totalApy: t.number(),
  stakerInfo: g.shape.data.shape.stakerInfo,
  token: e
}), C = t.array(d), u = r.or(s).or(c).or(d).or(l), h = t.record(t.object({
  name: t.string().optional(),
  healthRatio: t.string().optional(),
  accountAddress: o.optional()
})), S = t.object({
  type: m,
  manageUrl: t.string().url().optional(),
  name: t.string(),
  positions: t.array(u),
  // other types will be added when available from be
  positionsTotalValue: t.string(),
  brandColor: t.string().optional(),
  groups: h.optional(),
  accountAddress: o
}), k = t.array(S), I = t.object({
  dappId: t.string(),
  products: k
});
export {
  x as collateralizedDebtGroupSchema,
  s as collateralizedDebtPositionSchema,
  D as collateralizedDebtPositionsSchema,
  r as concentratedLiquidityPositionSchema,
  T as concentratedLiquidityPositionsSchema,
  I as defiDappsProductsSchema,
  u as defiPositionSchema,
  S as defiProductSchema,
  k as defiProductsSchema,
  j as delegatedTokensArraySchema,
  c as delegatedTokensSchema,
  h as productGroupsSchema,
  l as stakingPositionSchema,
  V as stakingPositionsSchema,
  C as strkDelegatedStakingPositionArraySchema,
  d as strkDelegatedStakingPositionSchema
};
