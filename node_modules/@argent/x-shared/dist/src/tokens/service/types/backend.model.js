import { z as t } from "zod";
import { addressSchema as a, addressSchemaArgentBackend as n } from "../../../chains/starknet/address.js";
import { defiPositionTypeSchema as d } from "./defiPositionType.model.js";
import { createSchemaWithWarnings as g } from "../../../utils/schemas.js";
const f = t.object({
  status: t.literal("initialising")
}).or(t.object({
  status: t.literal("initialised"),
  balances: t.array(t.object({
    tokenAddress: n,
    tokenBalance: t.string()
  }))
})), i = t.object({
  id: t.number(),
  address: a,
  brandColor: t.string().optional(),
  name: t.string(),
  symbol: t.string(),
  decimals: t.number(),
  iconUrl: t.string().optional(),
  sendable: t.boolean(),
  popular: t.boolean(),
  refundable: t.boolean(),
  listed: t.boolean(),
  tradable: t.boolean(),
  category: t.union([
    t.literal("tokens"),
    t.literal("currencies"),
    t.literal("savings")
  ]),
  pricingId: t.number().optional(),
  dappId: t.string().optional(),
  marketData: t.object({
    marketCap: t.number(),
    marketCap24hChange: t.number(),
    dailyVolume: t.number(),
    rank: t.number()
  }).optional(),
  tags: t.array(t.string()).optional()
}), A = t.object({
  tokens: t.array(i)
}), I = i, m = t.object({
  pricingId: t.number(),
  ethValue: t.string(),
  ccyValue: t.string(),
  ethDayChange: t.string(),
  ccyDayChange: t.string()
}), C = t.object({
  prices: t.array(m)
}), o = t.object({
  tokenAddress: n,
  principal: t.string(),
  accruedFees: t.string(),
  minPrice: t.string(),
  maxPrice: t.string(),
  currentPrice: t.string()
}), e = t.object({
  id: t.string(),
  investmentId: t.string().optional(),
  tokenAddress: a.optional(),
  totalBalances: t.record(t.string())
}), r = e.extend({
  tokenId: t.string(),
  data: t.object({
    poolFeePercentage: t.string(),
    tickSpacingPercentage: t.string().optional(),
    token0: o,
    token1: o
  })
}), T = t.array(r), s = e.extend({
  data: t.object({
    apy: t.string(),
    totalApy: t.string()
  }),
  investmentId: t.string().optional(),
  totalBalances: t.record(t.string())
}), x = t.array(s), c = e.extend({
  data: t.object({
    apy: t.string().optional(),
    totalApy: t.string().optional(),
    group: t.number().optional(),
    collateral: t.boolean(),
    debt: t.boolean(),
    lending: t.boolean()
  })
}), B = t.array(c), l = e.extend({
  id: t.string(),
  data: t.object({
    delegatingTo: a
  }),
  totalBalances: t.record(t.string())
}), R = t.array(l), p = e.extend({
  investmentId: t.string().optional(),
  data: t.object({
    stakerInfo: t.object({
      name: t.string().optional(),
      iconUrl: t.string().optional(),
      address: a
    }),
    accruedRewards: t.string(),
    stakedAmount: t.string(),
    pendingWithdrawal: t.object({
      amount: t.string(),
      withdrawableAfter: t.number()
    }).optional(),
    apy: t.string().optional(),
    totalApy: t.string().optional()
  })
}), w = t.array(p), b = r.or(c).or(l).or(s).or(p), h = t.array(b), u = g({
  productId: t.string().optional(),
  name: t.string(),
  manageUrl: t.string().optional(),
  type: d,
  groups: t.record(t.object({
    name: t.string().optional(),
    healthRatio: t.string().optional()
  })).optional(),
  positions: h
}), S = t.object({
  dappId: t.string(),
  products: t.array(u)
}), U = t.object({
  dapps: t.array(S)
}), k = t.object({
  name: t.string().optional(),
  tokenAddress: a,
  amount: t.string().optional(),
  claimUrl: t.string().optional(),
  claimStart: t.number(),
  claimEnd: t.number().optional()
}), v = t.object({
  accountAddress: a,
  chain: t.string(),
  airdrops: t.array(k)
});
export {
  f as apiAccountTokenBalancesSchema,
  k as apiAirdropSchema,
  c as apiCollateralizedDebtPositionSchema,
  B as apiCollateralizedDebtPositionsSchema,
  r as apiConcentratedLiquidityPositionSchema,
  T as apiConcentratedLiquidityPositionsSchema,
  u as apiDefiDecompositionProduct,
  h as apiDefiDecompositionProducts,
  S as apiDefiDecompositionSchema,
  o as apiDefiDecompositionToken,
  b as apiDefiPositionSchema,
  U as apiDefiPositionsSchema,
  R as apiDelegatedTokensArraySchema,
  l as apiDelegatedTokensSchema,
  C as apiPriceDataResponseSchema,
  m as apiPriceDetailsSchema,
  s as apiStakingPositionSchema,
  x as apiStakingPositionsSchema,
  w as apiStrkDelegatedStakingPositionsSchema,
  p as apiStrkDelegatedStakingSchema,
  I as apiTokenInfoResponseSchema,
  i as apiTokenInfoSchema,
  A as apiTokensInfoResponseSchema,
  v as apiUnclaimedRewardsSchema
};
