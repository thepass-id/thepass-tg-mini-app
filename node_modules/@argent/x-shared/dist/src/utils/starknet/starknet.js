import { z as a } from "zod";
import { addressSchema as c } from "../../chains/starknet/address.js";
const n = a.union([a.string(), a.number(), a.bigint()]), l = a.object({
  low: n,
  high: n
}), s = a.array(a.string()).and(a.object({
  __compiled__: a.boolean().optional()
}).optional()), i = a.lazy(() => a.array(a.union([o, a.array(o), r]))), o = a.union([
  n,
  l,
  a.any(),
  a.boolean()
]), m = a.lazy(() => a.record(a.union([o, a.array(o), r]))), r = a.lazy(() => a.union([m, i])), h = a.union([r, s]).optional(), d = a.lazy(() => a.object({
  contractAddress: a.string(),
  calldata: h,
  entrypoint: a.string().optional()
})), g = a.lazy(() => d.and(a.object({
  entrypoint: a.string()
}))), e = a.string().refine((t) => typeof parseInt(t) == "number"), S = a.tuple([e]), b = a.tuple([e]), y = a.object({
  new_threshold: a.string().refine((t) => typeof parseInt(t) == "number"),
  signers_to_add: a.array(e)
}), _ = a.object({
  new_threshold: a.string().refine((t) => typeof parseInt(t) == "number"),
  signers_to_remove: a.array(e)
}), C = a.object({
  signer_to_remove: e,
  signer_to_add: e
}), f = a.tuple([e]), j = a.tuple([e]), w = a.tuple([e]), z = a.tuple([e]).rest(e), A = a.object({
  recipient: c,
  amount: a.object({
    low: n,
    high: n
  })
});
export {
  y as addOwnersCalldataSchema,
  j as addPluginCalldataSchema,
  n as bigNumberishSchema,
  d as callDetailsSchema,
  g as callSchema,
  s as calldataSchema,
  S as changeGuardianCalldataSchema,
  f as changeThresholdCalldataSchema,
  b as escapeGuardianCalldataSchema,
  z as executeOnPluginCalldataSchema,
  e as feltSchema,
  h as looseCalldataSchema,
  o as multiTypeSchema,
  i as rawArgsArraySchema,
  m as rawArgsObjectSchema,
  r as rawArgsSchema,
  _ as removeOwnersCalldataSchema,
  w as removePluginCalldataSchema,
  C as replaceSignerCalldataSchema,
  A as transferCalldataSchema,
  l as uint256Schema
};
