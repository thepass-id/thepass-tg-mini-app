import { z as t } from "zod";
import { FunctionAbiType as m } from "./starknetLibTypes.js";
const i = t.array(t.string()), e = t.object({
  selector: t.string(),
  offset: t.string(),
  builtins: i.optional()
}), o = t.object({
  CONSTRUCTOR: t.array(e),
  EXTERNAL: t.array(e),
  L1_HANDLER: t.array(e)
}), A = t.string(), y = t.object({
  builtins: i,
  data: t.array(t.string())
}), a = t.object({
  name: t.string(),
  type: t.union([t.literal("felt"), t.literal("felt*"), t.string()])
}), l = t.nativeEnum(m), b = t.object({
  inputs: t.array(a),
  name: t.string(),
  outputs: t.array(a),
  stateMutability: t.literal("view").optional(),
  state_mutability: t.string().optional(),
  type: l
}), n = t.object({
  name: t.string(),
  type: t.union([t.literal("felt"), t.literal("felt*"), t.string()]),
  kind: t.union([t.literal("key"), t.literal("data")])
}), p = t.object({
  name: t.string(),
  type: t.literal("event"),
  data: t.array(n),
  keys: t.array(n)
}), u = t.object({
  name: t.string(),
  members: t.array(n),
  kind: t.literal("struct"),
  type: t.literal("event")
}), g = t.object({
  members: t.array(a.and(t.object({
    offset: t.number()
  }))),
  name: t.string(),
  size: t.number(),
  type: t.literal("struct")
}), h = t.union([u, p]), s = t.array(t.union([b, h, g, t.any()])), S = t.object({
  program: y,
  entry_points_by_type: o,
  abi: s
}), c = t.array(t.string()), _ = t.object({
  type_names: t.array(t.tuple([t.number(), t.string()])),
  libfunc_names: t.array(t.tuple([t.number(), t.string()])),
  user_func_names: t.array(t.tuple([t.number(), t.string()]))
}), r = t.object({
  selector: t.string(),
  function_idx: t.number()
}), f = t.object({
  CONSTRUCTOR: t.array(r),
  EXTERNAL: t.array(r),
  L1_HANDLER: t.array(r)
}), d = t.object({
  sierra_program: c,
  sierra_program_debug_info: _.optional(),
  contract_class_version: t.string(),
  entry_points_by_type: f,
  abi: s
}), j = t.array(t.tuple([t.number(), t.array(t.string())])), E = t.object({
  prime: t.string(),
  compiler_version: t.string(),
  bytecode: c,
  hints: t.array(t.any()),
  pythonic_hints: j,
  entry_points_by_type: o
}), T = E, R = t.union([
  S,
  d
]);
export {
  a as abiEntrySchema,
  s as abiSchema,
  i as builtinsSchema,
  c as byteCodeSchema,
  u as cairo1EventSchema,
  E as cairoAssemblySchema,
  R as compiledContractClassSchema,
  T as compiledSierraCasmSchema,
  d as compiledSierraSchema,
  A as compressedProgramSchema,
  e as contractEntryPointFieldsSchema,
  o as entryPointsByTypeSchema,
  h as eventAbiSchema,
  n as eventEntrySchema,
  b as functionAbiSchema,
  l as functionAbiTypeSchema,
  S as legacyContractClassSchema,
  p as legacyEventSchema,
  y as programSchema,
  j as pythonicHintsSchema,
  r as sierraContractEntryPointFieldsSchema,
  f as sierraEntryPointsByTypeSchema,
  _ as sierraProgramDebugInfoSchema,
  g as structAbiSchema
};
