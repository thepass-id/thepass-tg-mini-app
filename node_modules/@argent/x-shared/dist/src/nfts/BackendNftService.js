import n from "url-join";
import { BackendPaginationError as f } from "./BackendPaginationError.js";
import { addressSchema as P, addressSchemaArgentBackend as S } from "../chains/starknet/address.js";
import { formatAddress as b } from "../utils/address.js";
const A = 32;
class k {
  constructor(e, t) {
    this.apiBase = e, this.httpService = t;
  }
  async getNfts(e, t, a, s = 1) {
    const o = this.normalizeAddress(a), c = n(this.apiBase, "pandora", e, t), m = this.pageToPageIndex(s), l = `${n(c, "profile", o, "nfts")}?page=${m}&size=${A}`, i = await this.httpService.get(l), r = i.content.map((p) => this.mapItem(p, a));
    return {
      totalPages: i.totalPages,
      page: i.number + 1,
      count: r.length,
      nfts: r
    };
  }
  async getCollection(e, t, a) {
    const s = this.normalizeAddress(a), o = n(this.apiBase, "pandora", e, t), c = n(o, "collection", s), m = `${o}/collection/${s}`, [g, l] = await Promise.all([
      this.httpService.get(c),
      this.httpService.get(m)
    ]), i = h(g), r = l.content.map((p) => this.mapItem(p));
    return {
      ...i,
      nfts: {
        totalPages: l.totalPages,
        page: l.number,
        count: r.length,
        data: r
      }
    };
  }
  async getNft(e, t, a, s) {
    const o = this.normalizeAddress(a), c = n(this.apiBase, "pandora", e, t), m = n(c, "nft", o, s), g = await this.httpService.get(m);
    return this.mapItem(g);
  }
  async getProfileCollections(e, t, a, s = 1, o = !1) {
    const c = this.pageToPageIndex(s), m = this.normalizeAddress(a), g = n(this.apiBase, "pandora", e, t), l = n(g, "profile", m, "collections", `?page=${c}&size=${A}`), i = await this.httpService.get(l), r = [];
    for (const p of i.content)
      if (o) {
        const u = await this.getCollectionMetrics(e, t, p.contractAddress);
        r.push(h(p, u));
      } else
        r.push(h(p));
    return {
      totalPages: i.totalPages,
      page: i.number + 1,
      count: r.length,
      collections: r
    };
  }
  async getCollectionMetrics(e, t, a) {
    const s = this.normalizeAddress(a), o = n(this.apiBase, "pandora", e, t), c = n(o, "collection", s, "metrics");
    return this.httpService.get(c);
  }
  normalizeAddress(e) {
    return S.parse(e);
  }
  pageToPageIndex(e) {
    if (!Number.isInteger(e))
      throw new f("notANumber");
    const t = e - 1;
    if (t < 0)
      throw new f("tooLow");
    return t;
  }
  mapItem(e, t) {
    var s;
    const a = e.name ?? e.tokenId;
    return {
      token_id: e.tokenId,
      contract_address: e.contractAddress,
      name: a,
      spec: "spec" in e ? w(e.spec) : void 0,
      description: "",
      best_bid_order: {
        payment_amount: "bestListPrice" in e ? BigInt(e.bestListPrice) : void 0
      },
      properties: "properties" in e && e.properties.map((o) => ({ key: o.key, value: o.value })) || [],
      image_uri: e.imageUrls.preview,
      image_url_copy: e.imageUrls.full,
      owner: {
        account_address: ((s = e.owner) == null ? void 0 : s.address) || t
      },
      contract_name: b(e.contractAddress)
    };
  }
}
function w(d) {
  switch (d) {
    case "erc721":
    case "starknetErc721":
      return "ERC721";
    case "erc1155":
    case "starknetErc1155":
      return "ERC1155";
  }
}
function h(d, e) {
  return {
    contractAddress: P.parse(d.contractAddress),
    name: d.name || b(d.contractAddress),
    description: d.description ?? "",
    imageUri: d.imageUrls.preview,
    ...e && {
      owners: {
        total: e.numberOfItems,
        unique: e.uniqueOwners
      },
      ...e.floorPrice && {
        floorPrice: BigInt(e.floorPrice)
      }
    }
  };
}
export {
  k as BackendNftService
};
