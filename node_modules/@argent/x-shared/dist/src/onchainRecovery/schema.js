import { z as e } from "zod";
import { addressSchema as a } from "../chains/starknet/address.js";
import { hexSchema as r } from "../utils/hex.js";
var c;
(function(o) {
  o.NOT_STARTED = "NOT_STARTED", o.ONGOING = "ONGOING", o.AWAITING_FUNDS = "AWAITING_FUNDS", o.AWAITING_COMPLETION = "AWAITING_COMPLETION", o.COMPLETED = "COMPLETED", o.CANCELLED = "CANCELLED", o.ERROR = "ERROR";
})(c || (c = {}));
const T = e.object({
  recoveryId: e.number()
}), N = e.object({
  feeToken: a,
  signerSignature: e.object({
    type: e.literal("StarknetKey"),
    signer: e.object({
      publicKey: r,
      r,
      s: r
    })
  })
}), i = e.nativeEnum(c), t = e.object({
  recoveryId: e.number(),
  status: i,
  completionTime: e.array(e.number()).optional()
}), A = e.object({
  activeRecovery: t.optional().or(e.null()).optional(),
  minFees: e.record(e.number()).optional()
}), l = e.object({
  recovery: t.optional().or(e.null()).optional(),
  minFees: e.record(e.number()).optional()
});
var n;
(function(o) {
  o.UNDEPLOYED_ACCOUNT = "undeployedAccount", o.NOT_ENOUGH_TO_PAY_FEES = "notEnoughToPayFees", o.RECOVERY_ALREADY_EXISTS = "recoveryAlreadyExists";
})(n || (n = {}));
const O = e.nativeEnum(n), h = e.object({
  status: O
});
export {
  c as RecoveryStatusEnum,
  n as StartOnchainRecoveryErrorStatusEnum,
  A as activeOnchainRecoverySchema,
  l as onchainRecoverySchema,
  t as recoveryBaseSchema,
  N as recoveryBodySchema,
  i as recoveryStatusSchema,
  h as startOnchainRecoveryErrorSchema,
  O as startOnchainRecoveryErrorStatusSchema,
  T as startOnchainRecoverySchema
};
