import { validateField as c, FpPow as y } from "./modular.js";
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function b(r) {
  const { Fp: e } = r;
  c(e);
  for (const n of ["t", "roundsFull", "roundsPartial"])
    if (typeof r[n] != "number" || !Number.isSafeInteger(r[n]))
      throw new Error(`Poseidon: invalid param ${n}=${r[n]} (${typeof r[n]})`);
  if (r.reversePartialPowIdx !== void 0 && typeof r.reversePartialPowIdx != "boolean")
    throw new Error(`Poseidon: invalid param reversePartialPowIdx=${r.reversePartialPowIdx}`);
  let t = r.sboxPower;
  if (t === void 0 && (t = 5), typeof t != "number" || !Number.isSafeInteger(t))
    throw new Error(`Poseidon wrong sboxPower=${t}`);
  const u = BigInt(t);
  let f = (n) => y(e, n, u);
  if (t === 3 ? f = (n) => e.mul(e.sqrN(n), n) : t === 5 && (f = (n) => e.mul(e.sqrN(e.sqrN(n)), n)), r.roundsFull % 2 !== 0)
    throw new Error(`Poseidon roundsFull is not even: ${r.roundsFull}`);
  const w = r.roundsFull + r.roundsPartial;
  if (!Array.isArray(r.roundConstants) || r.roundConstants.length !== w)
    throw new Error("Poseidon: wrong round constants");
  const l = r.roundConstants.map((n) => {
    if (!Array.isArray(n) || n.length !== r.t)
      throw new Error(`Poseidon wrong round constants: ${n}`);
    return n.map((d) => {
      if (typeof d != "bigint" || !e.isValid(d))
        throw new Error(`Poseidon wrong round constant=${d}`);
      return e.create(d);
    });
  });
  if (!Array.isArray(r.mds) || r.mds.length !== r.t)
    throw new Error("Poseidon: wrong MDS matrix");
  const P = r.mds.map((n) => {
    if (!Array.isArray(n) || n.length !== r.t)
      throw new Error(`Poseidon MDS matrix row: ${n}`);
    return n.map((d) => {
      if (typeof d != "bigint")
        throw new Error(`Poseidon MDS matrix value=${d}`);
      return e.create(d);
    });
  });
  return Object.freeze({ ...r, rounds: w, sboxFn: f, roundConstants: l, mds: P });
}
function $(r) {
  const { t: e, Fp: t, rounds: u, sboxFn: f, reversePartialPowIdx: w } = b(r), l = Math.floor(r.roundsFull / 2), P = w ? e - 1 : 0, n = (a, i, s) => (a = a.map((o, m) => t.add(o, r.roundConstants[s][m])), i ? a = a.map((o) => f(o)) : a[P] = f(a[P]), a = r.mds.map((o) => o.reduce((m, h, g) => t.add(m, t.mulN(h, a[g])), t.ZERO)), a), d = function(i) {
    if (!Array.isArray(i) || i.length !== e)
      throw new Error(`Poseidon: wrong values (expected array of bigints with length ${e})`);
    i = i.map((o) => {
      if (typeof o != "bigint")
        throw new Error(`Poseidon: wrong value=${o} (${typeof o})`);
      return t.create(o);
    });
    let s = 0;
    for (let o = 0; o < l; o++)
      i = n(i, !0, s++);
    for (let o = 0; o < r.roundsPartial; o++)
      i = n(i, !1, s++);
    for (let o = 0; o < l; o++)
      i = n(i, !0, s++);
    if (s !== u)
      throw new Error(`Poseidon: wrong number of rounds: last round=${s}, total=${u}`);
    return i;
  };
  return d.roundConstants = r.roundConstants, d;
}
export {
  $ as poseidon,
  b as validateOpts
};
