import { validateObject as L, ensureBytes as T, bytesToNumberLE as y, bytesToNumberBE as m, numberToBytesBE as _, bitMask as $, numberToBytesLE as C } from "./utils.js";
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const f = BigInt(0), u = BigInt(1), w = BigInt(2), M = BigInt(3), E = BigInt(4), b = BigInt(5), I = BigInt(8);
BigInt(9);
BigInt(16);
function g(e, o) {
  const n = e % o;
  return n >= f ? n : o + n;
}
function Z(e, o, n) {
  if (n <= f || o < f)
    throw new Error("Expected power/modulo > 0");
  if (n === u)
    return f;
  let r = u;
  for (; o > f; )
    o & u && (r = r * e % n), e = e * e % n, o >>= u;
  return r;
}
function S(e, o) {
  if (e === f || o <= f)
    throw new Error(`invert: expected positive integers, got n=${e} mod=${o}`);
  let n = g(e, o), r = o, s = f, c = u;
  for (; n !== f; ) {
    const i = r / n, t = r % n, l = s - c * i;
    r = n, n = t, s = c, c = l;
  }
  if (r !== u)
    throw new Error("invert: does not exist");
  return g(s, o);
}
function j(e) {
  const o = (e - u) / w;
  let n, r, s;
  for (n = e - u, r = 0; n % w === f; n /= w, r++)
    ;
  for (s = w; s < e && Z(s, o, e) !== e - u; s++)
    ;
  if (r === 1) {
    const d = (e + u) / E;
    return function(t, l) {
      const a = t.pow(l, d);
      if (!t.eql(t.sqr(a), l))
        throw new Error("Cannot find square root");
      return a;
    };
  }
  const c = (n + u) / w;
  return function(i, t) {
    if (i.pow(t, o) === i.neg(i.ONE))
      throw new Error("Cannot find square root");
    let l = r, a = i.pow(i.mul(i.ONE, s), n), B = i.pow(t, c), h = i.pow(t, n);
    for (; !i.eql(h, i.ONE); ) {
      if (i.eql(h, i.ZERO))
        return i.ZERO;
      let q = 1;
      for (let v = i.sqr(h); q < l && !i.eql(v, i.ONE); q++)
        v = i.sqr(v);
      const N = i.pow(a, u << BigInt(l - q - 1));
      a = i.sqr(N), B = i.mul(B, N), h = i.mul(h, a), l = q;
    }
    return B;
  };
}
function k(e) {
  if (e % E === M) {
    const o = (e + u) / E;
    return function(r, s) {
      const c = r.pow(s, o);
      if (!r.eql(r.sqr(c), s))
        throw new Error("Cannot find square root");
      return c;
    };
  }
  if (e % I === b) {
    const o = (e - b) / I;
    return function(r, s) {
      const c = r.mul(s, w), d = r.pow(c, o), i = r.mul(s, d), t = r.mul(r.mul(i, w), d), l = r.mul(i, r.sub(t, r.ONE));
      if (!r.eql(r.sqr(l), s))
        throw new Error("Cannot find square root");
      return l;
    };
  }
  return j(e);
}
const A = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function Q(e) {
  const o = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  }, n = A.reduce((r, s) => (r[s] = "function", r), o);
  return L(e, n);
}
function O(e, o, n) {
  if (n < f)
    throw new Error("Expected power > 0");
  if (n === f)
    return e.ONE;
  if (n === u)
    return o;
  let r = e.ONE, s = o;
  for (; n > f; )
    n & u && (r = e.mul(r, s)), s = e.sqr(s), n >>= u;
  return r;
}
function z(e, o) {
  const n = new Array(o.length), r = o.reduce((c, d, i) => e.is0(d) ? c : (n[i] = c, e.mul(c, d)), e.ONE), s = e.inv(r);
  return o.reduceRight((c, d, i) => e.is0(d) ? c : (n[i] = e.mul(c, n[i]), e.mul(c, d)), s), n;
}
function x(e, o) {
  const n = o !== void 0 ? o : e.toString(2).length, r = Math.ceil(n / 8);
  return { nBitLength: n, nByteLength: r };
}
function V(e, o, n = !1, r = {}) {
  if (e <= f)
    throw new Error(`Expected Fp ORDER > 0, got ${e}`);
  const { nBitLength: s, nByteLength: c } = x(e, o);
  if (c > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const d = k(e), i = Object.freeze({
    ORDER: e,
    BITS: s,
    BYTES: c,
    MASK: $(s),
    ZERO: f,
    ONE: u,
    create: (t) => g(t, e),
    isValid: (t) => {
      if (typeof t != "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof t}`);
      return f <= t && t < e;
    },
    is0: (t) => t === f,
    isOdd: (t) => (t & u) === u,
    neg: (t) => g(-t, e),
    eql: (t, l) => t === l,
    sqr: (t) => g(t * t, e),
    add: (t, l) => g(t + l, e),
    sub: (t, l) => g(t - l, e),
    mul: (t, l) => g(t * l, e),
    pow: (t, l) => O(i, t, l),
    div: (t, l) => g(t * S(l, e), e),
    // Same as above, but doesn't normalize
    sqrN: (t) => t * t,
    addN: (t, l) => t + l,
    subN: (t, l) => t - l,
    mulN: (t, l) => t * l,
    inv: (t) => S(t, e),
    sqrt: r.sqrt || ((t) => d(i, t)),
    invertBatch: (t) => z(i, t),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (t, l, a) => a ? l : t,
    toBytes: (t) => n ? C(t, c) : _(t, c),
    fromBytes: (t) => {
      if (t.length !== c)
        throw new Error(`Fp.fromBytes: expected ${c}, got ${t.length}`);
      return n ? y(t) : m(t);
    }
  });
  return Object.freeze(i);
}
function Y(e, o, n = !1) {
  e = T("privateHash", e);
  const r = e.length, s = x(o).nByteLength + 8;
  if (s < 24 || r < s || r > 1024)
    throw new Error(`hashToPrivateScalar: expected ${s}-1024 bytes of input, got ${r}`);
  const c = n ? y(e) : m(e);
  return g(c, o - u) + u;
}
export {
  V as Field,
  z as FpInvertBatch,
  O as FpPow,
  k as FpSqrt,
  Y as hashToPrivateScalar,
  S as invert,
  g as mod,
  x as nLength,
  Z as pow,
  j as tonelliShanks,
  Q as validateField
};
