"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const p=BigInt(0),y=BigInt(1),v=BigInt(2),g=t=>t instanceof Uint8Array,U=Array.from({length:256},(t,e)=>e.toString(16).padStart(2,"0"));function w(t){if(!g(t))throw new Error("Uint8Array expected");let e="";for(let r=0;r<t.length;r++)e+=U[t[r]];return e}function B(t){const e=t.toString(16);return e.length&1?`0${e}`:e}function h(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);return BigInt(t===""?"0":`0x${t}`)}function b(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);if(t.length%2)throw new Error("hex string is invalid: unpadded "+t.length);const e=new Uint8Array(t.length/2);for(let r=0;r<e.length;r++){const n=r*2,o=t.slice(n,n+2),i=Number.parseInt(o,16);if(Number.isNaN(i)||i<0)throw new Error("invalid byte sequence");e[r]=i}return e}function $(t){return h(w(t))}function A(t){if(!g(t))throw new Error("Uint8Array expected");return h(w(Uint8Array.from(t).reverse()))}const E=(t,e)=>b(t.toString(16).padStart(e*2,"0")),I=(t,e)=>E(t,e).reverse(),N=t=>b(B(t));function S(t,e,r){let n;if(typeof e=="string")try{n=b(e)}catch(i){throw new Error(`${t} must be valid hex string, got "${e}". Cause: ${i}`)}else if(g(e))n=Uint8Array.from(e);else throw new Error(`${t} must be hex string or Uint8Array`);const o=n.length;if(typeof r=="number"&&o!==r)throw new Error(`${t} expected ${r} bytes, got ${o}`);return n}function T(...t){const e=new Uint8Array(t.reduce((n,o)=>n+o.length,0));let r=0;return t.forEach(n=>{if(!g(n))throw new Error("Uint8Array expected");e.set(n,r),r+=n.length}),e}function H(t,e){if(t.length!==e.length)return!1;for(let r=0;r<t.length;r++)if(t[r]!==e[r])return!1;return!0}function k(t){if(typeof t!="string")throw new Error(`utf8ToBytes expected string, got ${typeof t}`);return new TextEncoder().encode(t)}function O(t){let e;for(e=0;t>p;t>>=y,e+=1);return e}const j=(t,e)=>t>>BigInt(e)&y,V=(t,e,r)=>t|(r?y:p)<<BigInt(e),F=t=>(v<<BigInt(t-1))-y,d=t=>new Uint8Array(t),m=t=>Uint8Array.from(t);function M(t,e,r){if(typeof t!="number"||t<2)throw new Error("hashLen must be a number");if(typeof e!="number"||e<2)throw new Error("qByteLen must be a number");if(typeof r!="function")throw new Error("hmacFn must be a function");let n=d(t),o=d(t),i=0;const c=()=>{n.fill(1),o.fill(0),i=0},u=(...s)=>r(o,n,...s),f=(s=d())=>{o=u(m([0]),s),n=u(),s.length!==0&&(o=u(m([1]),s),n=u())},x=()=>{if(i++>=1e3)throw new Error("drbg: tried 1000 values");let s=0;const a=[];for(;s<e;){n=u();const l=n.slice();a.push(l),s+=n.length}return T(...a)};return(s,a)=>{c(),f(s);let l;for(;!(l=a(x()));)f();return c(),l}}const _={bigint:t=>typeof t=="bigint",function:t=>typeof t=="function",boolean:t=>typeof t=="boolean",string:t=>typeof t=="string",isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,e)=>e.Fp.isValid(t),hash:t=>typeof t=="function"&&Number.isSafeInteger(t.outputLen)};function q(t,e,r={}){const n=(o,i,c)=>{const u=_[i];if(typeof u!="function")throw new Error(`Invalid validator "${i}", expected function`);const f=t[o];if(!(c&&f===void 0)&&!u(f,t))throw new Error(`Invalid param ${String(o)}=${f} (${typeof f}), expected ${i}`)};for(const[o,i]of Object.entries(e))n(o,i,!1);for(const[o,i]of Object.entries(r))n(o,i,!0);return t}exports.bitGet=j;exports.bitLen=O;exports.bitMask=F;exports.bitSet=V;exports.bytesToHex=w;exports.bytesToNumberBE=$;exports.bytesToNumberLE=A;exports.concatBytes=T;exports.createHmacDrbg=M;exports.ensureBytes=S;exports.equalBytes=H;exports.hexToBytes=b;exports.hexToNumber=h;exports.numberToBytesBE=E;exports.numberToBytesLE=I;exports.numberToHexUnpadded=B;exports.numberToVarBytesBE=N;exports.utf8ToBytes=k;exports.validateObject=q;
