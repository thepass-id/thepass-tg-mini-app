import { mod as ut, hashToPrivateScalar as dt, invert as ht } from "./modular.js";
import * as mt from "./utils.js";
import { validateObject as lt, concatBytes as et, ensureBytes as Y, bytesToHex as nt, bytesToNumberBE as _, bitMask as yt, numberToBytesBE as rt, hexToBytes as at, createHmacDrbg as pt } from "./utils.js";
import { validateBasic as ft, wNAF as wt } from "./curve.js";
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function Et(B) {
  const n = ft(B);
  lt(n, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo: t, Fp: v, a: A } = n;
  if (t) {
    if (!v.eql(A, v.ZERO))
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    if (typeof t != "object" || typeof t.beta != "bigint" || typeof t.splitScalar != "function")
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
  }
  return Object.freeze({ ...n });
}
const { bytesToNumberBE: gt, hexToBytes: bt } = mt, k = {
  // asn.1 DER encoding utils
  Err: class extends Error {
    constructor(n = "") {
      super(n);
    }
  },
  _parseInt(B) {
    const { Err: n } = k;
    if (B.length < 2 || B[0] !== 2)
      throw new n("Invalid signature integer tag");
    const t = B[1], v = B.subarray(2, t + 2);
    if (!t || v.length !== t)
      throw new n("Invalid signature integer: wrong length");
    if (v[0] & 128)
      throw new n("Invalid signature integer: negative");
    if (v[0] === 0 && !(v[1] & 128))
      throw new n("Invalid signature integer: unnecessary leading zero");
    return { d: gt(v), l: B.subarray(t + 2) };
  },
  toSig(B) {
    const { Err: n } = k, t = typeof B == "string" ? bt(B) : B;
    if (!(t instanceof Uint8Array))
      throw new Error("ui8a expected");
    let v = t.length;
    if (v < 2 || t[0] != 48)
      throw new n("Invalid signature tag");
    if (t[1] !== v - 2)
      throw new n("Invalid signature: incorrect length");
    const { d: A, l: O } = k._parseInt(t.subarray(2)), { d: F, l: S } = k._parseInt(O);
    if (S.length)
      throw new n("Invalid signature: left bytes after parsing");
    return { r: A, s: F };
  },
  hexFromSig(B) {
    const n = (x) => Number.parseInt(x[0], 16) & 8 ? "00" + x : x, t = (x) => {
      const U = x.toString(16);
      return U.length & 1 ? `0${U}` : U;
    }, v = n(t(B.s)), A = n(t(B.r)), O = v.length / 2, F = A.length / 2, S = t(O), P = t(F);
    return `30${t(F + O + 4)}02${P}${A}02${S}${v}`;
  }
}, L = BigInt(0), z = BigInt(1);
BigInt(2);
const ct = BigInt(3);
BigInt(4);
function Bt(B) {
  const n = Et(B), { Fp: t } = n, v = n.toBytes || ((m, e, i) => {
    const s = e.toAffine();
    return et(Uint8Array.from([4]), t.toBytes(s.x), t.toBytes(s.y));
  }), A = n.fromBytes || ((m) => {
    const e = m.subarray(1), i = t.fromBytes(e.subarray(0, t.BYTES)), s = t.fromBytes(e.subarray(t.BYTES, 2 * t.BYTES));
    return { x: i, y: s };
  });
  function O(m) {
    const { a: e, b: i } = n, s = t.sqr(m), u = t.mul(s, m);
    return t.add(t.add(u, t.mul(m, e)), i);
  }
  if (!t.eql(t.sqr(n.Gy), O(n.Gx)))
    throw new Error("bad generator point: equation left != right");
  function F(m) {
    return typeof m == "bigint" && L < m && m < n.n;
  }
  function S(m) {
    if (!F(m))
      throw new Error("Expected valid bigint: 0 < bigint < curve.n");
  }
  function P(m) {
    const { allowedPrivateKeyLengths: e, nByteLength: i, wrapPrivateKey: s, n: u } = n;
    if (e && typeof m != "bigint") {
      if (m instanceof Uint8Array && (m = nt(m)), typeof m != "string" || !e.includes(m.length))
        throw new Error("Invalid key");
      m = m.padStart(i * 2, "0");
    }
    let f;
    try {
      f = typeof m == "bigint" ? m : _(Y("private key", m, i));
    } catch {
      throw new Error(`private key must be ${i} bytes, hex or bigint, not ${typeof m}`);
    }
    return s && (f = ut(f, u)), S(f), f;
  }
  const x = /* @__PURE__ */ new Map();
  function U(m) {
    if (!(m instanceof y))
      throw new Error("ProjectivePoint expected");
  }
  class y {
    constructor(e, i, s) {
      if (this.px = e, this.py = i, this.pz = s, e == null || !t.isValid(e))
        throw new Error("x required");
      if (i == null || !t.isValid(i))
        throw new Error("y required");
      if (s == null || !t.isValid(s))
        throw new Error("z required");
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(e) {
      const { x: i, y: s } = e || {};
      if (!e || !t.isValid(i) || !t.isValid(s))
        throw new Error("invalid affine point");
      if (e instanceof y)
        throw new Error("projective point not allowed");
      const u = (f) => t.eql(f, t.ZERO);
      return u(i) && u(s) ? y.ZERO : new y(i, s, t.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(e) {
      const i = t.invertBatch(e.map((s) => s.pz));
      return e.map((s, u) => s.toAffine(i[u])).map(y.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(e) {
      const i = y.fromAffine(A(Y("pointHex", e)));
      return i.assertValidity(), i;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(e) {
      return y.BASE.multiply(P(e));
    }
    // "Private method", don't use it directly
    _setWindowSize(e) {
      this._WINDOW_SIZE = e, x.delete(this);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      if (this.is0()) {
        if (n.allowInfinityPoint)
          return;
        throw new Error("bad point: ZERO");
      }
      const { x: e, y: i } = this.toAffine();
      if (!t.isValid(e) || !t.isValid(i))
        throw new Error("bad point: x or y not FE");
      const s = t.sqr(i), u = O(e);
      if (!t.eql(s, u))
        throw new Error("bad point: equation left != right");
      if (!this.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
    }
    hasEvenY() {
      const { y: e } = this.toAffine();
      if (t.isOdd)
        return !t.isOdd(e);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(e) {
      U(e);
      const { px: i, py: s, pz: u } = this, { px: f, py: E, pz: h } = e, a = t.eql(t.mul(i, h), t.mul(f, u)), c = t.eql(t.mul(s, h), t.mul(E, u));
      return a && c;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new y(this.px, t.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: e, b: i } = n, s = t.mul(i, ct), { px: u, py: f, pz: E } = this;
      let h = t.ZERO, a = t.ZERO, c = t.ZERO, d = t.mul(u, u), N = t.mul(f, f), b = t.mul(E, E), p = t.mul(u, f);
      return p = t.add(p, p), c = t.mul(u, E), c = t.add(c, c), h = t.mul(e, c), a = t.mul(s, b), a = t.add(h, a), h = t.sub(N, a), a = t.add(N, a), a = t.mul(h, a), h = t.mul(p, h), c = t.mul(s, c), b = t.mul(e, b), p = t.sub(d, b), p = t.mul(e, p), p = t.add(p, c), c = t.add(d, d), d = t.add(c, d), d = t.add(d, b), d = t.mul(d, p), a = t.add(a, d), b = t.mul(f, E), b = t.add(b, b), d = t.mul(b, p), h = t.sub(h, d), c = t.mul(b, N), c = t.add(c, c), c = t.add(c, c), new y(h, a, c);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(e) {
      U(e);
      const { px: i, py: s, pz: u } = this, { px: f, py: E, pz: h } = e;
      let a = t.ZERO, c = t.ZERO, d = t.ZERO;
      const N = n.a, b = t.mul(n.b, ct);
      let p = t.mul(i, f), T = t.mul(s, E), Z = t.mul(u, h), H = t.add(i, s), r = t.add(f, E);
      H = t.mul(H, r), r = t.add(p, T), H = t.sub(H, r), r = t.add(i, u);
      let o = t.add(f, h);
      return r = t.mul(r, o), o = t.add(p, Z), r = t.sub(r, o), o = t.add(s, u), a = t.add(E, h), o = t.mul(o, a), a = t.add(T, Z), o = t.sub(o, a), d = t.mul(N, r), a = t.mul(b, Z), d = t.add(a, d), a = t.sub(T, d), d = t.add(T, d), c = t.mul(a, d), T = t.add(p, p), T = t.add(T, p), Z = t.mul(N, Z), r = t.mul(b, r), T = t.add(T, Z), Z = t.sub(p, Z), Z = t.mul(N, Z), r = t.add(r, Z), p = t.mul(T, r), c = t.add(c, p), p = t.mul(o, r), a = t.mul(H, a), a = t.sub(a, p), p = t.mul(H, T), d = t.mul(o, d), d = t.add(d, p), new y(a, c, d);
    }
    subtract(e) {
      return this.add(e.negate());
    }
    is0() {
      return this.equals(y.ZERO);
    }
    wNAF(e) {
      return C.wNAFCached(this, x, e, (i) => {
        const s = t.invertBatch(i.map((u) => u.pz));
        return i.map((u, f) => u.toAffine(s[f])).map(y.fromAffine);
      });
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(e) {
      const i = y.ZERO;
      if (e === L)
        return i;
      if (S(e), e === z)
        return this;
      const { endo: s } = n;
      if (!s)
        return C.unsafeLadder(this, e);
      let { k1neg: u, k1: f, k2neg: E, k2: h } = s.splitScalar(e), a = i, c = i, d = this;
      for (; f > L || h > L; )
        f & z && (a = a.add(d)), h & z && (c = c.add(d)), d = d.double(), f >>= z, h >>= z;
      return u && (a = a.negate()), E && (c = c.negate()), c = new y(t.mul(c.px, s.beta), c.py, c.pz), a.add(c);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(e) {
      S(e);
      let i = e, s, u;
      const { endo: f } = n;
      if (f) {
        const { k1neg: E, k1: h, k2neg: a, k2: c } = f.splitScalar(i);
        let { p: d, f: N } = this.wNAF(h), { p: b, f: p } = this.wNAF(c);
        d = C.constTimeNegate(E, d), b = C.constTimeNegate(a, b), b = new y(t.mul(b.px, f.beta), b.py, b.pz), s = d.add(b), u = N.add(p);
      } else {
        const { p: E, f: h } = this.wNAF(i);
        s = E, u = h;
      }
      return y.normalizeZ([s, u])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(e, i, s) {
      const u = y.BASE, f = (h, a) => a === L || a === z || !h.equals(u) ? h.multiplyUnsafe(a) : h.multiply(a), E = f(this, i).add(f(e, s));
      return E.is0() ? void 0 : E;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z) ∋ (x=x/z, y=y/z)
    toAffine(e) {
      const { px: i, py: s, pz: u } = this, f = this.is0();
      e == null && (e = f ? t.ONE : t.inv(u));
      const E = t.mul(i, e), h = t.mul(s, e), a = t.mul(u, e);
      if (f)
        return { x: t.ZERO, y: t.ZERO };
      if (!t.eql(a, t.ONE))
        throw new Error("invZ was invalid");
      return { x: E, y: h };
    }
    isTorsionFree() {
      const { h: e, isTorsionFree: i } = n;
      if (e === z)
        return !0;
      if (i)
        return i(y, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: e, clearCofactor: i } = n;
      return e === z ? this : i ? i(y, this) : this.multiplyUnsafe(n.h);
    }
    toRawBytes(e = !0) {
      return this.assertValidity(), v(y, this, e);
    }
    toHex(e = !0) {
      return nt(this.toRawBytes(e));
    }
  }
  y.BASE = new y(n.Gx, n.Gy, t.ONE), y.ZERO = new y(t.ZERO, t.ONE, t.ZERO);
  const W = n.nBitLength, C = wt(y, n.endo ? Math.ceil(W / 2) : W);
  return {
    CURVE: n,
    ProjectivePoint: y,
    normPrivateKeyToScalar: P,
    weierstrassEquation: O,
    isWithinCurveOrder: F
  };
}
function vt(B) {
  const n = ft(B);
  return lt(n, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  }), Object.freeze({ lowS: !0, ...n });
}
function Ot(B) {
  const n = vt(B), { Fp: t, n: v } = n, A = t.BYTES + 1, O = 2 * t.BYTES + 1;
  function F(r) {
    return L < r && r < t.ORDER;
  }
  function S(r) {
    return ut(r, v);
  }
  function P(r) {
    return ht(r, v);
  }
  const { ProjectivePoint: x, normPrivateKeyToScalar: U, weierstrassEquation: y, isWithinCurveOrder: W } = Bt({
    ...n,
    toBytes(r, o, l) {
      const g = o.toAffine(), w = t.toBytes(g.x), R = et;
      return l ? R(Uint8Array.from([o.hasEvenY() ? 2 : 3]), w) : R(Uint8Array.from([4]), w, t.toBytes(g.y));
    },
    fromBytes(r) {
      const o = r.length, l = r[0], g = r.subarray(1);
      if (o === A && (l === 2 || l === 3)) {
        const w = _(g);
        if (!F(w))
          throw new Error("Point is not on curve");
        const R = y(w);
        let q = t.sqrt(R);
        const I = (q & z) === z;
        return (l & 1) === 1 !== I && (q = t.neg(q)), { x: w, y: q };
      } else if (o === O && l === 4) {
        const w = t.fromBytes(g.subarray(0, t.BYTES)), R = t.fromBytes(g.subarray(t.BYTES, 2 * t.BYTES));
        return { x: w, y: R };
      } else
        throw new Error(`Point of length ${o} was invalid. Expected ${A} compressed bytes or ${O} uncompressed bytes`);
    }
  }), C = (r) => nt(rt(r, n.nByteLength));
  function m(r) {
    const o = v >> z;
    return r > o;
  }
  function e(r) {
    return m(r) ? S(-r) : r;
  }
  const i = (r, o, l) => _(r.slice(o, l));
  class s {
    constructor(o, l, g) {
      this.r = o, this.s = l, this.recovery = g, this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(o) {
      const l = n.nByteLength;
      return o = Y("compactSignature", o, l * 2), new s(i(o, 0, l), i(o, l, 2 * l));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(o) {
      const { r: l, s: g } = k.toSig(Y("DER", o));
      return new s(l, g);
    }
    assertValidity() {
      if (!W(this.r))
        throw new Error("r must be 0 < r < CURVE.n");
      if (!W(this.s))
        throw new Error("s must be 0 < s < CURVE.n");
    }
    addRecoveryBit(o) {
      return new s(this.r, this.s, o);
    }
    recoverPublicKey(o) {
      const { r: l, s: g, recovery: w } = this, R = c(Y("msgHash", o));
      if (w == null || ![0, 1, 2, 3].includes(w))
        throw new Error("recovery id invalid");
      const q = w === 2 || w === 3 ? l + n.n : l;
      if (q >= t.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const I = w & 1 ? "03" : "02", D = x.fromHex(I + C(q)), K = P(q), X = S(-R * K), J = S(g * K), $ = x.BASE.multiplyAndAddUnsafe(D, X, J);
      if (!$)
        throw new Error("point at infinify");
      return $.assertValidity(), $;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return m(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new s(this.r, S(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return at(this.toDERHex());
    }
    toDERHex() {
      return k.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return at(this.toCompactHex());
    }
    toCompactHex() {
      return C(this.r) + C(this.s);
    }
  }
  const u = {
    isValidPrivateKey(r) {
      try {
        return U(r), !0;
      } catch {
        return !1;
      }
    },
    normPrivateKeyToScalar: U,
    /**
     * Produces cryptographically secure private key from random of size (nBitLength+64)
     * as per FIPS 186 B.4.1 with modulo bias being neglible.
     */
    randomPrivateKey: () => {
      const r = n.randomBytes(t.BYTES + 8), o = dt(r, v);
      return rt(o, n.nByteLength);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(r = 8, o = x.BASE) {
      return o._setWindowSize(r), o.multiply(BigInt(3)), o;
    }
  };
  function f(r, o = !0) {
    return x.fromPrivateKey(r).toRawBytes(o);
  }
  function E(r) {
    const o = r instanceof Uint8Array, l = typeof r == "string", g = (o || l) && r.length;
    return o ? g === A || g === O : l ? g === 2 * A || g === 2 * O : r instanceof x;
  }
  function h(r, o, l = !0) {
    if (E(r))
      throw new Error("first arg must be private key");
    if (!E(o))
      throw new Error("second arg must be public key");
    return x.fromHex(o).multiply(U(r)).toRawBytes(l);
  }
  const a = n.bits2int || function(r) {
    const o = _(r), l = r.length * 8 - n.nBitLength;
    return l > 0 ? o >> BigInt(l) : o;
  }, c = n.bits2int_modN || function(r) {
    return S(a(r));
  }, d = yt(n.nBitLength);
  function N(r) {
    if (typeof r != "bigint")
      throw new Error("bigint expected");
    if (!(L <= r && r < d))
      throw new Error(`bigint expected < 2^${n.nBitLength}`);
    return rt(r, n.nByteLength);
  }
  function b(r, o, l = p) {
    if (["recovered", "canonical"].some((j) => j in l))
      throw new Error("sign() legacy options not supported");
    const { hash: g, randomBytes: w } = n;
    let { lowS: R, prehash: q, extraEntropy: I } = l;
    R == null && (R = !0), r = Y("msgHash", r), q && (r = Y("prehashed msgHash", g(r)));
    const D = c(r), K = U(o), X = [N(K), N(D)];
    if (I != null) {
      const j = I === !0 ? w(t.BYTES) : I;
      X.push(Y("extraEntropy", j, t.BYTES));
    }
    const J = et(...X), $ = D;
    function tt(j) {
      const G = a(j);
      if (!W(G))
        return;
      const ot = P(G), M = x.BASE.multiply(G).toAffine(), V = S(M.x);
      if (V === L)
        return;
      const Q = S(ot * S($ + V * K));
      if (Q === L)
        return;
      let st = (M.x === V ? 0 : 2) | Number(M.y & z), it = Q;
      return R && m(Q) && (it = e(Q), st ^= 1), new s(V, it, st);
    }
    return { seed: J, k2sig: tt };
  }
  const p = { lowS: n.lowS, prehash: !1 }, T = { lowS: n.lowS, prehash: !1 };
  function Z(r, o, l = p) {
    const { seed: g, k2sig: w } = b(r, o, l);
    return pt(n.hash.outputLen, n.nByteLength, n.hmac)(g, w);
  }
  x.BASE._setWindowSize(8);
  function H(r, o, l, g = T) {
    var M;
    const w = r;
    if (o = Y("msgHash", o), l = Y("publicKey", l), "strict" in g)
      throw new Error("options.strict was renamed to lowS");
    const { lowS: R, prehash: q } = g;
    let I, D;
    try {
      if (typeof w == "string" || w instanceof Uint8Array)
        try {
          I = s.fromDER(w);
        } catch (V) {
          if (!(V instanceof k.Err))
            throw V;
          I = s.fromCompact(w);
        }
      else if (typeof w == "object" && typeof w.r == "bigint" && typeof w.s == "bigint") {
        const { r: V, s: Q } = w;
        I = new s(V, Q);
      } else
        throw new Error("PARSE");
      D = x.fromHex(l);
    } catch (V) {
      if (V.message === "PARSE")
        throw new Error("signature must be Signature instance, Uint8Array or hex string");
      return !1;
    }
    if (R && I.hasHighS())
      return !1;
    q && (o = n.hash(o));
    const { r: K, s: X } = I, J = c(o), $ = P(X), tt = S(J * $), j = S(K * $), G = (M = x.BASE.multiplyAndAddUnsafe(D, tt, j)) == null ? void 0 : M.toAffine();
    return G ? S(G.x) === K : !1;
  }
  return {
    CURVE: n,
    getPublicKey: f,
    getSharedSecret: h,
    sign: Z,
    verify: H,
    ProjectivePoint: x,
    Signature: s,
    utils: u
  };
}
export {
  k as DER,
  Ot as weierstrass,
  Bt as weierstrassPoints
};
