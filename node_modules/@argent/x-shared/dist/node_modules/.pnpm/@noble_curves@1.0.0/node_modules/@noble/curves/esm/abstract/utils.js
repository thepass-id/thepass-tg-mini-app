/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const h = BigInt(0), g = BigInt(1), B = BigInt(2), y = (t) => t instanceof Uint8Array, $ = Array.from({ length: 256 }, (t, e) => e.toString(16).padStart(2, "0"));
function b(t) {
  if (!y(t))
    throw new Error("Uint8Array expected");
  let e = "";
  for (let r = 0; r < t.length; r++)
    e += $[t[r]];
  return e;
}
function A(t) {
  const e = t.toString(16);
  return e.length & 1 ? `0${e}` : e;
}
function m(t) {
  if (typeof t != "string")
    throw new Error("hex string expected, got " + typeof t);
  return BigInt(t === "" ? "0" : `0x${t}`);
}
function d(t) {
  if (typeof t != "string")
    throw new Error("hex string expected, got " + typeof t);
  if (t.length % 2)
    throw new Error("hex string is invalid: unpadded " + t.length);
  const e = new Uint8Array(t.length / 2);
  for (let r = 0; r < e.length; r++) {
    const n = r * 2, o = t.slice(n, n + 2), i = Number.parseInt(o, 16);
    if (Number.isNaN(i) || i < 0)
      throw new Error("invalid byte sequence");
    e[r] = i;
  }
  return e;
}
function T(t) {
  return m(b(t));
}
function N(t) {
  if (!y(t))
    throw new Error("Uint8Array expected");
  return m(b(Uint8Array.from(t).reverse()));
}
const U = (t, e) => d(t.toString(16).padStart(e * 2, "0")), S = (t, e) => U(t, e).reverse(), k = (t) => d(A(t));
function F(t, e, r) {
  let n;
  if (typeof e == "string")
    try {
      n = d(e);
    } catch (i) {
      throw new Error(`${t} must be valid hex string, got "${e}". Cause: ${i}`);
    }
  else if (y(e))
    n = Uint8Array.from(e);
  else
    throw new Error(`${t} must be hex string or Uint8Array`);
  const o = n.length;
  if (typeof r == "number" && o !== r)
    throw new Error(`${t} expected ${r} bytes, got ${o}`);
  return n;
}
function v(...t) {
  const e = new Uint8Array(t.reduce((n, o) => n + o.length, 0));
  let r = 0;
  return t.forEach((n) => {
    if (!y(n))
      throw new Error("Uint8Array expected");
    e.set(n, r), r += n.length;
  }), e;
}
function H(t, e) {
  if (t.length !== e.length)
    return !1;
  for (let r = 0; r < t.length; r++)
    if (t[r] !== e[r])
      return !1;
  return !0;
}
function O(t) {
  if (typeof t != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof t}`);
  return new TextEncoder().encode(t);
}
function V(t) {
  let e;
  for (e = 0; t > h; t >>= g, e += 1)
    ;
  return e;
}
const _ = (t, e) => t >> BigInt(e) & g, j = (t, e, r) => t | (r ? g : h) << BigInt(e), q = (t) => (B << BigInt(t - 1)) - g, w = (t) => new Uint8Array(t), p = (t) => Uint8Array.from(t);
function C(t, e, r) {
  if (typeof t != "number" || t < 2)
    throw new Error("hashLen must be a number");
  if (typeof e != "number" || e < 2)
    throw new Error("qByteLen must be a number");
  if (typeof r != "function")
    throw new Error("hmacFn must be a function");
  let n = w(t), o = w(t), i = 0;
  const c = () => {
    n.fill(1), o.fill(0), i = 0;
  }, s = (...f) => r(o, n, ...f), u = (f = w()) => {
    o = s(p([0]), f), n = s(), f.length !== 0 && (o = s(p([1]), f), n = s());
  }, E = () => {
    if (i++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let f = 0;
    const a = [];
    for (; f < e; ) {
      n = s();
      const l = n.slice();
      a.push(l), f += n.length;
    }
    return v(...a);
  };
  return (f, a) => {
    c(), u(f);
    let l;
    for (; !(l = a(E())); )
      u();
    return c(), l;
  };
}
const x = {
  bigint: (t) => typeof t == "bigint",
  function: (t) => typeof t == "function",
  boolean: (t) => typeof t == "boolean",
  string: (t) => typeof t == "string",
  isSafeInteger: (t) => Number.isSafeInteger(t),
  array: (t) => Array.isArray(t),
  field: (t, e) => e.Fp.isValid(t),
  hash: (t) => typeof t == "function" && Number.isSafeInteger(t.outputLen)
};
function D(t, e, r = {}) {
  const n = (o, i, c) => {
    const s = x[i];
    if (typeof s != "function")
      throw new Error(`Invalid validator "${i}", expected function`);
    const u = t[o];
    if (!(c && u === void 0) && !s(u, t))
      throw new Error(`Invalid param ${String(o)}=${u} (${typeof u}), expected ${i}`);
  };
  for (const [o, i] of Object.entries(e))
    n(o, i, !1);
  for (const [o, i] of Object.entries(r))
    n(o, i, !0);
  return t;
}
export {
  _ as bitGet,
  V as bitLen,
  q as bitMask,
  j as bitSet,
  b as bytesToHex,
  T as bytesToNumberBE,
  N as bytesToNumberLE,
  v as concatBytes,
  C as createHmacDrbg,
  F as ensureBytes,
  H as equalBytes,
  d as hexToBytes,
  m as hexToNumber,
  U as numberToBytesBE,
  S as numberToBytesLE,
  A as numberToHexUnpadded,
  k as numberToVarBytesBE,
  O as utf8ToBytes,
  D as validateObject
};
