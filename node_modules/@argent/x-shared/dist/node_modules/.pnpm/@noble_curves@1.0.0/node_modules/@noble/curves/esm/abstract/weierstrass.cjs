"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const _=require("./modular.cjs"),m=require("./utils.cjs"),et=require("./curve.cjs");/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function at(v){const n=et.validateBasic(v);m.validateObject(n,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:t,Fp:x,a:O}=n;if(t){if(!x.eql(O,x.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if(typeof t!="object"||typeof t.beta!="bigint"||typeof t.splitScalar!="function")throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...n})}const{bytesToNumberBE:ct,hexToBytes:ut}=m,$={Err:class extends Error{constructor(n=""){super(n)}},_parseInt(v){const{Err:n}=$;if(v.length<2||v[0]!==2)throw new n("Invalid signature integer tag");const t=v[1],x=v.subarray(2,t+2);if(!t||x.length!==t)throw new n("Invalid signature integer: wrong length");if(x[0]&128)throw new n("Invalid signature integer: negative");if(x[0]===0&&!(x[1]&128))throw new n("Invalid signature integer: unnecessary leading zero");return{d:ct(x),l:v.subarray(t+2)}},toSig(v){const{Err:n}=$,t=typeof v=="string"?ut(v):v;if(!(t instanceof Uint8Array))throw new Error("ui8a expected");let x=t.length;if(x<2||t[0]!=48)throw new n("Invalid signature tag");if(t[1]!==x-2)throw new n("Invalid signature: incorrect length");const{d:O,l:T}=$._parseInt(t.subarray(2)),{d:F,l:R}=$._parseInt(T);if(R.length)throw new n("Invalid signature: left bytes after parsing");return{r:O,s:F}},hexFromSig(v){const n=S=>Number.parseInt(S[0],16)&8?"00"+S:S,t=S=>{const V=S.toString(16);return V.length&1?`0${V}`:V},x=n(t(v.s)),O=n(t(v.r)),T=x.length/2,F=O.length/2,R=t(T),L=t(F);return`30${t(F+T+4)}02${L}${O}02${R}${x}`}},P=BigInt(0),U=BigInt(1);BigInt(2);const ot=BigInt(3);BigInt(4);function it(v){const n=at(v),{Fp:t}=n,x=n.toBytes||((y,r,i)=>{const o=r.toAffine();return m.concatBytes(Uint8Array.from([4]),t.toBytes(o.x),t.toBytes(o.y))}),O=n.fromBytes||(y=>{const r=y.subarray(1),i=t.fromBytes(r.subarray(0,t.BYTES)),o=t.fromBytes(r.subarray(t.BYTES,2*t.BYTES));return{x:i,y:o}});function T(y){const{a:r,b:i}=n,o=t.sqr(y),u=t.mul(o,y);return t.add(t.add(u,t.mul(y,r)),i)}if(!t.eql(t.sqr(n.Gy),T(n.Gx)))throw new Error("bad generator point: equation left != right");function F(y){return typeof y=="bigint"&&P<y&&y<n.n}function R(y){if(!F(y))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function L(y){const{allowedPrivateKeyLengths:r,nByteLength:i,wrapPrivateKey:o,n:u}=n;if(r&&typeof y!="bigint"){if(y instanceof Uint8Array&&(y=m.bytesToHex(y)),typeof y!="string"||!r.includes(y.length))throw new Error("Invalid key");y=y.padStart(i*2,"0")}let f;try{f=typeof y=="bigint"?y:m.bytesToNumberBE(m.ensureBytes("private key",y,i))}catch{throw new Error(`private key must be ${i} bytes, hex or bigint, not ${typeof y}`)}return o&&(f=_.mod(f,u)),R(f),f}const S=new Map;function V(y){if(!(y instanceof w))throw new Error("ProjectivePoint expected")}class w{constructor(r,i,o){if(this.px=r,this.py=i,this.pz=o,r==null||!t.isValid(r))throw new Error("x required");if(i==null||!t.isValid(i))throw new Error("y required");if(o==null||!t.isValid(o))throw new Error("z required")}static fromAffine(r){const{x:i,y:o}=r||{};if(!r||!t.isValid(i)||!t.isValid(o))throw new Error("invalid affine point");if(r instanceof w)throw new Error("projective point not allowed");const u=f=>t.eql(f,t.ZERO);return u(i)&&u(o)?w.ZERO:new w(i,o,t.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(r){const i=t.invertBatch(r.map(o=>o.pz));return r.map((o,u)=>o.toAffine(i[u])).map(w.fromAffine)}static fromHex(r){const i=w.fromAffine(O(m.ensureBytes("pointHex",r)));return i.assertValidity(),i}static fromPrivateKey(r){return w.BASE.multiply(L(r))}_setWindowSize(r){this._WINDOW_SIZE=r,S.delete(this)}assertValidity(){if(this.is0()){if(n.allowInfinityPoint)return;throw new Error("bad point: ZERO")}const{x:r,y:i}=this.toAffine();if(!t.isValid(r)||!t.isValid(i))throw new Error("bad point: x or y not FE");const o=t.sqr(i),u=T(r);if(!t.eql(o,u))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y:r}=this.toAffine();if(t.isOdd)return!t.isOdd(r);throw new Error("Field doesn't support isOdd")}equals(r){V(r);const{px:i,py:o,pz:u}=this,{px:f,py:g,pz:h}=r,a=t.eql(t.mul(i,h),t.mul(f,u)),c=t.eql(t.mul(o,h),t.mul(g,u));return a&&c}negate(){return new w(this.px,t.neg(this.py),this.pz)}double(){const{a:r,b:i}=n,o=t.mul(i,ot),{px:u,py:f,pz:g}=this;let h=t.ZERO,a=t.ZERO,c=t.ZERO,d=t.mul(u,u),q=t.mul(f,f),B=t.mul(g,g),p=t.mul(u,f);return p=t.add(p,p),c=t.mul(u,g),c=t.add(c,c),h=t.mul(r,c),a=t.mul(o,B),a=t.add(h,a),h=t.sub(q,a),a=t.add(q,a),a=t.mul(h,a),h=t.mul(p,h),c=t.mul(o,c),B=t.mul(r,B),p=t.sub(d,B),p=t.mul(r,p),p=t.add(p,c),c=t.add(d,d),d=t.add(c,d),d=t.add(d,B),d=t.mul(d,p),a=t.add(a,d),B=t.mul(f,g),B=t.add(B,B),d=t.mul(B,p),h=t.sub(h,d),c=t.mul(B,q),c=t.add(c,c),c=t.add(c,c),new w(h,a,c)}add(r){V(r);const{px:i,py:o,pz:u}=this,{px:f,py:g,pz:h}=r;let a=t.ZERO,c=t.ZERO,d=t.ZERO;const q=n.a,B=t.mul(n.b,ot);let p=t.mul(i,f),N=t.mul(o,g),Z=t.mul(u,h),H=t.add(i,o),e=t.add(f,g);H=t.mul(H,e),e=t.add(p,N),H=t.sub(H,e),e=t.add(i,u);let s=t.add(f,h);return e=t.mul(e,s),s=t.add(p,Z),e=t.sub(e,s),s=t.add(o,u),a=t.add(g,h),s=t.mul(s,a),a=t.add(N,Z),s=t.sub(s,a),d=t.mul(q,e),a=t.mul(B,Z),d=t.add(a,d),a=t.sub(N,d),d=t.add(N,d),c=t.mul(a,d),N=t.add(p,p),N=t.add(N,p),Z=t.mul(q,Z),e=t.mul(B,e),N=t.add(N,Z),Z=t.sub(p,Z),Z=t.mul(q,Z),e=t.add(e,Z),p=t.mul(N,e),c=t.add(c,p),p=t.mul(s,e),a=t.mul(H,a),a=t.sub(a,p),p=t.mul(H,N),d=t.mul(s,d),d=t.add(d,p),new w(a,c,d)}subtract(r){return this.add(r.negate())}is0(){return this.equals(w.ZERO)}wNAF(r){return C.wNAFCached(this,S,r,i=>{const o=t.invertBatch(i.map(u=>u.pz));return i.map((u,f)=>u.toAffine(o[f])).map(w.fromAffine)})}multiplyUnsafe(r){const i=w.ZERO;if(r===P)return i;if(R(r),r===U)return this;const{endo:o}=n;if(!o)return C.unsafeLadder(this,r);let{k1neg:u,k1:f,k2neg:g,k2:h}=o.splitScalar(r),a=i,c=i,d=this;for(;f>P||h>P;)f&U&&(a=a.add(d)),h&U&&(c=c.add(d)),d=d.double(),f>>=U,h>>=U;return u&&(a=a.negate()),g&&(c=c.negate()),c=new w(t.mul(c.px,o.beta),c.py,c.pz),a.add(c)}multiply(r){R(r);let i=r,o,u;const{endo:f}=n;if(f){const{k1neg:g,k1:h,k2neg:a,k2:c}=f.splitScalar(i);let{p:d,f:q}=this.wNAF(h),{p:B,f:p}=this.wNAF(c);d=C.constTimeNegate(g,d),B=C.constTimeNegate(a,B),B=new w(t.mul(B.px,f.beta),B.py,B.pz),o=d.add(B),u=q.add(p)}else{const{p:g,f:h}=this.wNAF(i);o=g,u=h}return w.normalizeZ([o,u])[0]}multiplyAndAddUnsafe(r,i,o){const u=w.BASE,f=(h,a)=>a===P||a===U||!h.equals(u)?h.multiplyUnsafe(a):h.multiply(a),g=f(this,i).add(f(r,o));return g.is0()?void 0:g}toAffine(r){const{px:i,py:o,pz:u}=this,f=this.is0();r==null&&(r=f?t.ONE:t.inv(u));const g=t.mul(i,r),h=t.mul(o,r),a=t.mul(u,r);if(f)return{x:t.ZERO,y:t.ZERO};if(!t.eql(a,t.ONE))throw new Error("invZ was invalid");return{x:g,y:h}}isTorsionFree(){const{h:r,isTorsionFree:i}=n;if(r===U)return!0;if(i)return i(w,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:r,clearCofactor:i}=n;return r===U?this:i?i(w,this):this.multiplyUnsafe(n.h)}toRawBytes(r=!0){return this.assertValidity(),x(w,this,r)}toHex(r=!0){return m.bytesToHex(this.toRawBytes(r))}}w.BASE=new w(n.Gx,n.Gy,t.ONE),w.ZERO=new w(t.ZERO,t.ONE,t.ZERO);const W=n.nBitLength,C=et.wNAF(w,n.endo?Math.ceil(W/2):W);return{CURVE:n,ProjectivePoint:w,normPrivateKeyToScalar:L,weierstrassEquation:T,isWithinCurveOrder:F}}function lt(v){const n=et.validateBasic(v);return m.validateObject(n,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...n})}function ft(v){const n=lt(v),{Fp:t,n:x}=n,O=t.BYTES+1,T=2*t.BYTES+1;function F(e){return P<e&&e<t.ORDER}function R(e){return _.mod(e,x)}function L(e){return _.invert(e,x)}const{ProjectivePoint:S,normPrivateKeyToScalar:V,weierstrassEquation:w,isWithinCurveOrder:W}=it({...n,toBytes(e,s,l){const b=s.toAffine(),E=t.toBytes(b.x),A=m.concatBytes;return l?A(Uint8Array.from([s.hasEvenY()?2:3]),E):A(Uint8Array.from([4]),E,t.toBytes(b.y))},fromBytes(e){const s=e.length,l=e[0],b=e.subarray(1);if(s===O&&(l===2||l===3)){const E=m.bytesToNumberBE(b);if(!F(E))throw new Error("Point is not on curve");const A=w(E);let z=t.sqrt(A);const I=(z&U)===U;return(l&1)===1!==I&&(z=t.neg(z)),{x:E,y:z}}else if(s===T&&l===4){const E=t.fromBytes(b.subarray(0,t.BYTES)),A=t.fromBytes(b.subarray(t.BYTES,2*t.BYTES));return{x:E,y:A}}else throw new Error(`Point of length ${s} was invalid. Expected ${O} compressed bytes or ${T} uncompressed bytes`)}}),C=e=>m.bytesToHex(m.numberToBytesBE(e,n.nByteLength));function y(e){const s=x>>U;return e>s}function r(e){return y(e)?R(-e):e}const i=(e,s,l)=>m.bytesToNumberBE(e.slice(s,l));class o{constructor(s,l,b){this.r=s,this.s=l,this.recovery=b,this.assertValidity()}static fromCompact(s){const l=n.nByteLength;return s=m.ensureBytes("compactSignature",s,l*2),new o(i(s,0,l),i(s,l,2*l))}static fromDER(s){const{r:l,s:b}=$.toSig(m.ensureBytes("DER",s));return new o(l,b)}assertValidity(){if(!W(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!W(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(s){return new o(this.r,this.s,s)}recoverPublicKey(s){const{r:l,s:b,recovery:E}=this,A=c(m.ensureBytes("msgHash",s));if(E==null||![0,1,2,3].includes(E))throw new Error("recovery id invalid");const z=E===2||E===3?l+n.n:l;if(z>=t.ORDER)throw new Error("recovery id 2 or 3 invalid");const I=E&1?"03":"02",D=S.fromHex(I+C(z)),j=L(z),X=R(-A*j),J=R(b*j),K=S.BASE.multiplyAndAddUnsafe(D,X,J);if(!K)throw new Error("point at infinify");return K.assertValidity(),K}hasHighS(){return y(this.s)}normalizeS(){return this.hasHighS()?new o(this.r,R(-this.s),this.recovery):this}toDERRawBytes(){return m.hexToBytes(this.toDERHex())}toDERHex(){return $.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return m.hexToBytes(this.toCompactHex())}toCompactHex(){return C(this.r)+C(this.s)}}const u={isValidPrivateKey(e){try{return V(e),!0}catch{return!1}},normPrivateKeyToScalar:V,randomPrivateKey:()=>{const e=n.randomBytes(t.BYTES+8),s=_.hashToPrivateScalar(e,x);return m.numberToBytesBE(s,n.nByteLength)},precompute(e=8,s=S.BASE){return s._setWindowSize(e),s.multiply(BigInt(3)),s}};function f(e,s=!0){return S.fromPrivateKey(e).toRawBytes(s)}function g(e){const s=e instanceof Uint8Array,l=typeof e=="string",b=(s||l)&&e.length;return s?b===O||b===T:l?b===2*O||b===2*T:e instanceof S}function h(e,s,l=!0){if(g(e))throw new Error("first arg must be private key");if(!g(s))throw new Error("second arg must be public key");return S.fromHex(s).multiply(V(e)).toRawBytes(l)}const a=n.bits2int||function(e){const s=m.bytesToNumberBE(e),l=e.length*8-n.nBitLength;return l>0?s>>BigInt(l):s},c=n.bits2int_modN||function(e){return R(a(e))},d=m.bitMask(n.nBitLength);function q(e){if(typeof e!="bigint")throw new Error("bigint expected");if(!(P<=e&&e<d))throw new Error(`bigint expected < 2^${n.nBitLength}`);return m.numberToBytesBE(e,n.nByteLength)}function B(e,s,l=p){if(["recovered","canonical"].some(k=>k in l))throw new Error("sign() legacy options not supported");const{hash:b,randomBytes:E}=n;let{lowS:A,prehash:z,extraEntropy:I}=l;A==null&&(A=!0),e=m.ensureBytes("msgHash",e),z&&(e=m.ensureBytes("prehashed msgHash",b(e)));const D=c(e),j=V(s),X=[q(j),q(D)];if(I!=null){const k=I===!0?E(t.BYTES):I;X.push(m.ensureBytes("extraEntropy",k,t.BYTES))}const J=m.concatBytes(...X),K=D;function tt(k){const G=a(k);if(!W(G))return;const rt=L(G),M=S.BASE.multiply(G).toAffine(),Y=R(M.x);if(Y===P)return;const Q=R(rt*R(K+Y*j));if(Q===P)return;let nt=(M.x===Y?0:2)|Number(M.y&U),st=Q;return A&&y(Q)&&(st=r(Q),nt^=1),new o(Y,st,nt)}return{seed:J,k2sig:tt}}const p={lowS:n.lowS,prehash:!1},N={lowS:n.lowS,prehash:!1};function Z(e,s,l=p){const{seed:b,k2sig:E}=B(e,s,l);return m.createHmacDrbg(n.hash.outputLen,n.nByteLength,n.hmac)(b,E)}S.BASE._setWindowSize(8);function H(e,s,l,b=N){var M;const E=e;if(s=m.ensureBytes("msgHash",s),l=m.ensureBytes("publicKey",l),"strict"in b)throw new Error("options.strict was renamed to lowS");const{lowS:A,prehash:z}=b;let I,D;try{if(typeof E=="string"||E instanceof Uint8Array)try{I=o.fromDER(E)}catch(Y){if(!(Y instanceof $.Err))throw Y;I=o.fromCompact(E)}else if(typeof E=="object"&&typeof E.r=="bigint"&&typeof E.s=="bigint"){const{r:Y,s:Q}=E;I=new o(Y,Q)}else throw new Error("PARSE");D=S.fromHex(l)}catch(Y){if(Y.message==="PARSE")throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(A&&I.hasHighS())return!1;z&&(s=n.hash(s));const{r:j,s:X}=I,J=c(s),K=L(X),tt=R(J*K),k=R(j*K),G=(M=S.BASE.multiplyAndAddUnsafe(D,tt,k))==null?void 0:M.toAffine();return G?R(G.x)===j:!1}return{CURVE:n,getPublicKey:f,getSharedSecret:h,sign:Z,verify:H,ProjectivePoint:S,Signature:o,utils:u}}exports.DER=$;exports.weierstrass=ft;exports.weierstrassPoints=it;
