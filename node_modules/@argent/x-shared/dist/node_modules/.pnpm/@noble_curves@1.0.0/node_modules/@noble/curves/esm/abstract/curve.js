import { validateField as F, nLength as S } from "./modular.js";
import { validateObject as O } from "./utils.js";
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const A = BigInt(0), g = BigInt(1);
function z(i, u) {
  const l = (t, n) => {
    const e = n.negate();
    return t ? e : n;
  }, h = (t) => {
    const n = Math.ceil(u / t) + 1, e = 2 ** (t - 1);
    return { windows: n, windowSize: e };
  };
  return {
    constTimeNegate: l,
    // non-const time multiplication ladder
    unsafeLadder(t, n) {
      let e = i.ZERO, f = t;
      for (; n > A; )
        n & g && (e = e.add(f)), f = f.double(), n >>= g;
      return e;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(ğ‘Šâˆ’1) * (Math.ceil(ğ‘› / ğ‘Š) + 1), where:
     * - ğ‘Š is the window size
     * - ğ‘› is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(t, n) {
      const { windows: e, windowSize: f } = h(n), s = [];
      let o = t, d = o;
      for (let w = 0; w < e; w++) {
        d = o, s.push(d);
        for (let a = 1; a < f; a++)
          d = d.add(o), s.push(d);
        o = d.double();
      }
      return s;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(t, n, e) {
      const { windows: f, windowSize: s } = h(t);
      let o = i.ZERO, d = i.BASE;
      const w = BigInt(2 ** t - 1), a = 2 ** t, b = BigInt(t);
      for (let c = 0; c < f; c++) {
        const p = c * s;
        let r = Number(e & w);
        e >>= b, r > s && (r -= a, e += g);
        const B = p, m = p + Math.abs(r) - 1, I = c % 2 !== 0, N = r < 0;
        r === 0 ? d = d.add(l(I, n[B])) : o = o.add(l(N, n[m]));
      }
      return { p: o, f: d };
    },
    wNAFCached(t, n, e, f) {
      const s = t._WINDOW_SIZE || 1;
      let o = n.get(t);
      return o || (o = this.precomputeWindow(t, s), s !== 1 && n.set(t, f(o))), this.wNAF(s, o, e);
    }
  };
}
function R(i) {
  return F(i.Fp), O(i, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  }), Object.freeze({
    ...S(i.n, i.nBitLength),
    ...i,
    p: i.Fp.ORDER
  });
}
export {
  R as validateBasic,
  z as wNAF
};
