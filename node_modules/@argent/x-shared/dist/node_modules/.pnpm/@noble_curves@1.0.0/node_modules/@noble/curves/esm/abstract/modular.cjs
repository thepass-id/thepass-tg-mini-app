"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const g=require("./utils.cjs");/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const f=BigInt(0),u=BigInt(1),h=BigInt(2),M=BigInt(3),b=BigInt(4),y=BigInt(5),m=BigInt(8);BigInt(9);BigInt(16);function a(e,o){const n=e%o;return n>=f?n:o+n}function T(e,o,n){if(n<=f||o<f)throw new Error("Expected power/modulo > 0");if(n===u)return f;let r=u;for(;o>f;)o&u&&(r=r*e%n),e=e*e%n,o>>=u;return r}function N(e,o){if(e===f||o<=f)throw new Error(`invert: expected positive integers, got n=${e} mod=${o}`);let n=a(e,o),r=o,s=f,c=u;for(;n!==f;){const i=r/n,t=r%n,l=s-c*i;r=n,n=t,s=c,c=l}if(r!==u)throw new Error("invert: does not exist");return a(s,o)}function L(e){const o=(e-u)/h;let n,r,s;for(n=e-u,r=0;n%h===f;n/=h,r++);for(s=h;s<e&&T(s,o,e)!==e-u;s++);if(r===1){const d=(e+u)/b;return function(t,l){const w=t.pow(l,d);if(!t.eql(t.sqr(w),l))throw new Error("Cannot find square root");return w}}const c=(n+u)/h;return function(i,t){if(i.pow(t,o)===i.neg(i.ONE))throw new Error("Cannot find square root");let l=r,w=i.pow(i.mul(i.ONE,s),n),v=i.pow(t,c),q=i.pow(t,n);for(;!i.eql(q,i.ONE);){if(i.eql(q,i.ZERO))return i.ZERO;let B=1;for(let E=i.sqr(q);B<l&&!i.eql(E,i.ONE);B++)E=i.sqr(E);const I=i.pow(w,u<<BigInt(l-B-1));w=i.sqr(I),v=i.mul(v,I),q=i.mul(q,w),l=B}return v}}function x(e){if(e%b===M){const o=(e+u)/b;return function(r,s){const c=r.pow(s,o);if(!r.eql(r.sqr(c),s))throw new Error("Cannot find square root");return c}}if(e%m===y){const o=(e-y)/m;return function(r,s){const c=r.mul(s,h),d=r.pow(c,o),i=r.mul(s,d),t=r.mul(r.mul(i,h),d),l=r.mul(i,r.sub(t,r.ONE));if(!r.eql(r.sqr(l),s))throw new Error("Cannot find square root");return l}}return L(e)}const C=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function j(e){const o={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},n=C.reduce((r,s)=>(r[s]="function",r),o);return g.validateObject(e,n)}function _(e,o,n){if(n<f)throw new Error("Expected power > 0");if(n===f)return e.ONE;if(n===u)return o;let r=e.ONE,s=o;for(;n>f;)n&u&&(r=e.mul(r,s)),s=e.sqr(s),n>>=u;return r}function $(e,o){const n=new Array(o.length),r=o.reduce((c,d,i)=>e.is0(d)?c:(n[i]=c,e.mul(c,d)),e.ONE),s=e.inv(r);return o.reduceRight((c,d,i)=>e.is0(d)?c:(n[i]=e.mul(c,n[i]),e.mul(c,d)),s),n}function S(e,o){const n=o!==void 0?o:e.toString(2).length,r=Math.ceil(n/8);return{nBitLength:n,nByteLength:r}}function k(e,o,n=!1,r={}){if(e<=f)throw new Error(`Expected Fp ORDER > 0, got ${e}`);const{nBitLength:s,nByteLength:c}=S(e,o);if(c>2048)throw new Error("Field lengths over 2048 bytes are not supported");const d=x(e),i=Object.freeze({ORDER:e,BITS:s,BYTES:c,MASK:g.bitMask(s),ZERO:f,ONE:u,create:t=>a(t,e),isValid:t=>{if(typeof t!="bigint")throw new Error(`Invalid field element: expected bigint, got ${typeof t}`);return f<=t&&t<e},is0:t=>t===f,isOdd:t=>(t&u)===u,neg:t=>a(-t,e),eql:(t,l)=>t===l,sqr:t=>a(t*t,e),add:(t,l)=>a(t+l,e),sub:(t,l)=>a(t-l,e),mul:(t,l)=>a(t*l,e),pow:(t,l)=>_(i,t,l),div:(t,l)=>a(t*N(l,e),e),sqrN:t=>t*t,addN:(t,l)=>t+l,subN:(t,l)=>t-l,mulN:(t,l)=>t*l,inv:t=>N(t,e),sqrt:r.sqrt||(t=>d(i,t)),invertBatch:t=>$(i,t),cmov:(t,l,w)=>w?l:t,toBytes:t=>n?g.numberToBytesLE(t,c):g.numberToBytesBE(t,c),fromBytes:t=>{if(t.length!==c)throw new Error(`Fp.fromBytes: expected ${c}, got ${t.length}`);return n?g.bytesToNumberLE(t):g.bytesToNumberBE(t)}});return Object.freeze(i)}function O(e,o,n=!1){e=g.ensureBytes("privateHash",e);const r=e.length,s=S(o).nByteLength+8;if(s<24||r<s||r>1024)throw new Error(`hashToPrivateScalar: expected ${s}-1024 bytes of input, got ${r}`);const c=n?g.bytesToNumberLE(e):g.bytesToNumberBE(e);return a(c,o-u)+u}exports.Field=k;exports.FpInvertBatch=$;exports.FpPow=_;exports.FpSqrt=x;exports.hashToPrivateScalar=O;exports.invert=N;exports.mod=a;exports.nLength=S;exports.pow=T;exports.tonelliShanks=L;exports.validateField=j;
