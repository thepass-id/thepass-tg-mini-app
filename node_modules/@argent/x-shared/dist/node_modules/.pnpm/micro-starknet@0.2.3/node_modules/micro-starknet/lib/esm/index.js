import { keccak_256 as P } from "../../../../../@noble_hashes@1.3.3/node_modules/@noble/hashes/esm/sha3.js";
import { sha256 as B } from "../../../../../@noble_hashes@1.3.3/node_modules/@noble/hashes/esm/sha256.js";
import { utf8ToBytes as S } from "../../../../../@noble_hashes@1.3.3/node_modules/@noble/hashes/esm/utils.js";
import { mod as h, Field as l, validateField as b } from "../../../../../@noble_curves@1.0.0/node_modules/@noble/curves/esm/abstract/modular.js";
import { poseidon as R } from "../../../../../@noble_curves@1.0.0/node_modules/@noble/curves/esm/abstract/poseidon.js";
import { weierstrass as N } from "../../../../../@noble_curves@1.0.0/node_modules/@noble/curves/esm/abstract/weierstrass.js";
import { bytesToNumberBE as c, ensureBytes as x, hexToBytes as F, bytesToHex as v, bitMask as T } from "../../../../../@noble_curves@1.0.0/node_modules/@noble/curves/esm/abstract/utils.js";
import { getHash as _ } from "../../../../../@noble_curves@1.0.0/node_modules/@noble/curves/esm/_shortw_utils.js";
const d = BigInt("3618502788666131213697322783095070105526743751716087489154079457884512865583"), w = 252;
function m(n) {
  for (; n[0] === 0; )
    n = n.subarray(1);
  const e = n.length * 8 - w, t = c(n);
  return e > 0 ? t >> BigInt(e) : t;
}
function I(n) {
  return typeof n == "string" && (n = k(n), n.length & 1 && (n = "0" + n)), F(n);
}
const E = N({
  a: BigInt(1),
  b: BigInt("3141592653589793238462643383279502884197169399375105820974944592307816406665"),
  Fp: l(BigInt("0x800000000000011000000000000000000000000000000000000000000000001")),
  n: d,
  nBitLength: w,
  Gx: BigInt("874739451078007766457464989774322083649278607533249481151382481072868806602"),
  Gy: BigInt("152666792071518830868575557812948353041420400780739481342941381225525861407"),
  h: BigInt(1),
  lowS: !1,
  ..._(B),
  bits2int: m,
  bits2int_modN: (n) => {
    const e = c(n).toString(16);
    return e.length === 63 && (n = I(e + "0")), h(m(n), d);
  }
});
function $(n) {
  return x("", typeof n == "string" ? I(n) : n);
}
const { ProjectivePoint: s } = E;
function D(n) {
  return `0x${v(n.subarray(1)).replace(/^0+/gm, "")}`;
}
function k(n) {
  return n.replace(/^0x/i, "");
}
const u = [
  new s(2089986280348253421170679821480865132823066470938446095505822317253594081284n, 1713931329540660377023406109199410414810705867260802078187082345529207694986n, 1n),
  new s(996781205833008774514500082376783249102396023663454813447423147977397232763n, 1668503676786377725805489344771023921079126552019160156920634619255970485781n, 1n),
  new s(2251563274489750535117886426533222435294046428347329203627021249169616184184n, 1798716007562728905295480679789526322175868328062420237419143593021674992973n, 1n),
  new s(2138414695194151160943305727036575959195309218611738193261179310511854807447n, 113410276730064486255102093846540133784865286929052426931474106396135072156n, 1n),
  new s(2379962749567351885752724891227938183011949129833673362440656643086021394946n, 776496453633298175483985398648758586525933812536653089401905292063708816422n, 1n)
];
function y(n, e) {
  const t = [];
  let r = n;
  for (let o = 0; o < 248; o++)
    t.push(r), r = r.double();
  r = e;
  for (let o = 0; o < 4; o++)
    t.push(r), r = r.double();
  return t;
}
const A = y(u[1], u[2]), C = y(u[3], u[4]);
function O(n) {
  let e;
  if (typeof n == "bigint")
    e = n;
  else if (typeof n == "number") {
    if (!Number.isSafeInteger(n))
      throw new Error(`Invalid pedersenArg: ${n}`);
    e = BigInt(n);
  } else
    e = c($(n));
  if (!(0n <= e && e < E.CURVE.Fp.ORDER))
    throw new Error(`PedersenArg should be 0 <= value < CURVE.P: ${e}`);
  return e;
}
function g(n, e, t) {
  let r = O(e);
  for (let o = 0; o < 252; o++) {
    const i = t[o];
    if (i.equals(n))
      throw new Error("Same point");
    (r & 1n) !== 0n && (n = n.add(i)), r >>= 1n;
  }
  return n;
}
function Q(n, e) {
  let t = u[0];
  return t = g(t, n, A), t = g(t, e, C), D(t.toRawBytes(!0));
}
const M = T(250), Y = (n) => c(P(n)) & M;
l(BigInt("14474011154664525231415395255581126252639794253786371766033694892385558855681"));
const j = l(BigInt("3618502788666131213697322783095070105623107215331596699973092056135872020481"));
function H(n, e, t) {
  const r = n.fromBytes(B(S(`${e}${t}`)));
  return n.create(r);
}
const L = [
  [3, 1, 1],
  [1, -1, 1],
  [1, 1, -2]
].map((n) => n.map(BigInt));
function U(n, e) {
  if (b(n.Fp), !Number.isSafeInteger(n.rate) || !Number.isSafeInteger(n.capacity))
    throw new Error(`Wrong poseidon opts: ${n}`);
  const t = n.rate + n.capacity, r = n.roundsFull + n.roundsPartial, o = [];
  for (let a = 0; a < r; a++) {
    const p = [];
    for (let f = 0; f < t; f++)
      p.push(H(n.Fp, "Hades", t * a + f));
    o.push(p);
  }
  const i = R({
    ...n,
    t,
    sboxPower: 3,
    reversePartialPowIdx: !0,
    mds: e,
    roundConstants: o
  });
  return i.m = t, i.rate = n.rate, i.capacity = n.capacity, i;
}
U({ Fp: j, rate: 2, capacity: 1, roundsFull: 8, roundsPartial: 83 }, L);
export {
  j as Fp251,
  s as ProjectivePoint,
  Y as keccak,
  Q as pedersen,
  U as poseidonBasic
};
