import { __module as M } from "../../../../../_virtual/semver2.js";
var J;
function Ue() {
  return J ? M.exports : (J = 1, function(K, l) {
    l = K.exports = f;
    var I;
    typeof process == "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? I = function() {
      var e = Array.prototype.slice.call(arguments, 0);
      e.unshift("SEMVER"), console.log.apply(console, e);
    } : I = function() {
    }, l.SEMVER_SPEC_VERSION = "2.0.0";
    var y = 256, G = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991, $ = 16, Q = y - 6, D = l.re = [], h = l.safeRe = [], s = l.src = [], n = l.tokens = {}, k = 0;
    function R(e) {
      n[e] = k++;
    }
    var B = "[a-zA-Z0-9-]", V = [
      ["\\s", 1],
      ["\\d", y],
      [B, Q]
    ];
    function g(e) {
      for (var r = 0; r < V.length; r++) {
        var t = V[r][0], i = V[r][1];
        e = e.split(t + "*").join(t + "{0," + i + "}").split(t + "+").join(t + "{1," + i + "}");
      }
      return e;
    }
    R("NUMERICIDENTIFIER"), s[n.NUMERICIDENTIFIER] = "0|[1-9]\\d*", R("NUMERICIDENTIFIERLOOSE"), s[n.NUMERICIDENTIFIERLOOSE] = "\\d+", R("NONNUMERICIDENTIFIER"), s[n.NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-]" + B + "*", R("MAINVERSION"), s[n.MAINVERSION] = "(" + s[n.NUMERICIDENTIFIER] + ")\\.(" + s[n.NUMERICIDENTIFIER] + ")\\.(" + s[n.NUMERICIDENTIFIER] + ")", R("MAINVERSIONLOOSE"), s[n.MAINVERSIONLOOSE] = "(" + s[n.NUMERICIDENTIFIERLOOSE] + ")\\.(" + s[n.NUMERICIDENTIFIERLOOSE] + ")\\.(" + s[n.NUMERICIDENTIFIERLOOSE] + ")", R("PRERELEASEIDENTIFIER"), s[n.PRERELEASEIDENTIFIER] = "(?:" + s[n.NUMERICIDENTIFIER] + "|" + s[n.NONNUMERICIDENTIFIER] + ")", R("PRERELEASEIDENTIFIERLOOSE"), s[n.PRERELEASEIDENTIFIERLOOSE] = "(?:" + s[n.NUMERICIDENTIFIERLOOSE] + "|" + s[n.NONNUMERICIDENTIFIER] + ")", R("PRERELEASE"), s[n.PRERELEASE] = "(?:-(" + s[n.PRERELEASEIDENTIFIER] + "(?:\\." + s[n.PRERELEASEIDENTIFIER] + ")*))", R("PRERELEASELOOSE"), s[n.PRERELEASELOOSE] = "(?:-?(" + s[n.PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + s[n.PRERELEASEIDENTIFIERLOOSE] + ")*))", R("BUILDIDENTIFIER"), s[n.BUILDIDENTIFIER] = B + "+", R("BUILD"), s[n.BUILD] = "(?:\\+(" + s[n.BUILDIDENTIFIER] + "(?:\\." + s[n.BUILDIDENTIFIER] + ")*))", R("FULL"), R("FULLPLAIN"), s[n.FULLPLAIN] = "v?" + s[n.MAINVERSION] + s[n.PRERELEASE] + "?" + s[n.BUILD] + "?", s[n.FULL] = "^" + s[n.FULLPLAIN] + "$", R("LOOSEPLAIN"), s[n.LOOSEPLAIN] = "[v=\\s]*" + s[n.MAINVERSIONLOOSE] + s[n.PRERELEASELOOSE] + "?" + s[n.BUILD] + "?", R("LOOSE"), s[n.LOOSE] = "^" + s[n.LOOSEPLAIN] + "$", R("GTLT"), s[n.GTLT] = "((?:<|>)?=?)", R("XRANGEIDENTIFIERLOOSE"), s[n.XRANGEIDENTIFIERLOOSE] = s[n.NUMERICIDENTIFIERLOOSE] + "|x|X|\\*", R("XRANGEIDENTIFIER"), s[n.XRANGEIDENTIFIER] = s[n.NUMERICIDENTIFIER] + "|x|X|\\*", R("XRANGEPLAIN"), s[n.XRANGEPLAIN] = "[v=\\s]*(" + s[n.XRANGEIDENTIFIER] + ")(?:\\.(" + s[n.XRANGEIDENTIFIER] + ")(?:\\.(" + s[n.XRANGEIDENTIFIER] + ")(?:" + s[n.PRERELEASE] + ")?" + s[n.BUILD] + "?)?)?", R("XRANGEPLAINLOOSE"), s[n.XRANGEPLAINLOOSE] = "[v=\\s]*(" + s[n.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + s[n.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + s[n.XRANGEIDENTIFIERLOOSE] + ")(?:" + s[n.PRERELEASELOOSE] + ")?" + s[n.BUILD] + "?)?)?", R("XRANGE"), s[n.XRANGE] = "^" + s[n.GTLT] + "\\s*" + s[n.XRANGEPLAIN] + "$", R("XRANGELOOSE"), s[n.XRANGELOOSE] = "^" + s[n.GTLT] + "\\s*" + s[n.XRANGEPLAINLOOSE] + "$", R("COERCE"), s[n.COERCE] = "(^|[^\\d])(\\d{1," + $ + "})(?:\\.(\\d{1," + $ + "}))?(?:\\.(\\d{1," + $ + "}))?(?:$|[^\\d])", R("COERCERTL"), D[n.COERCERTL] = new RegExp(s[n.COERCE], "g"), h[n.COERCERTL] = new RegExp(g(s[n.COERCE]), "g"), R("LONETILDE"), s[n.LONETILDE] = "(?:~>?)", R("TILDETRIM"), s[n.TILDETRIM] = "(\\s*)" + s[n.LONETILDE] + "\\s+", D[n.TILDETRIM] = new RegExp(s[n.TILDETRIM], "g"), h[n.TILDETRIM] = new RegExp(g(s[n.TILDETRIM]), "g");
    var W = "$1~";
    R("TILDE"), s[n.TILDE] = "^" + s[n.LONETILDE] + s[n.XRANGEPLAIN] + "$", R("TILDELOOSE"), s[n.TILDELOOSE] = "^" + s[n.LONETILDE] + s[n.XRANGEPLAINLOOSE] + "$", R("LONECARET"), s[n.LONECARET] = "(?:\\^)", R("CARETTRIM"), s[n.CARETTRIM] = "(\\s*)" + s[n.LONECARET] + "\\s+", D[n.CARETTRIM] = new RegExp(s[n.CARETTRIM], "g"), h[n.CARETTRIM] = new RegExp(g(s[n.CARETTRIM]), "g");
    var x = "$1^";
    R("CARET"), s[n.CARET] = "^" + s[n.LONECARET] + s[n.XRANGEPLAIN] + "$", R("CARETLOOSE"), s[n.CARETLOOSE] = "^" + s[n.LONECARET] + s[n.XRANGEPLAINLOOSE] + "$", R("COMPARATORLOOSE"), s[n.COMPARATORLOOSE] = "^" + s[n.GTLT] + "\\s*(" + s[n.LOOSEPLAIN] + ")$|^$", R("COMPARATOR"), s[n.COMPARATOR] = "^" + s[n.GTLT] + "\\s*(" + s[n.FULLPLAIN] + ")$|^$", R("COMPARATORTRIM"), s[n.COMPARATORTRIM] = "(\\s*)" + s[n.GTLT] + "\\s*(" + s[n.LOOSEPLAIN] + "|" + s[n.XRANGEPLAIN] + ")", D[n.COMPARATORTRIM] = new RegExp(s[n.COMPARATORTRIM], "g"), h[n.COMPARATORTRIM] = new RegExp(g(s[n.COMPARATORTRIM]), "g");
    var ee = "$1$2$3";
    R("HYPHENRANGE"), s[n.HYPHENRANGE] = "^\\s*(" + s[n.XRANGEPLAIN] + ")\\s+-\\s+(" + s[n.XRANGEPLAIN] + ")\\s*$", R("HYPHENRANGELOOSE"), s[n.HYPHENRANGELOOSE] = "^\\s*(" + s[n.XRANGEPLAINLOOSE] + ")\\s+-\\s+(" + s[n.XRANGEPLAINLOOSE] + ")\\s*$", R("STAR"), s[n.STAR] = "(<|>)?=?\\s*\\*";
    for (var S = 0; S < k; S++)
      I(S, s[S]), D[S] || (D[S] = new RegExp(s[S]), h[S] = new RegExp(g(s[S])));
    l.parse = w;
    function w(e, r) {
      if ((!r || typeof r != "object") && (r = {
        loose: !!r,
        includePrerelease: !1
      }), e instanceof f)
        return e;
      if (typeof e != "string" || e.length > y)
        return null;
      var t = r.loose ? h[n.LOOSE] : h[n.FULL];
      if (!t.test(e))
        return null;
      try {
        return new f(e, r);
      } catch {
        return null;
      }
    }
    l.valid = re;
    function re(e, r) {
      var t = w(e, r);
      return t ? t.version : null;
    }
    l.clean = te;
    function te(e, r) {
      var t = w(e.trim().replace(/^[=v]+/, ""), r);
      return t ? t.version : null;
    }
    l.SemVer = f;
    function f(e, r) {
      if ((!r || typeof r != "object") && (r = {
        loose: !!r,
        includePrerelease: !1
      }), e instanceof f) {
        if (e.loose === r.loose)
          return e;
        e = e.version;
      } else if (typeof e != "string")
        throw new TypeError("Invalid Version: " + e);
      if (e.length > y)
        throw new TypeError("version is longer than " + y + " characters");
      if (!(this instanceof f))
        return new f(e, r);
      I("SemVer", e, r), this.options = r, this.loose = !!r.loose;
      var t = e.trim().match(r.loose ? h[n.LOOSE] : h[n.FULL]);
      if (!t)
        throw new TypeError("Invalid Version: " + e);
      if (this.raw = e, this.major = +t[1], this.minor = +t[2], this.patch = +t[3], this.major > G || this.major < 0)
        throw new TypeError("Invalid major version");
      if (this.minor > G || this.minor < 0)
        throw new TypeError("Invalid minor version");
      if (this.patch > G || this.patch < 0)
        throw new TypeError("Invalid patch version");
      t[4] ? this.prerelease = t[4].split(".").map(function(i) {
        if (/^[0-9]+$/.test(i)) {
          var a = +i;
          if (a >= 0 && a < G)
            return a;
        }
        return i;
      }) : this.prerelease = [], this.build = t[5] ? t[5].split(".") : [], this.format();
    }
    f.prototype.format = function() {
      return this.version = this.major + "." + this.minor + "." + this.patch, this.prerelease.length && (this.version += "-" + this.prerelease.join(".")), this.version;
    }, f.prototype.toString = function() {
      return this.version;
    }, f.prototype.compare = function(e) {
      return I("SemVer.compare", this.version, this.options, e), e instanceof f || (e = new f(e, this.options)), this.compareMain(e) || this.comparePre(e);
    }, f.prototype.compareMain = function(e) {
      return e instanceof f || (e = new f(e, this.options)), d(this.major, e.major) || d(this.minor, e.minor) || d(this.patch, e.patch);
    }, f.prototype.comparePre = function(e) {
      if (e instanceof f || (e = new f(e, this.options)), this.prerelease.length && !e.prerelease.length)
        return -1;
      if (!this.prerelease.length && e.prerelease.length)
        return 1;
      if (!this.prerelease.length && !e.prerelease.length)
        return 0;
      var r = 0;
      do {
        var t = this.prerelease[r], i = e.prerelease[r];
        if (I("prerelease compare", r, t, i), t === void 0 && i === void 0)
          return 0;
        if (i === void 0)
          return 1;
        if (t === void 0)
          return -1;
        if (t === i)
          continue;
        return d(t, i);
      } while (++r);
    }, f.prototype.compareBuild = function(e) {
      e instanceof f || (e = new f(e, this.options));
      var r = 0;
      do {
        var t = this.build[r], i = e.build[r];
        if (I("prerelease compare", r, t, i), t === void 0 && i === void 0)
          return 0;
        if (i === void 0)
          return 1;
        if (t === void 0)
          return -1;
        if (t === i)
          continue;
        return d(t, i);
      } while (++r);
    }, f.prototype.inc = function(e, r) {
      switch (e) {
        case "premajor":
          this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", r);
          break;
        case "preminor":
          this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", r);
          break;
        case "prepatch":
          this.prerelease.length = 0, this.inc("patch", r), this.inc("pre", r);
          break;
        // If the input is a non-prerelease version, this acts the same as
        // prepatch.
        case "prerelease":
          this.prerelease.length === 0 && this.inc("patch", r), this.inc("pre", r);
          break;
        case "major":
          (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
          break;
        case "minor":
          (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
          break;
        case "patch":
          this.prerelease.length === 0 && this.patch++, this.prerelease = [];
          break;
        // This probably shouldn't be used publicly.
        // 1.0.0 "pre" would become 1.0.0-0 which is the wrong direction.
        case "pre":
          if (this.prerelease.length === 0)
            this.prerelease = [0];
          else {
            for (var t = this.prerelease.length; --t >= 0; )
              typeof this.prerelease[t] == "number" && (this.prerelease[t]++, t = -2);
            t === -1 && this.prerelease.push(0);
          }
          r && (this.prerelease[0] === r ? isNaN(this.prerelease[1]) && (this.prerelease = [r, 0]) : this.prerelease = [r, 0]);
          break;
        default:
          throw new Error("invalid increment argument: " + e);
      }
      return this.format(), this.raw = this.version, this;
    }, l.inc = ne;
    function ne(e, r, t, i) {
      typeof t == "string" && (i = t, t = void 0);
      try {
        return new f(e, t).inc(r, i).version;
      } catch {
        return null;
      }
    }
    l.diff = ie;
    function ie(e, r) {
      if (_(e, r))
        return null;
      var t = w(e), i = w(r), a = "";
      if (t.prerelease.length || i.prerelease.length) {
        a = "pre";
        var E = "prerelease";
      }
      for (var u in t)
        if ((u === "major" || u === "minor" || u === "patch") && t[u] !== i[u])
          return a + u;
      return E;
    }
    l.compareIdentifiers = d;
    var Y = /^[0-9]+$/;
    function d(e, r) {
      var t = Y.test(e), i = Y.test(r);
      return t && i && (e = +e, r = +r), e === r ? 0 : t && !i ? -1 : i && !t ? 1 : e < r ? -1 : 1;
    }
    l.rcompareIdentifiers = se;
    function se(e, r) {
      return d(r, e);
    }
    l.major = ae;
    function ae(e, r) {
      return new f(e, r).major;
    }
    l.minor = Ee;
    function Ee(e, r) {
      return new f(e, r).minor;
    }
    l.patch = ue;
    function ue(e, r) {
      return new f(e, r).patch;
    }
    l.compare = m;
    function m(e, r, t) {
      return new f(e, t).compare(new f(r, t));
    }
    l.compareLoose = le;
    function le(e, r) {
      return m(e, r, !0);
    }
    l.compareBuild = fe;
    function fe(e, r, t) {
      var i = new f(e, t), a = new f(r, t);
      return i.compare(a) || i.compareBuild(a);
    }
    l.rcompare = ce;
    function ce(e, r, t) {
      return m(r, e, t);
    }
    l.sort = Re;
    function Re(e, r) {
      return e.sort(function(t, i) {
        return l.compareBuild(t, i, r);
      });
    }
    l.rsort = oe;
    function oe(e, r) {
      return e.sort(function(t, i) {
        return l.compareBuild(i, t, r);
      });
    }
    l.gt = F;
    function F(e, r, t) {
      return m(e, r, t) > 0;
    }
    l.lt = X;
    function X(e, r, t) {
      return m(e, r, t) < 0;
    }
    l.eq = _;
    function _(e, r, t) {
      return m(e, r, t) === 0;
    }
    l.neq = z;
    function z(e, r, t) {
      return m(e, r, t) !== 0;
    }
    l.gte = H;
    function H(e, r, t) {
      return m(e, r, t) >= 0;
    }
    l.lte = b;
    function b(e, r, t) {
      return m(e, r, t) <= 0;
    }
    l.cmp = U;
    function U(e, r, t, i) {
      switch (r) {
        case "===":
          return typeof e == "object" && (e = e.version), typeof t == "object" && (t = t.version), e === t;
        case "!==":
          return typeof e == "object" && (e = e.version), typeof t == "object" && (t = t.version), e !== t;
        case "":
        case "=":
        case "==":
          return _(e, t, i);
        case "!=":
          return z(e, t, i);
        case ">":
          return F(e, t, i);
        case ">=":
          return H(e, t, i);
        case "<":
          return X(e, t, i);
        case "<=":
          return b(e, t, i);
        default:
          throw new TypeError("Invalid operator: " + r);
      }
    }
    l.Comparator = T;
    function T(e, r) {
      if ((!r || typeof r != "object") && (r = {
        loose: !!r,
        includePrerelease: !1
      }), e instanceof T) {
        if (e.loose === !!r.loose)
          return e;
        e = e.value;
      }
      if (!(this instanceof T))
        return new T(e, r);
      e = e.trim().split(/\s+/).join(" "), I("comparator", e, r), this.options = r, this.loose = !!r.loose, this.parse(e), this.semver === P ? this.value = "" : this.value = this.operator + this.semver.version, I("comp", this);
    }
    var P = {};
    T.prototype.parse = function(e) {
      var r = this.options.loose ? h[n.COMPARATORLOOSE] : h[n.COMPARATOR], t = e.match(r);
      if (!t)
        throw new TypeError("Invalid comparator: " + e);
      this.operator = t[1] !== void 0 ? t[1] : "", this.operator === "=" && (this.operator = ""), t[2] ? this.semver = new f(t[2], this.options.loose) : this.semver = P;
    }, T.prototype.toString = function() {
      return this.value;
    }, T.prototype.test = function(e) {
      if (I("Comparator.test", e, this.options.loose), this.semver === P || e === P)
        return !0;
      if (typeof e == "string")
        try {
          e = new f(e, this.options);
        } catch {
          return !1;
        }
      return U(e, this.operator, this.semver, this.options);
    }, T.prototype.intersects = function(e, r) {
      if (!(e instanceof T))
        throw new TypeError("a Comparator is required");
      (!r || typeof r != "object") && (r = {
        loose: !!r,
        includePrerelease: !1
      });
      var t;
      if (this.operator === "")
        return this.value === "" ? !0 : (t = new O(e.value, r), j(this.value, t, r));
      if (e.operator === "")
        return e.value === "" ? !0 : (t = new O(this.value, r), j(e.semver, t, r));
      var i = (this.operator === ">=" || this.operator === ">") && (e.operator === ">=" || e.operator === ">"), a = (this.operator === "<=" || this.operator === "<") && (e.operator === "<=" || e.operator === "<"), E = this.semver.version === e.semver.version, u = (this.operator === ">=" || this.operator === "<=") && (e.operator === ">=" || e.operator === "<="), o = U(this.semver, "<", e.semver, r) && (this.operator === ">=" || this.operator === ">") && (e.operator === "<=" || e.operator === "<"), c = U(this.semver, ">", e.semver, r) && (this.operator === "<=" || this.operator === "<") && (e.operator === ">=" || e.operator === ">");
      return i || a || E && u || o || c;
    }, l.Range = O;
    function O(e, r) {
      if ((!r || typeof r != "object") && (r = {
        loose: !!r,
        includePrerelease: !1
      }), e instanceof O)
        return e.loose === !!r.loose && e.includePrerelease === !!r.includePrerelease ? e : new O(e.raw, r);
      if (e instanceof T)
        return new O(e.value, r);
      if (!(this instanceof O))
        return new O(e, r);
      if (this.options = r, this.loose = !!r.loose, this.includePrerelease = !!r.includePrerelease, this.raw = e.trim().split(/\s+/).join(" "), this.set = this.raw.split("||").map(function(t) {
        return this.parseRange(t.trim());
      }, this).filter(function(t) {
        return t.length;
      }), !this.set.length)
        throw new TypeError("Invalid SemVer Range: " + this.raw);
      this.format();
    }
    O.prototype.format = function() {
      return this.range = this.set.map(function(e) {
        return e.join(" ").trim();
      }).join("||").trim(), this.range;
    }, O.prototype.toString = function() {
      return this.range;
    }, O.prototype.parseRange = function(e) {
      var r = this.options.loose, t = r ? h[n.HYPHENRANGELOOSE] : h[n.HYPHENRANGE];
      e = e.replace(t, Se), I("hyphen replace", e), e = e.replace(h[n.COMPARATORTRIM], ee), I("comparator trim", e, h[n.COMPARATORTRIM]), e = e.replace(h[n.TILDETRIM], W), e = e.replace(h[n.CARETTRIM], x), e = e.split(/\s+/).join(" ");
      var i = r ? h[n.COMPARATORLOOSE] : h[n.COMPARATOR], a = e.split(" ").map(function(E) {
        return he(E, this.options);
      }, this).join(" ").split(/\s+/);
      return this.options.loose && (a = a.filter(function(E) {
        return !!E.match(i);
      })), a = a.map(function(E) {
        return new T(E, this.options);
      }, this), a;
    }, O.prototype.intersects = function(e, r) {
      if (!(e instanceof O))
        throw new TypeError("a Range is required");
      return this.set.some(function(t) {
        return Z(t, r) && e.set.some(function(i) {
          return Z(i, r) && t.every(function(a) {
            return i.every(function(E) {
              return a.intersects(E, r);
            });
          });
        });
      });
    };
    function Z(e, r) {
      for (var t = !0, i = e.slice(), a = i.pop(); t && i.length; )
        t = i.every(function(E) {
          return a.intersects(E, r);
        }), a = i.pop();
      return t;
    }
    l.toComparators = Ie;
    function Ie(e, r) {
      return new O(e, r).set.map(function(t) {
        return t.map(function(i) {
          return i.value;
        }).join(" ").trim().split(" ");
      });
    }
    function he(e, r) {
      return I("comp", e, r), e = Ne(e, r), I("caret", e), e = Oe(e, r), I("tildes", e), e = Ae(e, r), I("xrange", e), e = ve(e, r), I("stars", e), e;
    }
    function L(e) {
      return !e || e.toLowerCase() === "x" || e === "*";
    }
    function Oe(e, r) {
      return e.trim().split(/\s+/).map(function(t) {
        return Le(t, r);
      }).join(" ");
    }
    function Le(e, r) {
      var t = r.loose ? h[n.TILDELOOSE] : h[n.TILDE];
      return e.replace(t, function(i, a, E, u, o) {
        I("tilde", e, i, a, E, u, o);
        var c;
        return L(a) ? c = "" : L(E) ? c = ">=" + a + ".0.0 <" + (+a + 1) + ".0.0" : L(u) ? c = ">=" + a + "." + E + ".0 <" + a + "." + (+E + 1) + ".0" : o ? (I("replaceTilde pr", o), c = ">=" + a + "." + E + "." + u + "-" + o + " <" + a + "." + (+E + 1) + ".0") : c = ">=" + a + "." + E + "." + u + " <" + a + "." + (+E + 1) + ".0", I("tilde return", c), c;
      });
    }
    function Ne(e, r) {
      return e.trim().split(/\s+/).map(function(t) {
        return Te(t, r);
      }).join(" ");
    }
    function Te(e, r) {
      I("caret", e, r);
      var t = r.loose ? h[n.CARETLOOSE] : h[n.CARET];
      return e.replace(t, function(i, a, E, u, o) {
        I("caret", e, i, a, E, u, o);
        var c;
        return L(a) ? c = "" : L(E) ? c = ">=" + a + ".0.0 <" + (+a + 1) + ".0.0" : L(u) ? a === "0" ? c = ">=" + a + "." + E + ".0 <" + a + "." + (+E + 1) + ".0" : c = ">=" + a + "." + E + ".0 <" + (+a + 1) + ".0.0" : o ? (I("replaceCaret pr", o), a === "0" ? E === "0" ? c = ">=" + a + "." + E + "." + u + "-" + o + " <" + a + "." + E + "." + (+u + 1) : c = ">=" + a + "." + E + "." + u + "-" + o + " <" + a + "." + (+E + 1) + ".0" : c = ">=" + a + "." + E + "." + u + "-" + o + " <" + (+a + 1) + ".0.0") : (I("no pr"), a === "0" ? E === "0" ? c = ">=" + a + "." + E + "." + u + " <" + a + "." + E + "." + (+u + 1) : c = ">=" + a + "." + E + "." + u + " <" + a + "." + (+E + 1) + ".0" : c = ">=" + a + "." + E + "." + u + " <" + (+a + 1) + ".0.0"), I("caret return", c), c;
      });
    }
    function Ae(e, r) {
      return I("replaceXRanges", e, r), e.split(/\s+/).map(function(t) {
        return pe(t, r);
      }).join(" ");
    }
    function pe(e, r) {
      e = e.trim();
      var t = r.loose ? h[n.XRANGELOOSE] : h[n.XRANGE];
      return e.replace(t, function(i, a, E, u, o, c) {
        I("xRange", e, i, a, E, u, o, c);
        var p = L(E), v = p || L(u), A = v || L(o), N = A;
        return a === "=" && N && (a = ""), c = r.includePrerelease ? "-0" : "", p ? a === ">" || a === "<" ? i = "<0.0.0-0" : i = "*" : a && N ? (v && (u = 0), o = 0, a === ">" ? (a = ">=", v ? (E = +E + 1, u = 0, o = 0) : (u = +u + 1, o = 0)) : a === "<=" && (a = "<", v ? E = +E + 1 : u = +u + 1), i = a + E + "." + u + "." + o + c) : v ? i = ">=" + E + ".0.0" + c + " <" + (+E + 1) + ".0.0" + c : A && (i = ">=" + E + "." + u + ".0" + c + " <" + E + "." + (+u + 1) + ".0" + c), I("xRange return", i), i;
      });
    }
    function ve(e, r) {
      return I("replaceStars", e, r), e.trim().replace(h[n.STAR], "");
    }
    function Se(e, r, t, i, a, E, u, o, c, p, v, A, N) {
      return L(t) ? r = "" : L(i) ? r = ">=" + t + ".0.0" : L(a) ? r = ">=" + t + "." + i + ".0" : r = ">=" + r, L(c) ? o = "" : L(p) ? o = "<" + (+c + 1) + ".0.0" : L(v) ? o = "<" + c + "." + (+p + 1) + ".0" : A ? o = "<=" + c + "." + p + "." + v + "-" + A : o = "<=" + o, (r + " " + o).trim();
    }
    O.prototype.test = function(e) {
      if (!e)
        return !1;
      if (typeof e == "string")
        try {
          e = new f(e, this.options);
        } catch {
          return !1;
        }
      for (var r = 0; r < this.set.length; r++)
        if (me(this.set[r], e, this.options))
          return !0;
      return !1;
    };
    function me(e, r, t) {
      for (var i = 0; i < e.length; i++)
        if (!e[i].test(r))
          return !1;
      if (r.prerelease.length && !t.includePrerelease) {
        for (i = 0; i < e.length; i++)
          if (I(e[i].semver), e[i].semver !== P && e[i].semver.prerelease.length > 0) {
            var a = e[i].semver;
            if (a.major === r.major && a.minor === r.minor && a.patch === r.patch)
              return !0;
          }
        return !1;
      }
      return !0;
    }
    l.satisfies = j;
    function j(e, r, t) {
      try {
        r = new O(r, t);
      } catch {
        return !1;
      }
      return r.test(e);
    }
    l.maxSatisfying = Ce;
    function Ce(e, r, t) {
      var i = null, a = null;
      try {
        var E = new O(r, t);
      } catch {
        return null;
      }
      return e.forEach(function(u) {
        E.test(u) && (!i || a.compare(u) === -1) && (i = u, a = new f(i, t));
      }), i;
    }
    l.minSatisfying = we;
    function we(e, r, t) {
      var i = null, a = null;
      try {
        var E = new O(r, t);
      } catch {
        return null;
      }
      return e.forEach(function(u) {
        E.test(u) && (!i || a.compare(u) === 1) && (i = u, a = new f(i, t));
      }), i;
    }
    l.minVersion = de;
    function de(e, r) {
      e = new O(e, r);
      var t = new f("0.0.0");
      if (e.test(t) || (t = new f("0.0.0-0"), e.test(t)))
        return t;
      t = null;
      for (var i = 0; i < e.set.length; ++i) {
        var a = e.set[i];
        a.forEach(function(E) {
          var u = new f(E.semver.version);
          switch (E.operator) {
            case ">":
              u.prerelease.length === 0 ? u.patch++ : u.prerelease.push(0), u.raw = u.format();
            /* fallthrough */
            case "":
            case ">=":
              (!t || F(t, u)) && (t = u);
              break;
            case "<":
            case "<=":
              break;
            /* istanbul ignore next */
            default:
              throw new Error("Unexpected operation: " + E.operator);
          }
        });
      }
      return t && e.test(t) ? t : null;
    }
    l.validRange = De;
    function De(e, r) {
      try {
        return new O(e, r).range || "*";
      } catch {
        return null;
      }
    }
    l.ltr = Pe;
    function Pe(e, r, t) {
      return q(e, r, "<", t);
    }
    l.gtr = ye;
    function ye(e, r, t) {
      return q(e, r, ">", t);
    }
    l.outside = q;
    function q(e, r, t, i) {
      e = new f(e, i), r = new O(r, i);
      var a, E, u, o, c;
      switch (t) {
        case ">":
          a = F, E = b, u = X, o = ">", c = ">=";
          break;
        case "<":
          a = X, E = H, u = F, o = "<", c = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (j(e, r, i))
        return !1;
      for (var p = 0; p < r.set.length; ++p) {
        var v = r.set[p], A = null, N = null;
        if (v.forEach(function(C) {
          C.semver === P && (C = new T(">=0.0.0")), A = A || C, N = N || C, a(C.semver, A.semver, i) ? A = C : u(C.semver, N.semver, i) && (N = C);
        }), A.operator === o || A.operator === c || (!N.operator || N.operator === o) && E(e, N.semver))
          return !1;
        if (N.operator === c && u(e, N.semver))
          return !1;
      }
      return !0;
    }
    l.prerelease = ge;
    function ge(e, r) {
      var t = w(e, r);
      return t && t.prerelease.length ? t.prerelease : null;
    }
    l.intersects = Fe;
    function Fe(e, r, t) {
      return e = new O(e, t), r = new O(r, t), e.intersects(r);
    }
    l.coerce = Ge;
    function Ge(e, r) {
      if (e instanceof f)
        return e;
      if (typeof e == "number" && (e = String(e)), typeof e != "string")
        return null;
      r = r || {};
      var t = null;
      if (!r.rtl)
        t = e.match(h[n.COERCE]);
      else {
        for (var i; (i = h[n.COERCERTL].exec(e)) && (!t || t.index + t[0].length !== e.length); )
          (!t || i.index + i[0].length !== t.index + t[0].length) && (t = i), h[n.COERCERTL].lastIndex = i.index + i[1].length + i[2].length;
        h[n.COERCERTL].lastIndex = -1;
      }
      return t === null ? null : w(t[2] + "." + (t[3] || "0") + "." + (t[4] || "0"), r);
    }
  }(M, M.exports), M.exports);
}
export {
  Ue as __require
};
