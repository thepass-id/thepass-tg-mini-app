import { crypto as o } from "./crypto.js";
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const c = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!c)
  throw new Error("Non little-endian hardware is not supported");
Array.from({ length: 256 }, (t, r) => r.toString(16).padStart(2, "0"));
function s(t) {
  if (typeof t != "string")
    throw new TypeError(`utf8ToBytes expected string, got ${typeof t}`);
  return new TextEncoder().encode(t);
}
function p(t) {
  if (typeof t == "string" && (t = s(t)), !(t instanceof Uint8Array))
    throw new TypeError(`Expected input type is Uint8Array (got ${typeof t})`);
  return t;
}
function y(...t) {
  if (!t.every((e) => e instanceof Uint8Array))
    throw new Error("Uint8Array list expected");
  if (t.length === 1)
    return t[0];
  const r = t.reduce((e, n) => e + n.length, 0), i = new Uint8Array(r);
  for (let e = 0, n = 0; e < t.length; e++) {
    const f = t[e];
    i.set(f, n), n += f.length;
  }
  return i;
}
class l {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
}
function w(t = 32) {
  if (o && typeof o.getRandomValues == "function")
    return o.getRandomValues(new Uint8Array(t));
  throw new Error("crypto.getRandomValues must be defined");
}
export {
  l as Hash,
  y as concatBytes,
  c as isLE,
  w as randomBytes,
  p as toBytes,
  s as utf8ToBytes
};
