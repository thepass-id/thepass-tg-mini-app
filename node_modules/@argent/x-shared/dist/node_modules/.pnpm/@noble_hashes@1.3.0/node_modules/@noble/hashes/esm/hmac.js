import a from "./_assert.js";
import { Hash as c, toBytes as u } from "./utils.js";
class r extends c {
  constructor(t, i) {
    super(), this.finished = !1, this.destroyed = !1, a.hash(t);
    const h = u(i);
    if (this.iHash = t.create(), typeof this.iHash.update != "function")
      throw new TypeError("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const o = this.blockLen, e = new Uint8Array(o);
    e.set(h.length > o ? t.create().update(h).digest() : h);
    for (let s = 0; s < e.length; s++)
      e[s] ^= 54;
    this.iHash.update(e), this.oHash = t.create();
    for (let s = 0; s < e.length; s++)
      e[s] ^= 106;
    this.oHash.update(e), e.fill(0);
  }
  update(t) {
    return a.exists(this), this.iHash.update(t), this;
  }
  digestInto(t) {
    a.exists(this), a.bytes(t, this.outputLen), this.finished = !0, this.iHash.digestInto(t), this.oHash.update(t), this.oHash.digestInto(t), this.destroy();
  }
  digest() {
    const t = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(t), t;
  }
  _cloneInto(t) {
    t || (t = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: i, iHash: h, finished: o, destroyed: e, blockLen: s, outputLen: d } = this;
    return t = t, t.finished = o, t.destroyed = e, t.blockLen = s, t.outputLen = d, t.oHash = i._cloneInto(t.oHash), t.iHash = h._cloneInto(t.iHash), t;
  }
  destroy() {
    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
  }
}
const p = (n, t, i) => new r(n, t).update(i).digest();
p.create = (n, t) => new r(n, t);
export {
  p as hmac
};
