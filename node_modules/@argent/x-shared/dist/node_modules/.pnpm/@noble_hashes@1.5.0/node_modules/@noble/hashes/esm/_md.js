import { exists as g, output as d } from "./_assert.js";
import { Hash as b, createView as p, toBytes as a } from "./utils.js";
function w(o, t, s, i) {
  if (typeof o.setBigUint64 == "function")
    return o.setBigUint64(t, s, i);
  const n = BigInt(32), h = BigInt(4294967295), e = Number(s >> n & h), r = Number(s & h), c = i ? 4 : 0, u = i ? 0 : 4;
  o.setUint32(t + c, e, i), o.setUint32(t + u, r, i);
}
const B = (o, t, s) => o & t ^ ~o & s, L = (o, t, s) => o & t ^ o & s ^ t & s;
class U extends b {
  constructor(t, s, i, n) {
    super(), this.blockLen = t, this.outputLen = s, this.padOffset = i, this.isLE = n, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(t), this.view = p(this.buffer);
  }
  update(t) {
    g(this);
    const { view: s, buffer: i, blockLen: n } = this;
    t = a(t);
    const h = t.length;
    for (let e = 0; e < h; ) {
      const r = Math.min(n - this.pos, h - e);
      if (r === n) {
        const c = p(t);
        for (; n <= h - e; e += n)
          this.process(c, e);
        continue;
      }
      i.set(t.subarray(e, e + r), this.pos), this.pos += r, e += r, this.pos === n && (this.process(s, 0), this.pos = 0);
    }
    return this.length += t.length, this.roundClean(), this;
  }
  digestInto(t) {
    g(this), d(t, this), this.finished = !0;
    const { buffer: s, view: i, blockLen: n, isLE: h } = this;
    let { pos: e } = this;
    s[e++] = 128, this.buffer.subarray(e).fill(0), this.padOffset > n - e && (this.process(i, 0), e = 0);
    for (let f = e; f < n; f++)
      s[f] = 0;
    w(i, n - 8, BigInt(this.length * 8), h), this.process(i, 0);
    const r = p(t), c = this.outputLen;
    if (c % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const u = c / 4, l = this.get();
    if (u > l.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let f = 0; f < u; f++)
      r.setUint32(4 * f, l[f], h);
  }
  digest() {
    const { buffer: t, outputLen: s } = this;
    this.digestInto(t);
    const i = t.slice(0, s);
    return this.destroy(), i;
  }
  _cloneInto(t) {
    t || (t = new this.constructor()), t.set(...this.get());
    const { blockLen: s, buffer: i, length: n, finished: h, destroyed: e, pos: r } = this;
    return t.length = n, t.pos = r, t.finished = h, t.destroyed = e, n % s && t.buffer.set(i), t;
  }
}
export {
  B as Chi,
  U as HashMD,
  L as Maj
};
