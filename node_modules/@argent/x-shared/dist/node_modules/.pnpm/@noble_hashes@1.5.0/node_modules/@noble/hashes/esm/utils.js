import { bytes as o } from "./_assert.js";
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const y = (t) => new Uint32Array(t.buffer, t.byteOffset, Math.floor(t.byteLength / 4)), p = (t) => new DataView(t.buffer, t.byteOffset, t.byteLength), l = (t, e) => t << 32 - e | t >>> e, x = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68, r = (t) => t << 24 & 4278190080 | t << 8 & 16711680 | t >>> 8 & 65280 | t >>> 24 & 255;
function b(t) {
  for (let e = 0; e < t.length; e++)
    t[e] = r(t[e]);
}
const c = /* @__PURE__ */ Array.from({ length: 256 }, (t, e) => e.toString(16).padStart(2, "0"));
function g(t) {
  o(t);
  let e = "";
  for (let n = 0; n < t.length; n++)
    e += c[t[n]];
  return e;
}
function i(t) {
  if (typeof t != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof t}`);
  return new Uint8Array(new TextEncoder().encode(t));
}
function u(t) {
  return typeof t == "string" && (t = i(t)), o(t), t;
}
class w {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
}
function h(t) {
  const e = (f) => t().update(u(f)).digest(), n = t();
  return e.outputLen = n.outputLen, e.blockLen = n.blockLen, e.create = () => t(), e;
}
export {
  w as Hash,
  r as byteSwap,
  b as byteSwap32,
  g as bytesToHex,
  p as createView,
  x as isLE,
  l as rotr,
  u as toBytes,
  y as u32,
  i as utf8ToBytes,
  h as wrapConstructor
};
