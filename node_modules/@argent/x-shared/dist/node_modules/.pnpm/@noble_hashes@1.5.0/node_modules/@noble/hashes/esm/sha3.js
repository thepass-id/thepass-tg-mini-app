import { number as d, exists as k, bytes as B, output as A } from "./_assert.js";
import { rotlBH as H, rotlSH as m, rotlBL as S, rotlSL as T, split as F } from "./_u64.js";
import { wrapConstructor as X, Hash as E, u32 as U, isLE as x, byteSwap32 as I, toBytes as P } from "./utils.js";
const y = [], L = [], b = [], M = /* @__PURE__ */ BigInt(0), f = /* @__PURE__ */ BigInt(1), R = /* @__PURE__ */ BigInt(2), j = /* @__PURE__ */ BigInt(7), C = /* @__PURE__ */ BigInt(256), q = /* @__PURE__ */ BigInt(113);
for (let e = 0, t = f, s = 1, n = 0; e < 24; e++) {
  [s, n] = [n, (2 * s + 3 * n) % 5], y.push(2 * (5 * n + s)), L.push((e + 1) * (e + 2) / 2 % 64);
  let o = M;
  for (let r = 0; r < 7; r++)
    t = (t << f ^ (t >> j) * q) % C, t & R && (o ^= f << (f << /* @__PURE__ */ BigInt(r)) - f);
  b.push(o);
}
const [v, z] = /* @__PURE__ */ F(b, !0), O = (e, t, s) => s > 32 ? H(e, t, s) : m(e, t, s), w = (e, t, s) => s > 32 ? S(e, t, s) : T(e, t, s);
function D(e, t = 24) {
  const s = new Uint32Array(10);
  for (let n = 24 - t; n < 24; n++) {
    for (let i = 0; i < 10; i++)
      s[i] = e[i] ^ e[i + 10] ^ e[i + 20] ^ e[i + 30] ^ e[i + 40];
    for (let i = 0; i < 10; i += 2) {
      const h = (i + 8) % 10, l = (i + 2) % 10, u = s[l], c = s[l + 1], _ = O(u, c, 1) ^ s[h], g = w(u, c, 1) ^ s[h + 1];
      for (let a = 0; a < 50; a += 10)
        e[i + a] ^= _, e[i + a + 1] ^= g;
    }
    let o = e[2], r = e[3];
    for (let i = 0; i < 24; i++) {
      const h = L[i], l = O(o, r, h), u = w(o, r, h), c = y[i];
      o = e[c], r = e[c + 1], e[c] = l, e[c + 1] = u;
    }
    for (let i = 0; i < 50; i += 10) {
      for (let h = 0; h < 10; h++)
        s[h] = e[i + h];
      for (let h = 0; h < 10; h++)
        e[i + h] ^= ~s[(h + 2) % 10] & s[(h + 4) % 10];
    }
    e[0] ^= v[n], e[1] ^= z[n];
  }
  s.fill(0);
}
class p extends E {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(t, s, n, o = !1, r = 24) {
    if (super(), this.blockLen = t, this.suffix = s, this.outputLen = n, this.enableXOF = o, this.rounds = r, this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, d(n), 0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200), this.state32 = U(this.state);
  }
  keccak() {
    x || I(this.state32), D(this.state32, this.rounds), x || I(this.state32), this.posOut = 0, this.pos = 0;
  }
  update(t) {
    k(this);
    const { blockLen: s, state: n } = this;
    t = P(t);
    const o = t.length;
    for (let r = 0; r < o; ) {
      const i = Math.min(s - this.pos, o - r);
      for (let h = 0; h < i; h++)
        n[this.pos++] ^= t[r++];
      this.pos === s && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = !0;
    const { state: t, suffix: s, pos: n, blockLen: o } = this;
    t[n] ^= s, s & 128 && n === o - 1 && this.keccak(), t[o - 1] ^= 128, this.keccak();
  }
  writeInto(t) {
    k(this, !1), B(t), this.finish();
    const s = this.state, { blockLen: n } = this;
    for (let o = 0, r = t.length; o < r; ) {
      this.posOut >= n && this.keccak();
      const i = Math.min(n - this.posOut, r - o);
      t.set(s.subarray(this.posOut, this.posOut + i), o), this.posOut += i, o += i;
    }
    return t;
  }
  xofInto(t) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(t);
  }
  xof(t) {
    return d(t), this.xofInto(new Uint8Array(t));
  }
  digestInto(t) {
    if (A(t, this), this.finished)
      throw new Error("digest() was already called");
    return this.writeInto(t), this.destroy(), t;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = !0, this.state.fill(0);
  }
  _cloneInto(t) {
    const { blockLen: s, suffix: n, outputLen: o, rounds: r, enableXOF: i } = this;
    return t || (t = new p(s, n, o, i, r)), t.state32.set(this.state32), t.pos = this.pos, t.posOut = this.posOut, t.finished = this.finished, t.rounds = r, t.suffix = n, t.outputLen = o, t.enableXOF = i, t.destroyed = this.destroyed, t;
  }
}
const G = (e, t, s) => X(() => new p(t, e, s)), Q = /* @__PURE__ */ G(1, 136, 256 / 8);
export {
  p as Keccak,
  D as keccakP,
  Q as keccak_256
};
