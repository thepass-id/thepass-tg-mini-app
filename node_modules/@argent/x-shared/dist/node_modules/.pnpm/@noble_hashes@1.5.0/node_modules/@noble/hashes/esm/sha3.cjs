"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const l=require("./_assert.cjs"),a=require("./_u64.cjs"),c=require("./utils.cjs"),I=[],O=[],w=[],B=BigInt(0),f=BigInt(1),A=BigInt(2),S=BigInt(7),H=BigInt(256),T=BigInt(113);for(let i=0,t=f,s=1,n=0;i<24;i++){[s,n]=[n,(2*s+3*n)%5],I.push(2*(5*n+s)),O.push((i+1)*(i+2)/2%64);let o=B;for(let r=0;r<7;r++)t=(t<<f^(t>>S)*T)%H,t&A&&(o^=f<<(f<<BigInt(r))-f);w.push(o)}const[m,E]=a.split(w,!0),y=(i,t,s)=>s>32?a.rotlBH(i,t,s):a.rotlSH(i,t,s),b=(i,t,s)=>s>32?a.rotlBL(i,t,s):a.rotlSL(i,t,s);function L(i,t=24){const s=new Uint32Array(10);for(let n=24-t;n<24;n++){for(let e=0;e<10;e++)s[e]=i[e]^i[e+10]^i[e+20]^i[e+30]^i[e+40];for(let e=0;e<10;e+=2){const h=(e+8)%10,p=(e+2)%10,d=s[p],u=s[p+1],_=y(d,u,1)^s[h],g=b(d,u,1)^s[h+1];for(let k=0;k<50;k+=10)i[e+k]^=_,i[e+k+1]^=g}let o=i[2],r=i[3];for(let e=0;e<24;e++){const h=O[e],p=y(o,r,h),d=b(o,r,h),u=I[e];o=i[u],r=i[u+1],i[u]=p,i[u+1]=d}for(let e=0;e<50;e+=10){for(let h=0;h<10;h++)s[h]=i[e+h];for(let h=0;h<10;h++)i[e+h]^=~s[(h+2)%10]&s[(h+4)%10]}i[0]^=m[n],i[1]^=E[n]}s.fill(0)}class x extends c.Hash{constructor(t,s,n,o=!1,r=24){if(super(),this.blockLen=t,this.suffix=s,this.outputLen=n,this.enableXOF=o,this.rounds=r,this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,l.number(n),0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");this.state=new Uint8Array(200),this.state32=c.u32(this.state)}keccak(){c.isLE||c.byteSwap32(this.state32),L(this.state32,this.rounds),c.isLE||c.byteSwap32(this.state32),this.posOut=0,this.pos=0}update(t){l.exists(this);const{blockLen:s,state:n}=this;t=c.toBytes(t);const o=t.length;for(let r=0;r<o;){const e=Math.min(s-this.pos,o-r);for(let h=0;h<e;h++)n[this.pos++]^=t[r++];this.pos===s&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:t,suffix:s,pos:n,blockLen:o}=this;t[n]^=s,s&128&&n===o-1&&this.keccak(),t[o-1]^=128,this.keccak()}writeInto(t){l.exists(this,!1),l.bytes(t),this.finish();const s=this.state,{blockLen:n}=this;for(let o=0,r=t.length;o<r;){this.posOut>=n&&this.keccak();const e=Math.min(n-this.posOut,r-o);t.set(s.subarray(this.posOut,this.posOut+e),o),this.posOut+=e,o+=e}return t}xofInto(t){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(t)}xof(t){return l.number(t),this.xofInto(new Uint8Array(t))}digestInto(t){if(l.output(t,this),this.finished)throw new Error("digest() was already called");return this.writeInto(t),this.destroy(),t}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto(t){const{blockLen:s,suffix:n,outputLen:o,rounds:r,enableXOF:e}=this;return t||(t=new x(s,n,o,e,r)),t.state32.set(this.state32),t.pos=this.pos,t.posOut=this.posOut,t.finished=this.finished,t.rounds=r,t.suffix=n,t.outputLen=o,t.enableXOF=e,t.destroyed=this.destroyed,t}}const F=(i,t,s)=>c.wrapConstructor(()=>new x(t,i,s)),P=F(1,136,256/8);exports.Keccak=x;exports.keccakP=L;exports.keccak_256=P;
