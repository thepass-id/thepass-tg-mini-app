/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const u = (t) => new Uint32Array(t.buffer, t.byteOffset, Math.floor(t.byteLength / 4));
function o(t) {
  return t instanceof Uint8Array || t != null && typeof t == "object" && t.constructor.name === "Uint8Array";
}
const s = (t) => new DataView(t.buffer, t.byteOffset, t.byteLength), y = (t, e) => t << 32 - e | t >>> e, i = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!i)
  throw new Error("Non little-endian hardware is not supported");
function c(t) {
  if (typeof t != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof t}`);
  return new Uint8Array(new TextEncoder().encode(t));
}
function f(t) {
  if (typeof t == "string" && (t = c(t)), !o(t))
    throw new Error(`expected Uint8Array, got ${typeof t}`);
  return t;
}
class p {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
}
function w(t) {
  const e = (r) => t().update(f(r)).digest(), n = t();
  return e.outputLen = n.outputLen, e.blockLen = n.blockLen, e.create = () => t(), e;
}
export {
  p as Hash,
  s as createView,
  i as isLE,
  y as rotr,
  f as toBytes,
  u as u32,
  c as utf8ToBytes,
  w as wrapConstructor
};
