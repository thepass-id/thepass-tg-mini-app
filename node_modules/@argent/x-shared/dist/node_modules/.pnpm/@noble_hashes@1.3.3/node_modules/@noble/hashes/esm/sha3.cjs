"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const u=require("./_assert.cjs"),f=require("./_u64.cjs"),k=require("./utils.cjs"),[y,b,_]=[[],[],[]],B=BigInt(0),l=BigInt(1),A=BigInt(2),H=BigInt(7),S=BigInt(256),T=BigInt(113);for(let i=0,t=l,s=1,n=0;i<24;i++){[s,n]=[n,(2*s+3*n)%5],y.push(2*(5*n+s)),b.push((i+1)*(i+2)/2%64);let o=B;for(let r=0;r<7;r++)t=(t<<l^(t>>H)*T)%S,t&A&&(o^=l<<(l<<BigInt(r))-l);_.push(o)}const[m,F]=f.split(_,!0),I=(i,t,s)=>s>32?f.rotlBH(i,t,s):f.rotlSH(i,t,s),O=(i,t,s)=>s>32?f.rotlBL(i,t,s):f.rotlSL(i,t,s);function w(i,t=24){const s=new Uint32Array(10);for(let n=24-t;n<24;n++){for(let e=0;e<10;e++)s[e]=i[e]^i[e+10]^i[e+20]^i[e+30]^i[e+40];for(let e=0;e<10;e+=2){const h=(e+8)%10,a=(e+2)%10,p=s[a],c=s[a+1],g=I(p,c,1)^s[h],L=O(p,c,1)^s[h+1];for(let d=0;d<50;d+=10)i[e+d]^=g,i[e+d+1]^=L}let o=i[2],r=i[3];for(let e=0;e<24;e++){const h=b[e],a=I(o,r,h),p=O(o,r,h),c=y[e];o=i[c],r=i[c+1],i[c]=a,i[c+1]=p}for(let e=0;e<50;e+=10){for(let h=0;h<10;h++)s[h]=i[e+h];for(let h=0;h<10;h++)i[e+h]^=~s[(h+2)%10]&s[(h+4)%10]}i[0]^=m[n],i[1]^=F[n]}s.fill(0)}class x extends k.Hash{constructor(t,s,n,o=!1,r=24){if(super(),this.blockLen=t,this.suffix=s,this.outputLen=n,this.enableXOF=o,this.rounds=r,this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,u.number(n),0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");this.state=new Uint8Array(200),this.state32=k.u32(this.state)}keccak(){w(this.state32,this.rounds),this.posOut=0,this.pos=0}update(t){u.exists(this);const{blockLen:s,state:n}=this;t=k.toBytes(t);const o=t.length;for(let r=0;r<o;){const e=Math.min(s-this.pos,o-r);for(let h=0;h<e;h++)n[this.pos++]^=t[r++];this.pos===s&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:t,suffix:s,pos:n,blockLen:o}=this;t[n]^=s,s&128&&n===o-1&&this.keccak(),t[o-1]^=128,this.keccak()}writeInto(t){u.exists(this,!1),u.bytes(t),this.finish();const s=this.state,{blockLen:n}=this;for(let o=0,r=t.length;o<r;){this.posOut>=n&&this.keccak();const e=Math.min(n-this.posOut,r-o);t.set(s.subarray(this.posOut,this.posOut+e),o),this.posOut+=e,o+=e}return t}xofInto(t){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(t)}xof(t){return u.number(t),this.xofInto(new Uint8Array(t))}digestInto(t){if(u.output(t,this),this.finished)throw new Error("digest() was already called");return this.writeInto(t),this.destroy(),t}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto(t){const{blockLen:s,suffix:n,outputLen:o,rounds:r,enableXOF:e}=this;return t||(t=new x(s,n,o,e,r)),t.state32.set(this.state32),t.pos=this.pos,t.posOut=this.posOut,t.finished=this.finished,t.rounds=r,t.suffix=n,t.outputLen=o,t.enableXOF=e,t.destroyed=this.destroyed,t}}const P=(i,t,s)=>k.wrapConstructor(()=>new x(t,i,s)),X=P(1,136,256/8);exports.Keccak=x;exports.keccakP=w;exports.keccak_256=X;
