import { number as d, exists as k, bytes as _, output as g } from "./_assert.js";
import { rotlBH as B, rotlSH as A, rotlBL as H, rotlSL as m, split as S } from "./_u64.js";
import { wrapConstructor as T, Hash as F, u32 as X, toBytes as U } from "./utils.js";
const [O, w, y] = [[], [], []], E = /* @__PURE__ */ BigInt(0), f = /* @__PURE__ */ BigInt(1), P = /* @__PURE__ */ BigInt(2), M = /* @__PURE__ */ BigInt(7), R = /* @__PURE__ */ BigInt(256), j = /* @__PURE__ */ BigInt(113);
for (let i = 0, t = f, s = 1, n = 0; i < 24; i++) {
  [s, n] = [n, (2 * s + 3 * n) % 5], O.push(2 * (5 * n + s)), w.push((i + 1) * (i + 2) / 2 % 64);
  let o = E;
  for (let r = 0; r < 7; r++)
    t = (t << f ^ (t >> M) * j) % R, t & P && (o ^= f << (f << /* @__PURE__ */ BigInt(r)) - f);
  y.push(o);
}
const [C, q] = /* @__PURE__ */ S(y, !0), x = (i, t, s) => s > 32 ? B(i, t, s) : A(i, t, s), I = (i, t, s) => s > 32 ? H(i, t, s) : m(i, t, s);
function v(i, t = 24) {
  const s = new Uint32Array(10);
  for (let n = 24 - t; n < 24; n++) {
    for (let e = 0; e < 10; e++)
      s[e] = i[e] ^ i[e + 10] ^ i[e + 20] ^ i[e + 30] ^ i[e + 40];
    for (let e = 0; e < 10; e += 2) {
      const h = (e + 8) % 10, l = (e + 2) % 10, u = s[l], c = s[l + 1], L = x(u, c, 1) ^ s[h], b = I(u, c, 1) ^ s[h + 1];
      for (let a = 0; a < 50; a += 10)
        i[e + a] ^= L, i[e + a + 1] ^= b;
    }
    let o = i[2], r = i[3];
    for (let e = 0; e < 24; e++) {
      const h = w[e], l = x(o, r, h), u = I(o, r, h), c = O[e];
      o = i[c], r = i[c + 1], i[c] = l, i[c + 1] = u;
    }
    for (let e = 0; e < 50; e += 10) {
      for (let h = 0; h < 10; h++)
        s[h] = i[e + h];
      for (let h = 0; h < 10; h++)
        i[e + h] ^= ~s[(h + 2) % 10] & s[(h + 4) % 10];
    }
    i[0] ^= C[n], i[1] ^= q[n];
  }
  s.fill(0);
}
class p extends F {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(t, s, n, o = !1, r = 24) {
    if (super(), this.blockLen = t, this.suffix = s, this.outputLen = n, this.enableXOF = o, this.rounds = r, this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, d(n), 0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200), this.state32 = X(this.state);
  }
  keccak() {
    v(this.state32, this.rounds), this.posOut = 0, this.pos = 0;
  }
  update(t) {
    k(this);
    const { blockLen: s, state: n } = this;
    t = U(t);
    const o = t.length;
    for (let r = 0; r < o; ) {
      const e = Math.min(s - this.pos, o - r);
      for (let h = 0; h < e; h++)
        n[this.pos++] ^= t[r++];
      this.pos === s && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = !0;
    const { state: t, suffix: s, pos: n, blockLen: o } = this;
    t[n] ^= s, s & 128 && n === o - 1 && this.keccak(), t[o - 1] ^= 128, this.keccak();
  }
  writeInto(t) {
    k(this, !1), _(t), this.finish();
    const s = this.state, { blockLen: n } = this;
    for (let o = 0, r = t.length; o < r; ) {
      this.posOut >= n && this.keccak();
      const e = Math.min(n - this.posOut, r - o);
      t.set(s.subarray(this.posOut, this.posOut + e), o), this.posOut += e, o += e;
    }
    return t;
  }
  xofInto(t) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(t);
  }
  xof(t) {
    return d(t), this.xofInto(new Uint8Array(t));
  }
  digestInto(t) {
    if (g(t, this), this.finished)
      throw new Error("digest() was already called");
    return this.writeInto(t), this.destroy(), t;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = !0, this.state.fill(0);
  }
  _cloneInto(t) {
    const { blockLen: s, suffix: n, outputLen: o, rounds: r, enableXOF: e } = this;
    return t || (t = new p(s, n, o, e, r)), t.state32.set(this.state32), t.pos = this.pos, t.posOut = this.posOut, t.finished = this.finished, t.rounds = r, t.suffix = n, t.outputLen = o, t.enableXOF = e, t.destroyed = this.destroyed, t;
  }
}
const z = (i, t, s) => T(() => new p(t, i, s)), K = /* @__PURE__ */ z(1, 136, 256 / 8);
export {
  p as Keccak,
  v as keccakP,
  K as keccak_256
};
