import { exists as g, output as b } from "./_assert.js";
import { Hash as d, createView as p, toBytes as a } from "./utils.js";
function w(u, t, n, e) {
  if (typeof u.setBigUint64 == "function")
    return u.setBigUint64(t, n, e);
  const i = BigInt(32), o = BigInt(4294967295), s = Number(n >> i & o), h = Number(n & o), f = e ? 4 : 0, c = e ? 0 : 4;
  u.setUint32(t + f, s, e), u.setUint32(t + c, h, e);
}
class B extends d {
  constructor(t, n, e, i) {
    super(), this.blockLen = t, this.outputLen = n, this.padOffset = e, this.isLE = i, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(t), this.view = p(this.buffer);
  }
  update(t) {
    g(this);
    const { view: n, buffer: e, blockLen: i } = this;
    t = a(t);
    const o = t.length;
    for (let s = 0; s < o; ) {
      const h = Math.min(i - this.pos, o - s);
      if (h === i) {
        const f = p(t);
        for (; i <= o - s; s += i)
          this.process(f, s);
        continue;
      }
      e.set(t.subarray(s, s + h), this.pos), this.pos += h, s += h, this.pos === i && (this.process(n, 0), this.pos = 0);
    }
    return this.length += t.length, this.roundClean(), this;
  }
  digestInto(t) {
    g(this), b(t, this), this.finished = !0;
    const { buffer: n, view: e, blockLen: i, isLE: o } = this;
    let { pos: s } = this;
    n[s++] = 128, this.buffer.subarray(s).fill(0), this.padOffset > i - s && (this.process(e, 0), s = 0);
    for (let r = s; r < i; r++)
      n[r] = 0;
    w(e, i - 8, BigInt(this.length * 8), o), this.process(e, 0);
    const h = p(t), f = this.outputLen;
    if (f % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const c = f / 4, l = this.get();
    if (c > l.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let r = 0; r < c; r++)
      h.setUint32(4 * r, l[r], o);
  }
  digest() {
    const { buffer: t, outputLen: n } = this;
    this.digestInto(t);
    const e = t.slice(0, n);
    return this.destroy(), e;
  }
  _cloneInto(t) {
    t || (t = new this.constructor()), t.set(...this.get());
    const { blockLen: n, buffer: e, length: i, finished: o, destroyed: s, pos: h } = this;
    return t.length = i, t.pos = h, t.finished = o, t.destroyed = s, i % n && t.buffer.set(e), t;
  }
}
export {
  B as SHA2
};
