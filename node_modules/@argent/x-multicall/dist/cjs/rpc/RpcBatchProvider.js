"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RpcBatchProvider = exports.RpcChannelBatch = void 0;
const dataloader_1 = __importDefault(require("dataloader"));
const starknet_1 = require("starknet");
class RpcChannelBatch extends starknet_1.RpcChannel {
    wait;
    batchSize;
    loader;
    constructor({ batchInterval, maxBatchSize, ...optionsOrProvider }) {
        super(optionsOrProvider);
        this.wait = batchInterval ?? 0;
        this.batchSize = maxBatchSize ?? 20;
        this.loader = new dataloader_1.default(this.batchRequests.bind(this), {
            batch: true,
            maxBatchSize: this.batchSize,
            cache: false,
            batchScheduleFn: (cb) => setTimeout(cb, this.wait),
        });
    }
    async batchRequests(requests) {
        const body = requests.map(({ method, params }, i) => ({
            method,
            params: params ?? [],
            jsonrpc: "2.0",
            id: i,
        }));
        const response = await fetch(this.nodeUrl, {
            method: "POST",
            body: JSON.stringify(body),
            headers: this.headers,
        });
        if (!response.ok) {
            const data = await response.text();
            throw new Error(`Failed to fetch, status: ${response.status}, body:\n${JSON.stringify(data)}`);
        }
        const responseErrorClone = response.clone();
        const data = await response.json().catch(async () => {
            const errorText = await responseErrorClone.text();
            throw new Error(`Failed to parse response as JSON

        method: POST
        url: ${this.nodeUrl}
        headers: ${JSON.stringify(this.headers)}
        requestBody: ${JSON.stringify(body)}
        responseBody:\n${JSON.stringify(errorText)}`);
        });
        if (!Array.isArray(data)) {
            throw new Error("unknown error");
        }
        const sortedData = data.sort((a, b) => a.id - b.id);
        return sortedData;
    }
    errorHandler(method, params, rpcError, otherError) {
        if (rpcError) {
            const { code, message, data } = rpcError;
            throw new starknet_1.LibraryError(`RPC: ${method} with params ${JSON.stringify(params)}\n ${code}: ${message}: ${JSON.stringify(data)}`);
        }
        if (otherError instanceof starknet_1.LibraryError) {
            throw otherError;
        }
        if (otherError) {
            throw Error(otherError.message);
        }
    }
    async fetchEndpoint(method, params) {
        const request = { method, params };
        const response = await (this.loader?.load(request) ?? this.batchRequests([request]).then((res) => res[0]));
        const { error, result } = response;
        this.errorHandler(error, params);
        return result;
    }
}
exports.RpcChannelBatch = RpcChannelBatch;
class RpcBatchProvider extends starknet_1.RpcProvider {
    constructor({ batchInterval, maxBatchSize, ...optionsOrProvider }) {
        super({
            channel: new RpcChannelBatch({ batchInterval, maxBatchSize, ...optionsOrProvider }),
            ...optionsOrProvider,
        });
    }
}
exports.RpcBatchProvider = RpcBatchProvider;
