"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.aggregate = void 0;
const starknet_1 = require("starknet");
const partitionResponses = (responses) => {
    if (responses.length === 0) {
        return [];
    }
    const [responseLength, ...restResponses] = responses;
    const responseLengthInt = Number(starknet_1.num.toBigInt(responseLength));
    const response = restResponses.slice(0, responseLengthInt);
    const remainingResponses = restResponses.slice(responseLengthInt);
    return [response, ...partitionResponses(remainingResponses)];
};
const extractErrorCallIndex = (e) => {
    try {
        const errorCallText = e.toString();
        const sequencerErrorIndex = errorCallText.match(/Error message: multicall (\d+) failed/)?.[1];
        if (sequencerErrorIndex) {
            return Number(sequencerErrorIndex);
        }
        throw e;
    }
    catch {
        throw e;
    }
};
const fallbackAggregate = async (provider, calls) => {
    const results = await Promise.allSettled(calls.map((call) => provider
        .callContract({
        contractAddress: call.contractAddress,
        entrypoint: call.entrypoint,
        calldata: starknet_1.CallData.toCalldata(call.calldata),
    })
        .then((res) => res)));
    return results.map((result) => {
        if (result.status === "fulfilled") {
            return result.value;
        }
        return result.reason;
    });
};
const aggregate = async (provider, multicallAddress, calls) => {
    if (calls.length === 0) {
        return [];
    }
    try {
        const res = await provider.callContract({
            contractAddress: multicallAddress,
            entrypoint: "aggregate",
            calldata: starknet_1.transaction.fromCallsToExecuteCalldata([...calls]),
        });
        const [_blockNumber, _totalLength, ...results] = res;
        return partitionResponses(results);
    }
    catch (e) {
        if (!(e instanceof Error)) {
            throw e;
        }
        if ((e instanceof starknet_1.GatewayError && e.errorCode === "StarknetErrorCode.UNINITIALIZED_CONTRACT") ||
            (e instanceof starknet_1.LibraryError && e.message === "20: Contract not found")) {
            return fallbackAggregate(provider, calls);
        }
        const errorCallIndex = extractErrorCallIndex(e);
        const remainingCalls = calls.filter((_, i) => i !== errorCallIndex);
        const remainingResults = await (0, exports.aggregate)(provider, multicallAddress, remainingCalls);
        return [...remainingResults.slice(0, errorCallIndex), e, ...remainingResults.slice(errorCallIndex)];
    }
};
exports.aggregate = aggregate;
