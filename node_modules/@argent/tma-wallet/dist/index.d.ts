import { Abi } from 'starknet';
import { Account } from 'starknet';
import { AccountDeploymentPayload } from '@internal/shared/types/account';
import { AccountInterface } from 'starknet';
import { Address } from '@internal/primitives/address';
import { AllowArray } from 'starknet';
import { ApprovalRequest } from '@internal/shared/stores/approval';
import { Call } from 'starknet';
import { Calldata } from 'starknet';
import { ContactArgentBackendService } from '@internal/services/contact/backend';
import { DeclareSignerDetails } from 'starknet';
import { DeployAccountSignerDetails } from 'starknet';
import { DeployContractResponse } from 'starknet';
import { EstimateFeeResponse } from 'starknet';
import { InitData } from '@telegram-apps/types';
import { InvocationsSignerDetails } from 'starknet';
import { InvokeFunctionResponse } from 'starknet';
import { ITokenServiceWeb } from '@argent/x-shared';
import { ProviderInterface } from 'starknet';
import { Session } from '@argent/x-sessions';
import { Signature } from 'starknet';
import { SignerInterface } from 'starknet';
import { SimulateTransactionResponse } from 'starknet';
import { TypedData } from 'starknet';
import { Uint256 } from 'starknet';
import { UniversalDetails } from 'starknet';

export declare interface AccountConstructorArguments {
    sender: string;
    gift_token: string;
    gift_amount: string;
    fee_token: string;
    fee_amount: string;
    gift_pubkey: string;
}

export declare class ArgentTMA implements ArgentTMAInterface {
    private appName;
    private appTelegramUrl;
    private environment;
    private sessionParams;
    provider: ProviderInterface;
    private requestStore;
    private responseStore;
    private approvalStore;
    sessionAccount?: SessionAccountInterface;
    contactService: ContactArgentBackendService;
    constructor(params: InitParams);
    connect(): Promise<ConnectResponse | undefined>;
    requestConnection({ callbackData, approvalRequests, }: {
        callbackData?: string;
        approvalRequests?: ApprovalRequest[];
    }): Promise<never>;
    requestApprovals(approvalRequests: ApprovalRequest[]): Promise<void>;
    isConnected(): boolean;
    hasWallet(userId: number): Promise<boolean>;
    exportSignedSession(): Promise<SignedSession | undefined>;
    clearSession(): Promise<void>;
    private getSessionFromInitData;
    private getSessionFromCloudStorage;
    private getSessionRequestFromCloudStorage;
    private saveSessionToCloudStorage;
    private saveSessionRequestToCloudStorage;
    private buildSessionRequest;
    private buildSessionAccountFromStoredSession;
    static init(params: InitParams): ArgentTMA;
}

declare interface ArgentTMAInterface {
    provider: ProviderInterface;
    sessionAccount?: SessionAccountInterface;
    connect(): Promise<ConnectResponse | undefined>;
    requestConnection({ callbackData, approvalRequests, }: {
        callbackData?: string;
        approvalRequests?: ApprovalRequest[];
    }): Promise<never>;
    isConnected(): boolean;
    requestApprovals(approvalRequests: ApprovalRequest[]): Promise<void>;
    exportSignedSession(): Promise<SignedSession | undefined>;
    clearSession(): Promise<void>;
}

export declare function buildGiftCallData(gift: Gift): {
    gift_amount: Uint256;
    factory: string;
    escrow_class_hash: string;
    sender: string;
    gift_token: string;
    fee_token: string;
    fee_amount: string;
    gift_pubkey: string;
};

export declare function calculateEscrowAddress(gift: Gift): string;

export declare function cancelGift(args: {
    gift: Gift;
    senderAccount: Account;
}): Promise<InvokeFunctionResponse>;

export declare function claimInternal(args: {
    gift: Gift;
    receiver: string;
    giftPrivateKey: string;
    provider: ProviderInterface;
    overrides?: {
        escrowAccountAddress?: string;
        callToAddress?: string;
    };
    details?: UniversalDetails;
}): Promise<InvokeFunctionResponse>;

export declare interface CloudStorageService {
    get(key: string): Promise<string | null>;
    set(key: string, value: string): Promise<void>;
    remove(key: string): Promise<void>;
    getAllKeys(): Promise<string[]>;
}

declare type ConnectResponse = {
    account: SessionAccountInterface;
    initData?: InitData;
    callbackData?: string;
    approvalTransactionHash?: string;
};

export declare function createDeposit(sender: string, { giftAmount, feeAmount, factoryAddress, feeTokenAddress, giftTokenAddress, giftSignerPubKey, escrowAccountClassHash, }: DepositParams): {
    calls: Call[];
    gift: Gift;
};

export declare function createSessionAccount({ session, sessionParams, provider, chainId, argentBaseUrl, }: {
    session: SignedSession;
    sessionParams: SessionParameters;
    provider: ProviderInterface;
    chainId: StarknetChainId;
    argentBaseUrl: string;
    transactionVersion?: "0x2" | "0x3";
}): Promise<SessionAccount>;

export declare function deposit(sender: Account, depositParams: DepositParams): Promise<{
    response: InvokeFunctionResponse;
    gift: Gift;
}>;

export declare interface DepositParams {
    giftAmount: bigint;
    feeAmount: bigint;
    factoryAddress: string;
    feeTokenAddress: string;
    giftTokenAddress: string;
    giftSignerPubKey: bigint;
    escrowAccountClassHash: string;
}

export declare interface Environment {
    chainId: StarknetChainId;
    walletAppUrl: string;
    storeUrl: string;
    argentBaseUrl: string;
    providerDefaultUrl: string;
}

declare const ENVIRONMENTS: Record<"sepolia" | "mainnet" | "dev", Environment>;

export declare const ETH_GIFT_MAX_FEE = 200000000000000n;

export declare const ethAddress = "0x049d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7";

export declare function executeActionOnAccount(functionName: string, accountAddress: string, args: Calldata): Call;

export declare function executeWithPaymaster(tokenService: ITokenServiceWeb, account: SelfDeployingAccountInterface, calls: Call[], universalDetails?: UniversalDetails): Promise<{
    transaction_hash: string;
}>;

export declare const gaslessBaseUrls: {
    "0x534e5f4d41494e": string;
    "0x534e5f5345504f4c4941": string;
};

export declare const gasTokenAddress = "0x53b40a647cedfca6ca84f542a0fe36736031905a9639a7f19a3c1e66bfd5080";

export declare function getEscrowAccount(provider: ProviderInterface, gift: Gift, giftPrivateKey: string, forceEscrowAddress?: string): Account;

export declare const getEstimatedFeesInGasToken: ({ account, fee, }: {
    fee: EstimateFeeResponse;
    account: StrongAccountInterface;
}) => Promise<{
    gasTokenFees: {
        [k: string]: bigint;
    };
    gaslessOptions: {
        baseUrl: string;
    };
}>;

export declare function getMaxFee(useTxV3: boolean): bigint;

export declare const getNativeFees: ({ deploymentPayload, isDeployed, calls, account, universalDetails, }: {
    account: StrongAccountInterface;
    universalDetails?: UniversalDetails;
    calls: Call[];
    isDeployed?: boolean;
    deploymentPayload?: AccountDeploymentPayload;
}) => Promise<EstimateFeeResponse>;

export declare interface Gift extends AccountConstructorArguments {
    factory: string;
    escrow_class_hash: string;
}

declare type InitParams = {
    appName: string;
    appTelegramUrl: string;
    environment?: keyof typeof ENVIRONMENTS;
    provider?: ProviderInterface;
    sessionParams: SessionParameters;
};

export declare function isOutOfGasError(error: unknown): boolean;

export declare class LegacyStarknetKeyPair extends RawSigner {
    pk: string;
    constructor(pk?: string | bigint);
    get privateKey(): string;
    get publicKey(): bigint;
    signRaw(messageHash: string): Promise<string[]>;
}

export declare function prependPaymasterTransfer(typedData: TypedData, calls: Call[]): Call[];

export declare function randomPrivateKey(format: "buffer"): Uint8Array;

export declare function randomPrivateKey(format: "bigint"): BigInt;

export declare function randomPrivateKey(format: "hex"): string;

export declare function randomPrivateKey(): string;

/**
 * This class allows to easily implement custom signers by overriding the `signRaw` method.
 * This is based on Starknet.js implementation of Signer, but it delegates the actual signing to an abstract function
 */
export declare abstract class RawSigner implements SignerInterface {
    abstract signRaw(messageHash: string): Promise<string[]>;
    getPubKey(): Promise<string>;
    signMessage(typedDataArgument: TypedData, accountAddress: string): Promise<Signature>;
    signTransaction(transactions: Call[], details: InvocationsSignerDetails): Promise<Signature>;
    signDeployAccountTransaction(details: DeployAccountSignerDetails): Promise<Signature>;
    signDeclareTransaction(details: DeclareSignerDetails): Promise<Signature>;
}

/**
 * Self deploying account that can be used just as the vanilla SNjs account
 * It also enforces some extra properties to make it more type safe
 */
declare abstract class SelfDeployingAccount extends Account implements SelfDeployingAccountInterface {
    protected deploymentPayload: AccountDeploymentPayload;
    address: Address;
    protected isDeployedPromise: Promise<boolean>;
    constructor(provider: ProviderInterface, signer: SignerInterface, deploymentPayload: AccountDeploymentPayload);
    getDeploymentPayload(): Promise<AccountDeploymentPayload>;
    isDeployed(): Promise<boolean>;
    deployFrom(account: AccountInterface): Promise<DeployContractResponse>;
    protected executeWithDeploy(calls: Call[], abis: Abi[] | undefined, universalDetails?: UniversalDetails): Promise<{
        transaction_hash: string;
    }>;
    execute(calls: AllowArray<Call>, universalDetails?: UniversalDetails): Promise<InvokeFunctionResponse>;
    execute(calls: AllowArray<Call>, abis?: Abi[], universalDetails?: UniversalDetails): Promise<InvokeFunctionResponse>;
    protected abstract onExecute(calls: Call[], abis?: Abi[], universalDetails?: UniversalDetails): Promise<InvokeFunctionResponse>;
    protected executeDefault(calls: Call[], abis?: Abi[], universalDetails?: UniversalDetails): Promise<InvokeFunctionResponse>;
}

export declare interface SelfDeployingAccountInterface extends StrongAccountInterface {
    getDeploymentPayload(): Promise<AccountDeploymentPayload>;
    isDeployed(): Promise<boolean>;
    deployFrom(account: AccountInterface): Promise<DeployContractResponse>;
}

export declare interface SelfDeployingAccountInterface extends StrongAccountInterface {
    getDeploymentPayload(): Promise<AccountDeploymentPayload>;
}

declare class SessionAccount extends SelfDeployingAccount implements SessionAccountInterface {
    address: Address;
    protected deploymentPayload: AccountDeploymentPayload;
    protected session: SignedSession;
    protected sessionParams: SessionParameters;
    argentBaseUrl: string;
    chainId: StarknetChainId;
    constructor(provider: ProviderInterface, address: Address, signer: SignerInterface, deploymentPayload: AccountDeploymentPayload, session: Session, sessionParams: SessionParameters, argentBaseUrl: string, chainId: StarknetChainId);
    getOutsideExecutionPayload({ calls, }: {
        calls: Call[];
    }): Promise<Call>;
    protected onExecute(calls: Call[], abis?: Abi[], universalDetails?: UniversalDetails): Promise<{
        transaction_hash: string;
    }>;
    getSessionStatus(): SessionStatus;
    protected isSessionScopeValid(): boolean;
}

export declare interface SessionAccountInterface extends SelfDeployingAccountInterface {
    getOutsideExecutionPayload({ calls }: {
        calls: Call[];
    }): Promise<Call>;
    isDeployed(): Promise<boolean>;
    deployFrom(account: AccountInterface): Promise<DeployContractResponse>;
    getSessionStatus(): SessionStatus;
}

export declare interface SessionAccountInterface extends SelfDeployingAccountInterface {
    getOutsideExecutionPayload({ calls }: {
        calls: Call[];
    }): Promise<Call>;
    isDeployed(): Promise<boolean>;
    deployFrom(account: AccountInterface): Promise<DeployContractResponse>;
    getSessionStatus(): SessionStatus;
}

export declare type SessionParameters = {
    allowedMethods: Array<{
        contract: string;
        selector: string;
    }>;
    validityDays?: number;
};

export declare type SessionStatus = "VALID" | "EXPIRED" | "INVALID_SCOPE" | "INVALID_SIGNATURE" | "INVALID_SESSION";

export declare interface SignedSession extends Session {
    deploymentPayload?: AccountDeploymentPayload;
    signature?: Signature;
}

export declare function simulateClaimInternal(args: {
    gift: Gift;
    receiver: string;
    giftPrivateKey: string;
    provider: ProviderInterface;
    overrides?: {
        escrowAccountAddress?: string;
        callToAddress?: string;
    };
}): Promise<SimulateTransactionResponse>;

export declare enum StarknetChainId {
    SN_MAIN = "0x534e5f4d41494e",// encodeShortString('SN_MAIN'),
    SN_SEPOLIA = "0x534e5f5345504f4c4941"
}

export declare const storageService: TelegramCloudStorage;

export declare const STRK_GIFT_MAX_FEE = 200000000000000000n;

export declare const strkAddress = "0x04718f5a0fc34cc1af16a1cdee98ffb20c31f5cd61d6ab07201858f4287c938d";

export declare interface StrongAccountInterface extends Omit<AccountInterface, "address"> {
    address: Address;
}

export declare interface StrongAccountInterface extends Omit<AccountInterface, "address" | "channel"> {
    address: Address;
}

declare class TelegramCloudStorage implements CloudStorageService {
    private validateKey;
    private validateValue;
    get(key: string): Promise<string | null>;
    set(key: string, value: string): Promise<void>;
    remove(key: string): Promise<void>;
    getAllKeys(): Promise<string[]>;
}

export { }
