(function(d,n){typeof exports=="object"&&typeof module<"u"?n(exports,require("starknet")):typeof define=="function"&&define.amd?define(["exports","starknet"],n):(d=typeof globalThis<"u"?globalThis:d||self,n(d.sessions={},d.starknet))})(this,function(d,n){"use strict";var ie=Object.defineProperty;var re=(d,n,p)=>n in d?ie(d,n,{enumerable:!0,configurable:!0,writable:!0,value:p}):d[n]=p;var N=(d,n,p)=>re(d,typeof n!="symbol"?n+"":n,p);const p="https://cloud.argent-api.com/v1";class T extends Error{constructor(t,s){super(t),this.cause=s,Error.captureStackTrace(this,this.constructor)}}const V=async({sessionKey:e,authorisationSignature:t,argentSessionServiceBaseUrl:s=p,calls:a,transactionsDetail:o,sessionTypedData:r,sessionSignature:i,cacheAuthorisation:c})=>{const u=n.transaction.getExecuteCalldata(a,o.cairoVersion),S=n.typedData.getMessageHash(r,o.walletAddress),h=n.stark.formatSignature(t),g={session:{sessionHash:S,sessionAuthorisation:h,cacheAuthorisation:c,sessionSignature:{type:"StarknetKey",signer:{publicKey:e.publicKey,r:i[0].toString(),s:i[1].toString()}}}};if(Object.values(n.RPC.ETransactionVersion2).includes(o.version)){const l=o;g.transaction={contractAddress:l.walletAddress,calldata:u,maxFee:l.maxFee.toString(),nonce:l.nonce.toString(),version:n.num.toBigInt(l.version).toString(10),chainId:n.num.toBigInt(l.chainId).toString(10)}}else if(Object.values(n.RPC.ETransactionVersion3).includes(o.version)){const l=o;g.transaction={sender_address:l.walletAddress,calldata:u,nonce:l.nonce.toString(),version:n.num.toBigInt(l.version).toString(10),chain_id:n.num.toBigInt(l.chainId).toString(10),resource_bounds:{l1_gas:{max_amount:l.resourceBounds.l1_gas.max_amount.toString(),max_price_per_unit:l.resourceBounds.l1_gas.max_price_per_unit.toString()},l2_gas:{max_amount:l.resourceBounds.l1_gas.max_amount.toString(),max_price_per_unit:l.resourceBounds.l1_gas.max_price_per_unit.toString()}},tip:l.tip.toString(),paymaster_data:l.paymasterData.map(A=>A.toString()),account_deployment_data:l.accountDeploymentData,nonce_data_availability_mode:l.nonceDataAvailabilityMode,fee_data_availability_mode:l.feeDataAvailabilityMode}}else throw Error("unsupported signTransaction version");const m=await fetch(`${s}/cosigner/signSession`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(g)});if(!m.ok){const l=await m.json();throw new T("Sign session error",l.status)}return(await m.json()).signature},U=async({sessionKey:e,authorisationSignature:t,argentSessionServiceBaseUrl:s=p,sessionTokenToSign:a,accountAddress:o,currentTypedData:r,sessionSignature:i,cacheAuthorisation:c,chainId:u,network:S="mainnet"})=>{const h=n.typedData.getMessageHash(x(a,u),o),y=n.stark.formatSignature(t),f={session:{sessionHash:h,sessionAuthorisation:y,cacheAuthorisation:c,sessionSignature:{type:"StarknetKey",signer:{publicKey:e.publicKey,r:i[0].toString(),s:i[1].toString()}}},message:{type:"eip712",accountAddress:o,chain:"starknet",message:r,network:S}},l=JSON.stringify(f,(j,b)=>typeof b=="bigint"?b.toString():b),A=await fetch(`${s}/cosigner/signSessionEFO`,{method:"POST",headers:{"Content-Type":"application/json"},body:l});if(!A.ok){const j=await A.json();throw new T("Sign session error",j.status)}return(await A.json()).signature};class W extends n.Signer{constructor(t){super(),this.signTransactionCallback=t}async signRaw(t){throw new Error("Method not implemented.")}async signTransaction(t,s){return this.signTransactionCallback(t,s)}}var _=(e=>(e[e.Starknet=0]="Starknet",e[e.Secp256k1=1]="Secp256k1",e[e.Secp256r1=2]="Secp256r1",e[e.Eip191=3]="Eip191",e[e.Webauthn=4]="Webauthn",e))(_||{});const F=(e,t)=>{const s={Starknet:void 0,Secp256k1:void 0,Secp256r1:void 0,Eip191:void 0,Webauthn:void 0};if(e===_.Starknet)s.Starknet=t;else if(e===_.Secp256k1)s.Secp256k1=t;else if(e===_.Secp256r1)s.Secp256r1=t;else if(e===_.Eip191)s.Eip191=t;else if(e===_.Webauthn)s.Webauthn=t;else throw new Error("Unknown SignerType");return new n.CairoCustomEnum(s)},C=e=>{const t=e.allowed_methods.map(s=>n.hash.computePoseidonHashOnElements([I,s["Contract Address"],n.selector.getSelectorFromName(s.selector)]));return new n.merkle.MerkleTree(t,n.hash.computePoseidonHash)},D=e=>{const t=n.byteArray.byteArrayFromString(e.metadata),s=[t.data.length,...t.data,t.pending_word,t.pending_word_len],a=n.hash.computePoseidonHashOnElements(s);return{expires_at:e.expires_at,allowed_methods_root:C(e).root.toString(),metadata_hash:a,session_key_guid:e.session_key_guid}},G=(e,t)=>{const s=C(e);return t.map(a=>{const o=e.allowed_methods.findIndex(r=>n.num.hexToDecimalString(r["Contract Address"])===n.num.hexToDecimalString(a.contractAddress)&&r.selector==a.entrypoint);return s.getProof(s.leaves[o],s.leaves)})},H=(e,t)=>F(_.Starknet,{pubkey:e,r:t[0],s:t[1]}),M=async(e,t,s,a,o,r,i,c)=>({session:e,cache_authorization:c,session_authorization:r,sessionSignature:H(s.publicKey,o),guardianSignature:H(i.publicKey,[i.r,i.s]),proofs:G(t,a)}),O=(e,t,s,a,o)=>{const r=n.typedData.getMessageHash(s,t),i=n.hash.computePoseidonHashOnElements([e,r,+a]),c=n.ec.starkCurve.sign(i,o.privateKey);return[c.r,c.s]},L=n.shortString.encodeShortString("session-token");class R{constructor(t,s,a=p){N(this,"argentSessionServiceUrl");this.session=t,this.sessionKey=s,this.argentSessionServiceUrl=a}getAccountWithSessionSigner({provider:t,session:s,cacheAuthorisation:a=!1}){const o=new W((r,i)=>this.signTransaction(n.stark.formatSignature(s.authorisationSignature),s,r,i,a));return new n.Account(t,s.address,o)}async signTransaction(t,s,a,o,r){const i=n.transaction.getExecuteCalldata(a,o.cairoVersion);let c;if(Object.values(n.RPC.ETransactionVersion2).includes(o.version)){const u=o;c=n.hash.calculateInvokeTransactionHash({...u,senderAddress:u.walletAddress,compiledCalldata:i,version:u.version})}else if(Object.values(n.RPC.ETransactionVersion3).includes(o.version)){const u=o;c=n.hash.calculateInvokeTransactionHash({...u,senderAddress:u.walletAddress,compiledCalldata:i,version:u.version,nonceDataAvailabilityMode:n.stark.intDAM(u.nonceDataAvailabilityMode),feeDataAvailabilityMode:n.stark.intDAM(u.feeDataAvailabilityMode)})}else throw Error("unsupported signTransaction version");return this.getSessionSignatureForTransaction({sessionAuthorizationSignature:t,session:s,transactionHash:c,calls:a,accountAddress:o.walletAddress,invocationSignerDetails:o,cacheAuthorisation:r})}async getSessionSignatureForTransaction({sessionAuthorizationSignature:t,session:s,transactionHash:a,calls:o,accountAddress:r,invocationSignerDetails:i,cacheAuthorisation:c}){const u={allowed_methods:s.allowedMethods,expires_at:s.expiresAt,metadata:s.metadata,session_key_guid:s.sessionKeyGuid},S=D(u),h=x(u,this.session.chainId),y=O(a,r,h,c,this.sessionKey),g=await V({sessionKey:this.sessionKey,authorisationSignature:this.session.authorisationSignature,argentSessionServiceBaseUrl:this.argentSessionServiceUrl,calls:o,transactionsDetail:i,sessionTypedData:h,sessionSignature:y,cacheAuthorisation:c}),m=await M(S,u,this.sessionKey,o,y,t,g,c);return[L,...n.CallData.compile(m)]}}const w={StarknetDomain:[{name:"name",type:"shortstring"},{name:"version",type:"shortstring"},{name:"chainId",type:"shortstring"},{name:"revision",type:"shortstring"}],"Allowed Method":[{name:"Contract Address",type:"ContractAddress"},{name:"selector",type:"selector"}],Session:[{name:"Expires At",type:"timestamp"},{name:"Allowed Methods",type:"merkletree",contains:"Allowed Method"},{name:"Metadata",type:"string"},{name:"Session Key",type:"felt"}]},I=n.typedData.getTypeHash(w,"Allowed Method",n.typedData.TypedDataRevision.ACTIVE),K=e=>({name:"SessionAccount.session",version:n.shortString.encodeShortString("1"),chainId:e,revision:"1"}),x=(e,t)=>({types:w,primaryType:"Session",domain:K(t),message:{"Expires At":e.expires_at,"Allowed Methods":e.allowed_methods,Metadata:e.metadata,"Session Key":e.session_key_guid}}),P=(e,t,s,a)=>({expires_at:Number(t),allowed_methods:e,metadata:JSON.stringify(s),session_key_guid:n.hash.computePoseidonHash(n.shortString.encodeShortString("Starknet Signer"),a)}),J=async({session:e,sessionKey:t,provider:s,argentSessionServiceBaseUrl:a,useCacheAuthorisation:o})=>new R(e,t,a).getAccountWithSessionSigner({provider:s,session:e,cacheAuthorisation:o}),$=({chainId:e,sessionParams:t})=>{const{allowedMethods:s,expiry:a=BigInt(Date.now())+10000n,sessionKey:o,metaData:r}=t;if(!o||!o.publicKey)throw new Error("sessionPublicKey is required");const i=P(s,a,r,o.publicKey);return{sessionTypedData:x(i,e),offchainSession:i,sessionKey:o}},Y=async({address:e,authorisationSignature:t,sessionRequest:s,chainId:a})=>{const{sessionKey:o,sessionTypedData:r,offchainSession:i}=s;if(!o||!o.publicKey)throw new Error("sessionPublicKey is required");return{authorisationSignature:t,address:e,chainId:a,hash:n.typedData.getMessageHash(r,e),version:n.shortString.encodeShortString("1"),expiresAt:i.expires_at,allowedMethods:i.allowed_methods,metadata:i.metadata,sessionKeyGuid:i.session_key_guid,sessionKey:o}},k=({session:e,sessionKey:t})=>{const s={allowed_methods:e.allowedMethods,expires_at:e.expiresAt,metadata:e.metadata,session_key_guid:e.sessionKeyGuid},a=x(s,e.chainId),o=n.typedData.getMessageHash(a,e.address);return n.ec.starkCurve.sign(e.hash,t.privateKey)&&e.hash===o},z=e=>n.encode.addHexPrefix(n.encode.buf2hex(e)),Q=e=>{const s=n.encode.removeHexPrefix(e).match(/.{1,2}/g);if(!s)throw new Error("Invalid hex string");return Uint8Array.from(s.map(a=>parseInt(a,16)))};/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function X(e){return e instanceof Uint8Array||e!=null&&typeof e=="object"&&e.constructor.name==="Uint8Array"}function Z(e){if(!X(e))throw new Error("Uint8Array expected")}const q=Array.from({length:256},(e,t)=>t.toString(16).padStart(2,"0"));function ee(e){Z(e);let t="";for(let s=0;s<e.length;s++)t+=q[e[s]];return t}const te={StarknetDomain:[{name:"name",type:"shortstring"},{name:"version",type:"shortstring"},{name:"chainId",type:"shortstring"},{name:"revision",type:"shortstring"}],OutsideExecution:[{name:"Caller",type:"ContractAddress"},{name:"Nonce",type:"felt"},{name:"Execute After",type:"u128"},{name:"Execute Before",type:"u128"},{name:"Calls",type:"Call*"}],Call:[{name:"To",type:"ContractAddress"},{name:"Selector",type:"selector"},{name:"Calldata",type:"felt*"}]};function ne(e,t="1"){return{name:"Account.execute_from_outside",version:t,chainId:e,revision:"1"}}function se(e){return{to:e.contractAddress,selector:n.hash.getSelectorFromName(e.entrypoint),calldata:e.calldata??[]}}const v=(e,t,s,a,o)=>{const r=n.shortString.encodeShortString("ANY_CALLER"),i=n.encode.addHexPrefix(ee(n.ec.starkCurve.utils.randomPrivateKey())),c=Date.now(),u=Math.floor((c+6e4*20)/1e3),S=Math.floor((c-6e4*10)/1e3);return{caller:t||r,nonce:o||i,execute_after:s||S,execute_before:a||u,calls:e.map(h=>se(h))}},oe=async({session:e,sessionKey:t,cacheAuthorisation:s,calls:a,outsideExecutionParams:o,argentSessionServiceUrl:r=p,network:i="mainnet"})=>{const{caller:c,execute_after:u,execute_before:S,nonce:h,version:y}=o||{},g=v(a,c,u,S,h),m=B({outsideExecution:g,chainId:e.chainId,version:y||"2"}),f=await E({session:e,sessionKey:t,argentSessionServiceUrl:r,outsideExecutionTypedData:m,cacheAuthorisation:s,calls:a,network:i});return{contractAddress:e.address,entrypoint:"execute_from_outside_v2",calldata:n.CallData.compile({...g,signature:f})}},ae=async({session:e,sessionKey:t,cacheAuthorisation:s,calls:a,outsideExecutionParams:o,argentSessionServiceUrl:r=p,network:i="mainnet"})=>{const{caller:c,execute_after:u,execute_before:S,nonce:h,version:y}=o||{},g=v(a,c,u,S,h),m=B({outsideExecution:g,chainId:e.chainId,version:y||"1"}),f=await E({argentSessionServiceUrl:r,cacheAuthorisation:s,calls:a,outsideExecutionTypedData:m,session:e,sessionKey:t,network:i});return{outsideExecutionTypedData:m,signature:f}},B=({outsideExecution:e,chainId:t,version:s="1"})=>({types:te,primaryType:"OutsideExecution",domain:ne(t,s),message:{Caller:e.caller,Nonce:e.nonce,"Execute After":e.execute_after,"Execute Before":e.execute_before,Calls:e.calls.map(a=>({To:a.to,Selector:a.selector,Calldata:a.calldata}))}}),E=async({session:e,sessionKey:t,outsideExecutionTypedData:s,argentSessionServiceUrl:a=p,cacheAuthorisation:o=!1,calls:r,network:i="mainnet"})=>{const c={expires_at:e.expiresAt,allowed_methods:e.allowedMethods,metadata:e.metadata,session_key_guid:e.sessionKeyGuid},u=n.shortString.encodeShortString("session-token"),S=D(c),h=x(c,e.chainId),y=n.typedData.getMessageHash(s,e.address),g=O(y,e.address,h,o,t),m=await U({sessionKey:t,authorisationSignature:e.authorisationSignature,argentSessionServiceBaseUrl:a,sessionTokenToSign:c,accountAddress:e.address,currentTypedData:s,sessionSignature:g,cacheAuthorisation:o,chainId:e.chainId,network:i}),f=await M(S,c,t,r,g,n.stark.formatSignature(e.authorisationSignature),m,o);return[u,...n.CallData.compile(f)].map(l=>n.num.toHex(l))};d.ALLOWED_METHOD_HASH=I,d.buildOutsideExecution=v,d.buildSessionAccount=J,d.bytesToHexString=z,d.createOffchainSession=P,d.createOutsideExecutionCall=oe,d.createOutsideExecutionTypedData=ae,d.createSession=Y,d.createSessionRequest=$,d.getSessionDomain=K,d.getSessionTypedData=x,d.hexStringToBytes=Q,d.sessionTypes=w,d.signOutsideExecution=E,d.verifySession=k,Object.defineProperty(d,Symbol.toStringTag,{value:"Module"})});
