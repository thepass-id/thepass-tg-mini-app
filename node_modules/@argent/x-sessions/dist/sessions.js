var G = Object.defineProperty;
var L = (e, t, n) => t in e ? G(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n;
var I = (e, t, n) => L(e, typeof t != "symbol" ? t + "" : t, n);
import { typedData as S, stark as x, transaction as O, RPC as b, num as f, Signer as J, CairoCustomEnum as R, byteArray as $, hash as y, ec as C, selector as Y, merkle as z, shortString as A, Account as Q, CallData as M, encode as k } from "starknet";
const w = "https://cloud.argent-api.com/v1";
class K extends Error {
  constructor(t, n) {
    super(t), this.cause = n, Error.captureStackTrace(this, this.constructor);
  }
}
const X = async ({
  sessionKey: e,
  authorisationSignature: t,
  argentSessionServiceBaseUrl: n = w,
  calls: o,
  transactionsDetail: s,
  sessionTypedData: r,
  sessionSignature: a,
  cacheAuthorisation: i
}) => {
  const c = O.getExecuteCalldata(
    o,
    s.cairoVersion
  ), g = S.getMessageHash(
    r,
    s.walletAddress
  ), l = x.formatSignature(t), u = {
    session: {
      sessionHash: g,
      sessionAuthorisation: l,
      cacheAuthorisation: i,
      sessionSignature: {
        type: "StarknetKey",
        signer: {
          publicKey: e.publicKey,
          r: a[0].toString(),
          s: a[1].toString()
        }
      }
    }
  };
  if (Object.values(b.ETransactionVersion2).includes(
    s.version
  )) {
    const d = s;
    u.transaction = {
      contractAddress: d.walletAddress,
      calldata: c,
      maxFee: d.maxFee.toString(),
      nonce: d.nonce.toString(),
      version: f.toBigInt(d.version).toString(10),
      chainId: f.toBigInt(d.chainId).toString(10)
    };
  } else if (Object.values(b.ETransactionVersion3).includes(
    s.version
  )) {
    const d = s;
    u.transaction = {
      sender_address: d.walletAddress,
      calldata: c,
      nonce: d.nonce.toString(),
      version: f.toBigInt(d.version).toString(10),
      chain_id: f.toBigInt(d.chainId).toString(10),
      resource_bounds: {
        l1_gas: {
          max_amount: d.resourceBounds.l1_gas.max_amount.toString(),
          max_price_per_unit: d.resourceBounds.l1_gas.max_price_per_unit.toString()
        },
        l2_gas: {
          max_amount: d.resourceBounds.l1_gas.max_amount.toString(),
          max_price_per_unit: d.resourceBounds.l1_gas.max_price_per_unit.toString()
        }
      },
      tip: d.tip.toString(),
      paymaster_data: d.paymasterData.map((v) => v.toString()),
      account_deployment_data: d.accountDeploymentData,
      nonce_data_availability_mode: d.nonceDataAvailabilityMode,
      fee_data_availability_mode: d.feeDataAvailabilityMode
    };
  } else
    throw Error("unsupported signTransaction version");
  const p = await fetch(
    `${n}/cosigner/signSession`,
    {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify(u)
    }
  );
  if (!p.ok) {
    const d = await p.json();
    throw new K("Sign session error", d.status);
  }
  return (await p.json()).signature;
}, Z = async ({
  sessionKey: e,
  authorisationSignature: t,
  argentSessionServiceBaseUrl: n = w,
  sessionTokenToSign: o,
  accountAddress: s,
  currentTypedData: r,
  sessionSignature: a,
  cacheAuthorisation: i,
  chainId: c,
  network: g = "mainnet"
}) => {
  const l = S.getMessageHash(
    E(o, c),
    s
  ), h = x.formatSignature(t), m = {
    session: {
      sessionHash: l,
      sessionAuthorisation: h,
      cacheAuthorisation: i,
      sessionSignature: {
        type: "StarknetKey",
        signer: {
          publicKey: e.publicKey,
          r: a[0].toString(),
          s: a[1].toString()
        }
      }
    },
    message: {
      type: "eip712",
      accountAddress: s,
      chain: "starknet",
      message: r,
      network: g
    }
  }, d = JSON.stringify(
    m,
    (H, T) => typeof T == "bigint" ? T.toString() : T
  ), v = await fetch(
    `${n}/cosigner/signSessionEFO`,
    {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: d
    }
  );
  if (!v.ok) {
    const H = await v.json();
    throw new K("Sign session error", H.status);
  }
  return (await v.json()).signature;
};
class q extends J {
  constructor(t) {
    super(), this.signTransactionCallback = t;
  }
  async signRaw(t) {
    throw new Error("Method not implemented.");
  }
  async signTransaction(t, n) {
    return this.signTransactionCallback(t, n);
  }
}
var _ = /* @__PURE__ */ ((e) => (e[e.Starknet = 0] = "Starknet", e[e.Secp256k1 = 1] = "Secp256k1", e[e.Secp256r1 = 2] = "Secp256r1", e[e.Eip191 = 3] = "Eip191", e[e.Webauthn = 4] = "Webauthn", e))(_ || {});
const ee = (e, t) => {
  const n = {
    Starknet: void 0,
    Secp256k1: void 0,
    Secp256r1: void 0,
    Eip191: void 0,
    Webauthn: void 0
  };
  if (e === _.Starknet)
    n.Starknet = t;
  else if (e === _.Secp256k1)
    n.Secp256k1 = t;
  else if (e === _.Secp256r1)
    n.Secp256r1 = t;
  else if (e === _.Eip191)
    n.Eip191 = t;
  else if (e === _.Webauthn)
    n.Webauthn = t;
  else
    throw new Error("Unknown SignerType");
  return new R(n);
}, B = (e) => {
  const t = e.allowed_methods.map(
    (n) => y.computePoseidonHashOnElements([
      oe,
      n["Contract Address"],
      Y.getSelectorFromName(n.selector)
    ])
  );
  return new z.MerkleTree(t, y.computePoseidonHash);
}, P = (e) => {
  const t = $.byteArrayFromString(
    e.metadata
  ), n = [
    t.data.length,
    ...t.data,
    t.pending_word,
    t.pending_word_len
  ], o = y.computePoseidonHashOnElements(n);
  return {
    expires_at: e.expires_at,
    allowed_methods_root: B(e).root.toString(),
    metadata_hash: o,
    session_key_guid: e.session_key_guid
  };
}, te = (e, t) => {
  const n = B(e);
  return t.map((o) => {
    const s = e.allowed_methods.findIndex(
      (r) => f.hexToDecimalString(r["Contract Address"]) === f.hexToDecimalString(o.contractAddress) && r.selector == o.entrypoint
    );
    return n.getProof(n.leaves[s], n.leaves);
  });
}, D = (e, t) => ee(_.Starknet, {
  pubkey: e,
  r: t[0],
  s: t[1]
}), j = async (e, t, n, o, s, r, a, i) => ({
  session: e,
  cache_authorization: i,
  session_authorization: r,
  sessionSignature: D(
    n.publicKey,
    s
  ),
  guardianSignature: D(a.publicKey, [
    a.r,
    a.s
  ]),
  proofs: te(t, o)
}), N = (e, t, n, o, s) => {
  const r = S.getMessageHash(
    n,
    t
  ), a = y.computePoseidonHashOnElements([
    e,
    r,
    +o
  ]), i = C.starkCurve.sign(a, s.privateKey);
  return [i.r, i.s];
}, ne = A.encodeShortString("session-token");
class se {
  /**
   * Creates an instance of SessionAccount.
   * @param session - The session object containing session details.
   * @param sessionKey - The session key used for signing transactions.
   * @param argentSessionServiceUrl - The base URL for the Argent session service.
   */
  constructor(t, n, o = w) {
    I(this, "argentSessionServiceUrl");
    this.session = t, this.sessionKey = n, this.argentSessionServiceUrl = o;
  }
  /**
   * Retrieves an account with a session signer.
   *
   * @param {Object} params - The parameters for the function.
   * @param {Provider} params.provider - The provider to use for the account.
   * @param {Session} params.session - The session information.
   * @param {boolean} [params.cacheAuthorisation=false] - Whether to cache the authorisation signature.
   * @returns {Account} The account with the session signer.
   */
  getAccountWithSessionSigner({
    provider: t,
    session: n,
    cacheAuthorisation: o = !1
  }) {
    const s = new q(
      (r, a) => this.signTransaction(
        x.formatSignature(n.authorisationSignature),
        n,
        r,
        a,
        o
      )
    );
    return new Q(t, n.address, s);
  }
  async signTransaction(t, n, o, s, r) {
    const a = O.getExecuteCalldata(
      o,
      s.cairoVersion
    );
    let i;
    if (Object.values(b.ETransactionVersion2).includes(
      s.version
    )) {
      const c = s;
      i = y.calculateInvokeTransactionHash({
        ...c,
        senderAddress: c.walletAddress,
        compiledCalldata: a,
        version: c.version
      });
    } else if (Object.values(b.ETransactionVersion3).includes(
      s.version
    )) {
      const c = s;
      i = y.calculateInvokeTransactionHash({
        ...c,
        senderAddress: c.walletAddress,
        compiledCalldata: a,
        version: c.version,
        nonceDataAvailabilityMode: x.intDAM(
          c.nonceDataAvailabilityMode
        ),
        feeDataAvailabilityMode: x.intDAM(
          c.feeDataAvailabilityMode
        )
      });
    } else
      throw Error("unsupported signTransaction version");
    return this.getSessionSignatureForTransaction({
      sessionAuthorizationSignature: t,
      session: n,
      transactionHash: i,
      calls: o,
      accountAddress: s.walletAddress,
      invocationSignerDetails: s,
      cacheAuthorisation: r
    });
  }
  /**
   * Generates a session signature for a transaction.
   *
   * @param sessionAuthorizationSignature - The authorization signature for the session.
   * @param session - The session object containing session details.
   * @param transactionHash - The hash of the transaction.
   * @param calls - An array of calls to be made.
   * @param accountAddress - The address of the account.
   * @param invocationSignerDetails - Details of the invocation signer.
   * @param cacheAuthorisation - A boolean indicating whether to cache the authorization.
   * @returns A promise that resolves to an array containing the session signature.
   */
  async getSessionSignatureForTransaction({
    sessionAuthorizationSignature: t,
    session: n,
    transactionHash: o,
    calls: s,
    accountAddress: r,
    invocationSignerDetails: a,
    cacheAuthorisation: i
  }) {
    const c = {
      allowed_methods: n.allowedMethods,
      expires_at: n.expiresAt,
      metadata: n.metadata,
      session_key_guid: n.sessionKeyGuid
    }, g = P(c), l = E(
      c,
      this.session.chainId
    ), h = N(
      o,
      r,
      l,
      i,
      this.sessionKey
    ), u = await X({
      sessionKey: this.sessionKey,
      authorisationSignature: this.session.authorisationSignature,
      argentSessionServiceBaseUrl: this.argentSessionServiceUrl,
      calls: s,
      transactionsDetail: a,
      sessionTypedData: l,
      sessionSignature: h,
      cacheAuthorisation: i
    }), p = await j(
      g,
      c,
      this.sessionKey,
      s,
      h,
      t,
      u,
      i
    );
    return [ne, ...M.compile(p)];
  }
}
const V = {
  StarknetDomain: [
    { name: "name", type: "shortstring" },
    { name: "version", type: "shortstring" },
    { name: "chainId", type: "shortstring" },
    { name: "revision", type: "shortstring" }
  ],
  "Allowed Method": [
    { name: "Contract Address", type: "ContractAddress" },
    { name: "selector", type: "selector" }
  ],
  Session: [
    { name: "Expires At", type: "timestamp" },
    { name: "Allowed Methods", type: "merkletree", contains: "Allowed Method" },
    { name: "Metadata", type: "string" },
    { name: "Session Key", type: "felt" }
  ]
}, oe = S.getTypeHash(
  V,
  "Allowed Method",
  S.TypedDataRevision.ACTIVE
), ae = (e) => ({
  name: "SessionAccount.session",
  version: A.encodeShortString("1"),
  chainId: e,
  revision: "1"
}), E = (e, t) => ({
  types: V,
  primaryType: "Session",
  domain: ae(t),
  message: {
    "Expires At": e.expires_at,
    "Allowed Methods": e.allowed_methods,
    Metadata: e.metadata,
    "Session Key": e.session_key_guid
  }
}), re = (e, t, n, o) => ({
  expires_at: Number(t),
  allowed_methods: e,
  metadata: JSON.stringify(n),
  session_key_guid: y.computePoseidonHash(
    A.encodeShortString("Starknet Signer"),
    o
  )
}), ye = async ({
  session: e,
  sessionKey: t,
  provider: n,
  argentSessionServiceBaseUrl: o,
  useCacheAuthorisation: s
}) => new se(
  e,
  t,
  o
).getAccountWithSessionSigner({
  provider: n,
  session: e,
  cacheAuthorisation: s
}), _e = ({
  chainId: e,
  sessionParams: t
}) => {
  const {
    allowedMethods: n,
    expiry: o = BigInt(Date.now()) + 10000n,
    sessionKey: s,
    metaData: r
  } = t;
  if (!s || !s.publicKey)
    throw new Error("sessionPublicKey is required");
  const a = re(
    n,
    o,
    r,
    s.publicKey
  );
  return {
    sessionTypedData: E(a, e),
    offchainSession: a,
    sessionKey: s
  };
}, fe = async ({
  address: e,
  authorisationSignature: t,
  sessionRequest: n,
  chainId: o
}) => {
  const { sessionKey: s, sessionTypedData: r, offchainSession: a } = n;
  if (!s || !s.publicKey)
    throw new Error("sessionPublicKey is required");
  return {
    authorisationSignature: t,
    address: e,
    chainId: o,
    hash: S.getMessageHash(r, e),
    version: A.encodeShortString("1"),
    expiresAt: a.expires_at,
    allowedMethods: a.allowed_methods,
    metadata: a.metadata,
    sessionKeyGuid: a.session_key_guid,
    sessionKey: s
  };
}, xe = ({
  session: e,
  sessionKey: t
}) => {
  const n = {
    allowed_methods: e.allowedMethods,
    expires_at: e.expiresAt,
    metadata: e.metadata,
    session_key_guid: e.sessionKeyGuid
  }, o = E(n, e.chainId), s = S.getMessageHash(o, e.address);
  return C.starkCurve.sign(e.hash, t.privateKey) && e.hash === s;
}, Ae = (e) => k.addHexPrefix(k.buf2hex(e)), we = (e) => {
  const n = k.removeHexPrefix(e).match(/.{1,2}/g);
  if (!n)
    throw new Error("Invalid hex string");
  return Uint8Array.from(n.map((o) => parseInt(o, 16)));
};
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function ie(e) {
  return e instanceof Uint8Array || e != null && typeof e == "object" && e.constructor.name === "Uint8Array";
}
function ce(e) {
  if (!ie(e))
    throw new Error("Uint8Array expected");
}
const de = /* @__PURE__ */ Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, "0"));
function le(e) {
  ce(e);
  let t = "";
  for (let n = 0; n < e.length; n++)
    t += de[e[n]];
  return t;
}
const ue = {
  StarknetDomain: [
    { name: "name", type: "shortstring" },
    { name: "version", type: "shortstring" },
    { name: "chainId", type: "shortstring" },
    { name: "revision", type: "shortstring" }
  ],
  OutsideExecution: [
    { name: "Caller", type: "ContractAddress" },
    { name: "Nonce", type: "felt" },
    { name: "Execute After", type: "u128" },
    { name: "Execute Before", type: "u128" },
    { name: "Calls", type: "Call*" }
  ],
  Call: [
    { name: "To", type: "ContractAddress" },
    { name: "Selector", type: "selector" },
    { name: "Calldata", type: "felt*" }
  ]
};
function ge(e, t = "1") {
  return {
    name: "Account.execute_from_outside",
    version: t,
    chainId: e,
    revision: "1"
  };
}
function pe(e) {
  return {
    to: e.contractAddress,
    selector: y.getSelectorFromName(e.entrypoint),
    calldata: e.calldata ?? []
  };
}
const U = (e, t, n, o, s) => {
  const r = A.encodeShortString("ANY_CALLER"), a = k.addHexPrefix(
    le(C.starkCurve.utils.randomPrivateKey())
  ), i = Date.now(), c = Math.floor((i + 6e4 * 20) / 1e3), g = Math.floor((i - 6e4 * 10) / 1e3);
  return {
    caller: t || r,
    nonce: s || a,
    execute_after: n || g,
    execute_before: o || c,
    calls: e.map((l) => pe(l))
  };
}, ve = async ({
  session: e,
  sessionKey: t,
  cacheAuthorisation: n,
  calls: o,
  outsideExecutionParams: s,
  argentSessionServiceUrl: r = w,
  network: a = "mainnet"
}) => {
  const { caller: i, execute_after: c, execute_before: g, nonce: l, version: h } = s || {}, u = U(
    o,
    i,
    c,
    g,
    l
  ), p = F({
    outsideExecution: u,
    chainId: e.chainId,
    version: h || "2"
    // version, set as "2" because of a bug in x-sessions where default was wrongly set to "1"
  }), m = await W({
    session: e,
    sessionKey: t,
    argentSessionServiceUrl: r,
    outsideExecutionTypedData: p,
    cacheAuthorisation: n,
    calls: o,
    network: a
  });
  return {
    contractAddress: e.address,
    entrypoint: "execute_from_outside_v2",
    calldata: M.compile({ ...u, signature: m })
  };
}, Ee = async ({
  session: e,
  sessionKey: t,
  cacheAuthorisation: n,
  calls: o,
  outsideExecutionParams: s,
  argentSessionServiceUrl: r = w,
  network: a = "mainnet"
}) => {
  const { caller: i, execute_after: c, execute_before: g, nonce: l, version: h } = s || {}, u = U(
    o,
    i,
    c,
    g,
    l
  ), p = F({
    outsideExecution: u,
    chainId: e.chainId,
    version: h || "1"
  }), m = await W({
    argentSessionServiceUrl: r,
    cacheAuthorisation: n,
    calls: o,
    outsideExecutionTypedData: p,
    session: e,
    sessionKey: t,
    network: a
  });
  return {
    outsideExecutionTypedData: p,
    signature: m
  };
}, F = ({
  outsideExecution: e,
  chainId: t,
  version: n = "1"
}) => ({
  types: ue,
  primaryType: "OutsideExecution",
  domain: ge(t, n),
  message: {
    Caller: e.caller,
    Nonce: e.nonce,
    "Execute After": e.execute_after,
    "Execute Before": e.execute_before,
    Calls: e.calls.map((o) => ({
      To: o.to,
      Selector: o.selector,
      Calldata: o.calldata
    }))
  }
}), W = async ({
  session: e,
  sessionKey: t,
  outsideExecutionTypedData: n,
  argentSessionServiceUrl: o = w,
  cacheAuthorisation: s = !1,
  calls: r,
  network: a = "mainnet"
}) => {
  const i = {
    expires_at: e.expiresAt,
    allowed_methods: e.allowedMethods,
    metadata: e.metadata,
    session_key_guid: e.sessionKeyGuid
  }, c = A.encodeShortString("session-token"), g = P(i), l = E(i, e.chainId), h = S.getMessageHash(
    n,
    e.address
  ), u = N(
    h,
    e.address,
    l,
    s,
    t
  ), p = await Z({
    sessionKey: t,
    authorisationSignature: e.authorisationSignature,
    argentSessionServiceBaseUrl: o,
    sessionTokenToSign: i,
    accountAddress: e.address,
    currentTypedData: n,
    sessionSignature: u,
    cacheAuthorisation: s,
    chainId: e.chainId,
    network: a
  }), m = await j(
    g,
    i,
    t,
    r,
    u,
    x.formatSignature(e.authorisationSignature),
    p,
    s
  );
  return [c, ...M.compile(m)].map(
    (d) => f.toHex(d)
  );
};
export {
  oe as ALLOWED_METHOD_HASH,
  U as buildOutsideExecution,
  ye as buildSessionAccount,
  Ae as bytesToHexString,
  re as createOffchainSession,
  ve as createOutsideExecutionCall,
  Ee as createOutsideExecutionTypedData,
  fe as createSession,
  _e as createSessionRequest,
  ae as getSessionDomain,
  E as getSessionTypedData,
  we as hexStringToBytes,
  V as sessionTypes,
  W as signOutsideExecution,
  xe as verifySession
};
