{"version":3,"sources":["../src/index.ts","../src/constants.ts","../src/fixtures.ts","../src/services.ts","../src/types.ts"],"sourcesContent":["export * from './constants';\nexport * from './fixtures';\nexport * from './services';\nexport * from './types';\n","export const SEPOLIA_BASE_URL = 'https://sepolia.api.avnu.fi';\nexport const BASE_URL = 'https://starknet.api.avnu.fi';\n","import { parseUnits } from 'ethers';\nimport { GasTokenPrice } from './types';\n\nexport const aListOfGasTokenPrices = (): GasTokenPrice[] => [\n  {\n    // USDC\n    tokenAddress: '0x053c91253bc9682c04929ca02ed00b3e423f6710d2ee7e0d5ebb06f3ecf368a8',\n    priceInETH: parseUnits('0.0005', 18),\n    priceInUSD: 1.0,\n    decimals: 6,\n  },\n  {\n    // USDT\n    tokenAddress: '0x068f5c6a61780768455de69077e07e89787839bf8166decfbf92b645209c0fb8',\n    priceInETH: parseUnits('0.0005', 18),\n    priceInUSD: 1.0,\n    decimals: 6,\n  },\n];\n","import { toBeHex } from 'ethers';\nimport qs from 'qs';\nimport { AccountInterface, Call, CallData, ec, hash, RawArgs, Signature, TypedData } from 'starknet';\nimport { BASE_URL } from './constants';\nimport {\n  AccountsRewardsOptions,\n  ContractError,\n  DeploymentData,\n  ExecuteCallsOptions,\n  GaslessCompatibility,\n  GaslessOptions,\n  GaslessStatus,\n  GasTokenPrice,\n  InvokeResponse,\n  PaymasterReward,\n  RequestError,\n} from './types';\n\nconst baseUrl = (options?: GaslessOptions): string => options?.baseUrl ?? BASE_URL;\nconst getRequest = (options?: GaslessOptions): RequestInit => ({\n  signal: options?.abortSignal,\n  headers: {\n    ...(options?.apiPublicKey !== undefined && { 'ask-signature': 'true' }),\n    ...(options?.apiKey && { 'api-key': options.apiKey }),\n  },\n});\nconst postRequest = (body: unknown, options?: GaslessOptions): RequestInit => ({\n  method: 'POST',\n  headers: {\n    Accept: 'application/json',\n    'Content-Type': 'application/json',\n    ...(options?.apiKey && { 'api-key': options.apiKey }),\n    ...(options?.apiPublicKey && { 'ask-signature': 'true' }),\n  },\n  body: JSON.stringify(body),\n});\n\nconst parseResponse = <T>(response: Response, apiPublicKey?: string): Promise<T> => {\n  if (response.status === 400) {\n    return response.json().then((error: RequestError) => {\n      throw new Error(error.messages[0]);\n    });\n  }\n  if (response.status === 500) {\n    return response.json().then((error: RequestError) => {\n      if (error.messages.length >= 0 && error.messages[0].includes('Contract error')) {\n        throw new ContractError(error.messages[0], error.revertError || '');\n      } else {\n        throw new Error(error.messages[0]);\n      }\n    });\n  }\n  if (response.status > 400) {\n    throw new Error(`${response.status} ${response.statusText}`);\n  }\n  if (apiPublicKey) {\n    const signature = response.headers.get('signature');\n    if (!signature) throw new Error('No server signature');\n    return response\n      .clone()\n      .text()\n      .then((textResponse) => {\n        const hashResponse = hash.computeHashOnElements([hash.starknetKeccak(textResponse)]);\n        const formattedSig = signature.split(',').map((s) => BigInt(s));\n        const signatureType = new ec.starkCurve.Signature(formattedSig[0], formattedSig[1]);\n        if (!ec.starkCurve.verify(signatureType, hashResponse, apiPublicKey))\n          throw new Error('Invalid server signature');\n      })\n      .then(() => response.json());\n  }\n  return response.json();\n};\n\n/**\n * Calls API to know if gasless service is up\n * @param options Optional options\n */\nconst fetchGaslessStatus = (options?: GaslessOptions): Promise<GaslessStatus> =>\n  fetch(`${baseUrl(options)}/paymaster/v1/status`, getRequest(options)).then((response) =>\n    parseResponse<GaslessStatus>(response, options?.apiPublicKey),\n  );\n\n/**\n * Calls API to know if the account can use the gasless feature\n * If not, the user may need to upgrade his contract or use a compatible wallet\n * @param accountAddress The account address\n * @param options Optional options\n */\nconst fetchAccountCompatibility = (accountAddress: string, options?: GaslessOptions): Promise<GaslessCompatibility> =>\n  fetch(`${baseUrl(options)}/paymaster/v1/accounts/${accountAddress}/compatible`, getRequest(options))\n    .then((response) => parseResponse<GaslessCompatibility>(response, options?.apiPublicKey))\n    .then((response) => ({\n      ...response,\n      gasConsumedOverhead: BigInt(response.gasConsumedOverhead),\n      dataGasConsumedOverhead: BigInt(response.dataGasConsumedOverhead),\n    }));\n\n/**\n * Fetches the list of user's paymaster rewards.\n * Rewards are registered by a sponsor. This sponsor will pay account's gas fees.\n * @param accountAddress The account address\n * @param options Optional options\n */\nconst fetchAccountsRewards = (\n  accountAddress: string,\n  options?: AccountsRewardsOptions & GaslessOptions,\n): Promise<PaymasterReward[]> => {\n  const queryParams = qs.stringify(\n    {\n      ...(options?.sponsor && { sponsor: options.sponsor }),\n      ...(options?.campaign && { campaign: options.campaign }),\n      ...(options?.protocol && { protocol: options.protocol }),\n    },\n    { arrayFormat: 'repeat' },\n  );\n  return fetch(\n    `${baseUrl(options)}/paymaster/v1/accounts/${accountAddress}/rewards?${queryParams}`,\n    getRequest(options),\n  ).then((response) => parseResponse<PaymasterReward[]>(response, options?.apiPublicKey));\n};\n\n/**\n * Calls API to retrieve gas token prices\n * @param options Optional options\n */\nconst fetchGasTokenPrices = (options?: GaslessOptions): Promise<GasTokenPrice[]> =>\n  fetch(`${baseUrl(options)}/paymaster/v1/gas-token-prices`, getRequest(options))\n    .then((response) => parseResponse<GasTokenPrice[]>(response, options?.apiPublicKey))\n    .then((prices) =>\n      prices.map((price) => ({\n        ...price,\n        priceInETH: BigInt(price.priceInETH),\n      })),\n    );\n\n/**\n * Calls API to retrieve the typed data that the user will have to sign.\n * @param userAddress The user's address\n * @param calls The list of calls that will be executed\n * @param gasTokenAddress The gas token address that will be used to pay the gas fees. If null, there is two options:\n * 1. the user must have a reward compatible with the calls. In this case, the reward's sponsor will pay the gas fees in ETH.\n * 2. the api-key header must be field. The api-key's owner will be charged for the consumed gas fees in ETH\n * @param maxGasTokenAmount The maximum amount of gas token that the user is willing to spend. If null, there is two options:\n * 1. the user must have a reward compatible with the calls. In this case, the reward's sponsor will pay the gas fees in ETH.\n * 2. the api-key header must be field. The api-key's owner will be charged for the consumed gas fees in ETH\n * @param accountClassHash Only set this field when the account is not deployed.\n * When the accountClassHash is defined, the API will not check the gasless compatibility by calling\n * the supportsInterface entrypoint but will instead look into an internal map.\n * If the classHash is not supported by the API, please contact us so we can quickly add support.\n * @param options Optional options\n * @returns The best quotes\n */\nconst fetchBuildTypedData = (\n  userAddress: string,\n  calls: Call[],\n  gasTokenAddress: string | undefined,\n  maxGasTokenAmount: bigint | undefined,\n  options?: GaslessOptions,\n  accountClassHash?: string | undefined,\n): Promise<TypedData> =>\n  fetch(\n    `${baseUrl(options)}/paymaster/v1/build-typed-data`,\n    postRequest(\n      {\n        userAddress,\n        calls: formatCall(calls),\n        gasTokenAddress,\n        accountClassHash,\n        ...(maxGasTokenAmount !== undefined && { maxGasTokenAmount: toBeHex(maxGasTokenAmount) }),\n      },\n      options,\n    ),\n  ).then((response) => parseResponse<TypedData>(response, options?.apiPublicKey));\n\nconst formatCall = (calls: Call[]): Call[] =>\n  calls.map((call) => ({\n    contractAddress: call.contractAddress,\n    entrypoint: call.entrypoint,\n    calldata: (Array.isArray(call.calldata) && '__compiled__' in call.calldata\n      ? call.calldata // Calldata type\n      : CallData.compile(call.calldata as RawArgs)\n    ) // RawArgsObject | RawArgsArray type\n      .map((calldata) => toBeHex(calldata)),\n  }));\n\n/**\n * Calls API to execute transaction using the gasless feature\n * @param userAddress The user address\n * @param typedData The typed data that the user signed\n * @param signature The typed data's signature\n * @param deploymentData When this field is set, the paymaster will deploy the user's account\n * before executing the typed data. To retrieve the deployment data, you can read\n * https://community.starknet.io/t/snip-deployment-interface-between-dapps-and-wallets/101923.\n * For now, the paymaster only allows the deployment of account for sponsored transactions.\n * @param options Optional options.\n * @returns The best quotes\n */\nconst fetchExecuteTransaction = (\n  userAddress: string,\n  typedData: string,\n  signature: Signature,\n  options?: GaslessOptions,\n  deploymentData?: DeploymentData | undefined,\n): Promise<InvokeResponse> => {\n  if (Array.isArray(signature)) {\n    signature = signature.map((sig) => toBeHex(BigInt(sig)));\n  } else if (signature.r && signature.s) {\n    signature = [toBeHex(BigInt(signature.r)), toBeHex(BigInt(signature.s))];\n  }\n  return fetch(\n    `${baseUrl(options)}/paymaster/v1/execute`,\n    postRequest(\n      {\n        userAddress,\n        typedData,\n        signature,\n        ...(deploymentData && {\n          deploymentData: {\n            ...deploymentData,\n            sigdata: deploymentData.sigdata?.map((sig) => toBeHex(BigInt(sig))),\n          },\n        }),\n      },\n      options,\n    ),\n  ).then((response) => parseResponse<InvokeResponse>(response, options?.apiPublicKey));\n};\n\n/**\n * Execute list of calls using the gasless feature\n * You can directly provide the maxGasTokenAmount or let us compute it for you by providing estimatedGasFees, gasTokenPrices and maxFeesOverhead\n * @param account The user's account\n * @param calls Calls that will be executed\n * @param gasTokenAddress The gas token address that will be used to pay the gas fees. If null, there is two options:\n * 1. the user must have a reward compatible with the calls. In this case, the reward's sponsor will pay the gas fees in ETH.\n * 2. the api-key header must be field. The api-key's owner will be charged for the consumed gas fees in ETH\n * @param maxGasTokenAmount The maximum amount of gas token that the user is willing to spend. If null, there is two options:\n * 1. the user must have a reward compatible with the calls. In this case, the reward's sponsor will pay the gas fees in ETH.\n * 2. the api-key header must be field. The api-key's owner will be charged for the consumed gas fees in ETH\n * @param estimatedGasFees The estimated gas fees amount in ETH\n * @param options Optional options.\n * @returns Promise<InvokeSwapResponse>\n */\nconst executeCalls = async (\n  account: AccountInterface,\n  calls: Call[],\n  { gasTokenAddress, maxGasTokenAmount, deploymentData }: ExecuteCallsOptions,\n  options?: GaslessOptions,\n): Promise<InvokeResponse> => {\n  const accountClassHash = deploymentData ? deploymentData.class_hash : undefined;\n  const typedData = await fetchBuildTypedData(\n    account.address,\n    calls,\n    gasTokenAddress,\n    maxGasTokenAmount,\n    options,\n    accountClassHash,\n  );\n  const signature = await account.signMessage(typedData);\n  return fetchExecuteTransaction(account.address, JSON.stringify(typedData), signature, options, deploymentData).then(\n    (value) => ({\n      transactionHash: value.transactionHash,\n    }),\n  );\n};\n\nconst shouldAddValidationOverhead = (\n  gasCost: bigint | undefined,\n  dataGasCost: bigint | undefined,\n  gasConsumedOverhead: bigint,\n  dataGasConsumedOverhead: bigint,\n): boolean => {\n  if (gasCost === undefined || dataGasCost === undefined) return false;\n  return !(gasConsumedOverhead === BigInt(0) && dataGasConsumedOverhead === BigInt(0));\n};\n\nconst addValidationGasOverhead = (\n  estimatedGasFees: bigint,\n  gasCost: bigint | undefined,\n  dataGasCost: bigint | undefined,\n  gasConsumedOverhead: bigint,\n  dataGasConsumedOverhead: bigint,\n): bigint => {\n  if (shouldAddValidationOverhead(gasCost, dataGasCost, gasConsumedOverhead, dataGasConsumedOverhead)) {\n    return estimatedGasFees + gasCost! * gasConsumedOverhead + dataGasCost! * dataGasConsumedOverhead;\n  }\n  return estimatedGasFees;\n};\n\n/**\n * Calculate the gas fees in gas token\n * @param estimatedGasFeesInETH The estimated amount gas fees (overall_fee)\n * @param gasTokenPrice The selected gasTokenPrice\n * @param gasCost The current gas_price\n * @param dataGasCost The current data_gas_price\n * @param gasConsumedOverhead The gaslessCompatibility's gasConsumedOverhead (see fetchAccountCompatibility)\n * @param dataGasConsumedOverhead The gaslessCompatibility's dataGasConsumedOverhead (see fetchAccountCompatibility)\n * @returns bigint\n */\nconst getGasFeesInGasToken = (\n  estimatedGasFeesInETH: bigint,\n  gasTokenPrice: GasTokenPrice,\n  gasCost: bigint | undefined,\n  dataGasCost: bigint | undefined,\n  gasConsumedOverhead: bigint,\n  dataGasConsumedOverhead: bigint,\n): bigint => {\n  const gasFeesInETH: bigint = addValidationGasOverhead(\n    estimatedGasFeesInETH,\n    gasCost,\n    dataGasCost,\n    gasConsumedOverhead,\n    dataGasConsumedOverhead,\n  );\n  const gasFeesInGasToken = Number(gasFeesInETH) / Number(gasTokenPrice.priceInETH);\n  return BigInt(Math.round(gasFeesInGasToken * 10 ** gasTokenPrice.decimals));\n};\n\nexport {\n  executeCalls,\n  fetchAccountCompatibility,\n  fetchAccountsRewards,\n  fetchBuildTypedData,\n  fetchExecuteTransaction,\n  fetchGaslessStatus,\n  fetchGasTokenPrices,\n  formatCall,\n  getGasFeesInGasToken,\n};\n","export interface GaslessStatus {\n  //The gasless status\n  status: boolean;\n}\n\nexport interface GaslessCompatibility {\n  //Indicates if the account is compatible with the gasless service\n  isCompatible: boolean;\n  //The validation's gas consumed overhead\n  gasConsumedOverhead: bigint;\n  //The validation's data gas consumed overhead\n  dataGasConsumedOverhead: bigint;\n}\n\nexport interface GasTokenPrice {\n  // The gas token's address\n  tokenAddress: string;\n  // The price of 1 token in ETH\n  priceInETH: bigint;\n  // The price of 1 token in USD\n  priceInUSD: number;\n  // The token's number of decimals\n  decimals: number;\n}\n\nexport interface PaymasterReward {\n  // Reward's creation date\n  date: Date;\n  // The user's address\n  address: string;\n  // The company that will pay the gas fees\n  sponsor: string;\n  // The name of the company's campaign\n  campaign: string;\n  // The protocol where the reward can be used\n  protocol: string | undefined;\n  // The number of free transaction\n  freeTx: number;\n  // The number of remaining transactions\n  remainingTx: number;\n  // Reward's expiration date\n  expirationDate: Date | undefined;\n  // The list of whitelisted calls\n  whitelistedCalls: WhitelistedCall[];\n}\n\nexport interface WhitelistedCall {\n  // The value can be '*' if all contracts are whitelisted or can be the contract address (hex format)\n  contractAddress: string;\n  // The value can be '*' if all entrypoint are whitelisted or can be the entrypoint name (string format)\n  entrypoint: string;\n}\n\nexport interface AccountsRewardsOptions {\n  sponsor?: string;\n  campaign?: string;\n  protocol?: string;\n}\n\nexport interface DeploymentData {\n  class_hash: string;\n  salt: string;\n  unique: string;\n  calldata: string[];\n  sigdata?: string[];\n}\n\nexport interface ExecuteCallsOptions {\n  gasTokenAddress?: string;\n  maxGasTokenAmount?: bigint;\n  deploymentData?: DeploymentData;\n}\n\nexport interface GaslessOptions {\n  baseUrl?: string;\n  // The api key allows you to sponsor the gas fees for your users\n  apiKey?: string;\n  abortSignal?: AbortSignal;\n  apiPublicKey?: string;\n}\n\nexport interface RequestError {\n  messages: string[];\n  revertError: string | undefined;\n}\n\nexport interface InvokeResponse {\n  transactionHash: string;\n}\n\nexport class ContractError {\n  constructor(\n    public message: string,\n    public revertError: string,\n  ) {}\n}\n"],"mappings":"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","names":["import_ethers","qs"]}